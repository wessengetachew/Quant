<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gap-Class Decomposition of ζ(2) = π²/6 | Mathematical Research Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            background: #0a0a0f; 
            color: #e0e0e0;
            line-height: 1.6;
        }
        
        .header { 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
            padding: 40px;
            border-bottom: 2px solid #2a2a4a;
        }
        .header h1 { 
            font-size: 2.2rem; 
            color: #ffd700; 
            margin-bottom: 12px;
            letter-spacing: -0.5px;
        }
        .header .subtitle { 
            color: #aaa; 
            font-size: 1.1rem; 
            margin-bottom: 8px;
        }
        .header .author { 
            color: #888; 
            font-size: 0.95rem;
        }
        
        .introduction {
            max-width: 1400px;
            margin: 40px auto;
            padding: 0 40px;
        }
        
        .intro-section {
            background: #12121a;
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            padding: 32px;
            margin-bottom: 24px;
        }
        
        .intro-section h2 {
            color: #ffd700;
            font-size: 1.6rem;
            margin-bottom: 20px;
            border-bottom: 2px solid #2a2a4a;
            padding-bottom: 10px;
        }
        
        .intro-section h3 {
            color: #ffd700;
            font-size: 1.2rem;
            margin: 24px 0 12px 0;
        }
        
        .intro-section p {
            margin-bottom: 16px;
            color: #ccc;
            font-size: 1rem;
        }
        
        .intro-section ul {
            margin-left: 24px;
            margin-bottom: 16px;
            color: #ccc;
        }
        
        .intro-section li {
            margin-bottom: 10px;
        }
        
        .formula-box {
            background: #1a1a2a;
            padding: 20px;
            border-radius: 6px;
            font-family: 'Times New Roman', serif;
            font-size: 1.3rem;
            text-align: center;
            color: #ffd700;
            margin: 20px 0;
            border-left: 4px solid #ffd700;
        }
        
        .research-question {
            background: linear-gradient(135deg, #1a1a2a 0%, #2a1a1a 100%);
            padding: 24px;
            border-radius: 6px;
            border-left: 4px solid #ff6464;
            margin: 20px 0;
        }
        
        .research-question h3 {
            color: #ff6464;
            margin-bottom: 12px;
        }
        
        .controls-container {
            max-width: 1400px;
            margin: 0 auto 30px auto;
            padding: 0 40px;
        }
        
        .control-panel {
            background: #12121a;
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .control-panel h3 {
            color: #ffd700;
            font-size: 1.1rem;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a2a4a;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }
        
        .control-value {
            color: #ffd700;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 10px;
            background: #1a1a2a;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        
        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #ffd700;
        }
        
        .btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
            border: none;
            border-radius: 4px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: #2a2a4a;
            color: #e0e0e0;
        }
        
        .btn-secondary:hover {
            background: #3a3a5a;
            box-shadow: none;
        }

        .preset-btn {
            padding: 6px 12px;
            background: #1e40af;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: #2563eb;
            transform: scale(1.05);
        }

        .preset-btn:active {
            transform: scale(0.98);
        }
        
        .button-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .charts-container {
            max-width: 3840px;
            margin: 0 auto;
            padding: 0 40px 40px 40px;
        }
        
        .chart-wrapper {
            background: #12121a;
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            padding: 20px;
            margin-bottom: 24px;
        }
        
        .chart-title {
            color: #ffd700;
            font-size: 1.2rem;
            margin-bottom: 16px;
            font-weight: 600;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: auto;
            background: #0a0a10;
            border-radius: 4px;
        }
        
        .status-bar {
            background: #1a1a2a;
            padding: 12px 20px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .status-bar.computing {
            color: #ffd700;
            border-left: 4px solid #ffd700;
        }
        
        .status-bar.complete {
            color: #64ff64;
            border-left: 4px solid #64ff64;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: #1a1a2a;
            padding: 16px;
            border-radius: 6px;
            border-left: 3px solid #ffd700;
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        .stat-value {
            font-size: 1.4rem;
            color: #ffd700;
            font-family: monospace;
        }
        
        .toggle-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }
        
        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            inset: 0;
            background: #2a2a4a;
            border-radius: 13px;
            cursor: pointer;
            transition: 0.3s;
        }
        
        .toggle-slider:before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            left: 3px;
            top: 3px;
            background: #666;
            border-radius: 50%;
            transition: 0.3s;
        }
        
        .toggle input:checked + .toggle-slider {
            background: #ffd700;
        }
        
        .toggle input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background: #000;
        }
        
        .animation-controls {
            background: #1a1a2a;
            padding: 16px;
            border-radius: 6px;
            margin-top: 16px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #2a2a4a;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 12px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffaa00);
            width: 0%;
            transition: width 0.3s;
        }
        
        .stats-table-wrapper {
            background: #1a1a2a;
            border-radius: 6px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .stats-table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #3a3a5a;
        }
        
        .stats-table-title {
            color: #ffd700;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .precision-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .precision-control label {
            color: #aaa;
            font-size: 0.85rem;
        }
        
        .precision-control select {
            width: 80px;
            padding: 6px;
            background: #12121a;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 0.85rem;
        }
        
        .show-all-toggle {
            background: #2a2a4a;
            color: #e0e0e0;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }
        
        .show-all-toggle:hover {
            background: #3a3a5a;
        }
        
        .stats-table-container {
            max-height: 300px;
            overflow-y: auto;
            border-radius: 4px;
        }
        
        .stats-table-container.expanded {
            max-height: 800px;
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .stats-table thead {
            position: sticky;
            top: 0;
            background: #12121a;
            z-index: 10;
        }
        
        .stats-table th {
            padding: 12px;
            text-align: left;
            color: #ffd700;
            font-weight: 600;
            border-bottom: 2px solid #3a3a5a;
        }
        
        .stats-table th:first-child {
            text-align: center;
        }
        
        .stats-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #2a2a4a;
            color: #ccc;
        }
        
        .stats-table td:first-child {
            text-align: center;
            color: #ffd700;
            font-weight: 600;
        }
        
        .stats-table tr:hover {
            background: #1a1a2a;
        }
        
        .stats-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }
        
        .prime-list {
            max-width: 400px;
            color: #888;
            font-size: 0.85rem;
        }
        
        .stats-table-container::-webkit-scrollbar {
            width: 10px;
        }
        
        .stats-table-container::-webkit-scrollbar-track {
            background: #12121a;
            border-radius: 4px;
        }
        
        .stats-table-container::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 4px;
        }
        
        .stats-table-container::-webkit-scrollbar-thumb:hover {
            background: #4a4a6a;
        }

        /* TAB SYSTEM */
        .tab-navigation {
            display: flex;
            gap: 4px;
            background: #12121a;
            padding: 8px;
            border-radius: 8px 8px 0 0;
            border-bottom: 2px solid #2a2a4a;
        }

        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #888;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px 6px 0 0;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .tab-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            color: #ccc;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
            color: #000;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: #12121a;
        }

        .data-table th {
            background: #1a1a2a;
            color: #ffd700;
            padding: 12px;
            text-align: left;
            border-bottom: 2px solid #2a2a4a;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .data-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #2a2a4a;
            color: #ccc;
        }

        .data-table tr:hover {
            background: #1a1a2a;
            cursor: pointer;
        }

        .data-table tr.highlighted {
            background: rgba(255, 215, 0, 0.3);
            border-left: 4px solid #ffd700;
        }

        .stats-table tr {
            cursor: pointer;
            transition: all 0.2s;
        }

        .stats-table tr.highlighted {
            background: rgba(255, 215, 0, 0.3);
            border-left: 4px solid #ffd700;
        }

        .data-table tbody {
            max-height: 600px;
            overflow-y: auto;
        }

        .copy-btn {
            padding: 6px 12px;
            background: #3b82f6;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #2563eb;
        }

        .data-container {
            background: #12121a;
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
        }

        .chart-description {
            background: rgba(255, 215, 0, 0.1);
            padding: 16px;
            border-radius: 6px;
            border-left: 4px solid #ffd700;
            margin-bottom: 20px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .export-row {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #3a3a5a;
        }
        
        .export-btn {
            flex: 1;
            padding: 8px 12px;
            background: #2a2a4a;
            color: #e0e0e0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .export-btn:hover {
            background: #3a3a5a;
            transform: translateY(-1px);
        }
        
        .export-btn.csv {
            background: linear-gradient(135deg, #64ff64 0%, #32aa32 100%);
            color: #000;
        }
        
        .export-btn.csv:hover {
            box-shadow: 0 2px 8px rgba(100, 255, 100, 0.3);
        }
        
        .export-btn.png {
            background: linear-gradient(135deg, #64ffff 0%, #32aaaa 100%);
            color: #000;
        }
        
        .export-btn.png:hover {
            box-shadow: 0 2px 8px rgba(100, 255, 255, 0.3);
        }
        
        .section-divider {
            height: 1px;
            background: #3a3a5a;
            margin: 24px 0;
        }
        /* Modal Popup Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            backdrop-filter: blur(4px);
        }
        
        .modal-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.2s;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 32px;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #ffd700;
        }
        
        .modal-title {
            color: #ffd700;
            font-size: 1.8rem;
            font-weight: bold;
        }
        
        .modal-close {
            background: #ff4444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .modal-close:hover {
            background: #cc0000;
        }
        
        .modal-screenshot {
            background: #4ecdc4;
            color: #0a0a10;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .modal-screenshot:hover {
            background: #3ab8af;
        }
        
        .modal-section {
            margin-bottom: 24px;
        }
        
        .modal-section-title {
            color: #4ecdc4;
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 12px;
        }
        
        .modal-stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .modal-stat-item {
            background: rgba(255, 215, 0, 0.05);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #ffd700;
        }
        
        .modal-stat-label {
            color: #aaa;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }
        
        .modal-stat-value {
            color: #fff;
            font-size: 1.3rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .modal-prime-list {
            background: rgba(78, 205, 196, 0.05);
            padding: 16px;
            border-radius: 6px;
            border-left: 3px solid #4ecdc4;
            max-height: 600px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .modal-prime-list code {
            color: #4ecdc4;
            font-size: 0.95rem;
            line-height: 1.8;
            word-wrap: break-word;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Gap-Class Decomposition of ζ(2) = π²/6</h1>
        <div class="subtitle">Analytical Framework for Prime Gap Contributions to the Riemann Zeta Function</div>
        <div class="author">By Wessen Getachew | 2026</div>
        <div class="author" style="margin-top: 8px; font-size: 0.85rem;">
            Related work: <a href="https://wessengetachew.github.io/Ethiopian/" target="_blank" style="color: #4ecdc4; text-decoration: none; border-bottom: 1px dotted #4ecdc4;">Modular Sieve Calculator</a>
        </div>
    </header>
    
    <div class="introduction">
        <div class="intro-section">
            <h2>Theoretical Foundation</h2>
            
            <p>Leonhard Euler established in 1734 that the Riemann zeta function at s=2 admits the following representation:</p>
            
            <div class="formula-box">
                ζ(2) = Σ<sub>n=1</sub><sup>∞</sup> 1/n² = ∏<sub>p prime</sub> p²/(p²-1) = π²/6 ≈ 1.644934066848...
            </div>
            
            <p>The Euler product expresses ζ(2) as an infinite product over all prime numbers, where each prime p contributes the multiplicative factor p²/(p²-1).</p>
            
            <h3>Gap-Class Partition</h3>
            
            <p>This framework introduces a partition of the Euler product based on prime gap classes. Define gap(p) as the forward difference p<sub>n+1</sub> - p<sub>n</sub> for consecutive primes. The Euler product may then be reorganized as:</p>
            
            <div class="formula-box">
                ζ(2) = ∏<sub>g∈{1,2,4,6,...}</sub> P<sub>g</sub>
            </div>
            
            <p>where each gap family product is:</p>
            
            <div class="formula-box">
                P<sub>g</sub> = ∏<sub>p: gap(p)=g</sub> p²/(p²-1)
            </div>
            
            <h3>Gap Classification</h3>
            
            <p>Prime gaps partition into the following classes:</p>
            
            <ul>
                <li><strong>Gap 1:</strong> {2} (first gap: 3-2=1)</li>
                <li><strong>Gap 2 (Twin Primes):</strong> {3, 5, 11, 17, 29, 41, 59, 71, 101, 107, ...}</li>
                <li><strong>Gap 4 (Cousin Primes):</strong> {7, 13, 19, 37, 43, 67, 79, 97, 103, 109, ...}</li>
                <li><strong>Gap 6 (Sexy Primes):</strong> {23, 31, 47, 53, 61, 73, 83, 89, 113, ...}</li>
            </ul>
            
            <h3>Research Objectives</h3>
            
            <p>This computational framework enables investigation of the following questions:</p>
            
            <ol>
                <li><strong>Quantitative Contributions:</strong> Determine the absolute and relative contribution of each gap class to ζ(2)</li>
                <li><strong>Convergence Analysis:</strong> Characterize whether individual P<sub>g</sub> admit closed-form expressions involving π or other fundamental constants</li>
                <li><strong>Asymptotic Behavior:</strong> Analyze how P<sub>g</sub> scales as g → ∞</li>
                <li><strong>Gap Distribution:</strong> Examine relationships between gap class populations and analytic properties of ζ(s)</li>
                <li><strong>Generalization:</strong> Test whether this decomposition extends to ζ(2n) for all positive integers n</li>
                <li><strong>Conjecture Constraints:</strong> Investigate whether gap contribution patterns impose necessary conditions on unproven conjectures</li>
            </ol>
            
            <h3>Analytical Methods</h3>
            
            <p>The tool employs the Sieve of Eratosthenes for prime generation, computes exact products P<sub>g</sub> for each gap class, tracks progressive convergence to π²/6, and provides high-precision numerical analysis with configurable decimal representation.</p>
        </div>
    </div>
    
    <div class="controls-container">
        <div class="control-panel">
            <h3 style="color: #ffd700; margin-bottom: 20px;">Research Presets</h3>
            <p style="font-size: 0.9rem; color: #94a3b8; margin-bottom: 16px;">
                Quick configurations for common research scenarios - click to apply settings instantly
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 30px;">
                <button onclick="applyResearchPreset('twins')" class="preset-btn" style="background: #dc2626; padding: 10px;">
                    <strong>Twin Prime Focus</strong><br>
                    <span style="font-size: 0.85em; opacity: 0.9;">Primes: 100K, Gaps: 2-10</span>
                </button>
                <button onclick="applyResearchPreset('goldbach')" class="preset-btn" style="background: #ea580c; padding: 10px;">
                    <strong>Goldbach Range</strong><br>
                    <span style="font-size: 0.85em; opacity: 0.9;">Primes: 500K, Gaps: 2-30</span>
                </button>
                <button onclick="applyResearchPreset('topology')" class="preset-btn" style="background: #7c3aed; padding: 10px;">
                    <strong>Large Gap Topology</strong><br>
                    <span style="font-size: 0.85em; opacity: 0.9;">Primes: 1M, Gaps: 30-90</span>
                </button>
                <button onclick="applyResearchPreset('extreme')" class="preset-btn" style="background: #c026d3; padding: 10px;">
                    <strong>Extreme Range</strong><br>
                    <span style="font-size: 0.85em; opacity: 0.9;">Primes: 5M, Gaps: 100+</span>
                </button>
                <button onclick="applyResearchPreset('full')" class="preset-btn" style="background: #059669; padding: 10px;">
                    <strong>Full Spectrum</strong><br>
                    <span style="font-size: 0.85em; opacity: 0.9;">Primes: 1M, All Gaps</span>
                </button>
                <button onclick="applyResearchPreset('rh')" class="preset-btn" style="background: #0891b2; padding: 10px;">
                    <strong>Riemann Hypothesis Analysis</strong><br>
                    <span style="font-size: 0.85em; opacity: 0.9;">High-precision: 2M primes, Standard gap range</span>
                </button>
            </div>

            <h3>Computation Parameters</h3>
            
            <div class="control-grid">
                <div class="control-group">
                    <label>
                        Maximum Prime
                        <span class="control-value" id="maxPrimeDisplay">10000000</span>
                    </label>
                    <input type="number" id="maxPrime" value="10000000" min="1000" max="10000000" step="1000">
                </div>
                
                <div class="control-group">
                    <label>
                        Maximum Gap to Analyze
                        <span class="control-value" id="maxGapDisplay">50</span>
                    </label>
                    <input type="number" id="maxGap" value="50" min="2" max="1000" step="2">
                    <div style="margin-top: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 0.85rem;">
                            <input type="checkbox" id="autoDetectMaxGap" style="width: auto;" checked>
                            <span>Auto-detect largest gap in range</span>
                        </label>
                    </div>
                </div>
                
                <div class="control-group" style="border: 2px solid #8b5cf6; padding: 16px; border-radius: 8px; background: rgba(139, 92, 246, 0.05);">
                    <label style="color: #8b5cf6; font-weight: 600;">
                        Zeta Exponent (s)
                        <span class="control-value" id="zetaSDisplay">2.00</span>
                    </label>
                    <input type="range" id="zetaS" value="2" min="1.01" max="20" step="0.01"
                           oninput="updateZetaSDisplay()" onchange="updateZetaSDisplay()">
                    
                    <!-- Preset Buttons -->
                    <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 6px; margin-top: 12px;">
                        <button onclick="setZetaS(1.5)" class="preset-btn" style="background: #7c3aed; padding: 6px; font-size: 0.8rem;">s=1.5</button>
                        <button onclick="setZetaS(2)" class="preset-btn" style="background: #6366f1; padding: 6px; font-size: 0.8rem;">s=2</button>
                        <button onclick="setZetaS(3)" class="preset-btn" style="background: #3b82f6; padding: 6px; font-size: 0.8rem;">s=3</button>
                        <button onclick="setZetaS(4)" class="preset-btn" style="background: #0891b2; padding: 6px; font-size: 0.8rem;">s=4</button>
                        <button onclick="setZetaS(Math.PI)" class="preset-btn" style="background: #059669; padding: 6px; font-size: 0.8rem;">s=π</button>
                        <button onclick="setZetaS(10)" class="preset-btn" style="background: #dc2626; padding: 6px; font-size: 0.8rem;">s=10</button>
                    </div>
                    
                    <div style="margin-top: 12px; font-size: 0.85rem; color: #a78bfa;">
                        <div id="zetaSInfo" style="font-weight: 600;">ζ(2) = π²/6 ≈ 1.6449</div>
                        <div id="zetaSBehavior" style="margin-top: 8px; color: #888; font-size: 0.8rem;">
                            Twin primes dominate at s=2
                        </div>
                        <div style="margin-top: 4px; color: #888; font-size: 0.75rem;">
                            Formula: ζ(s) = ∏ p^s/(p^s-1)
                        </div>
                    </div>
                </div>

                <div class="control-group" style="grid-column: 1 / -1; border: 2px solid #3b82f6; padding: 16px; border-radius: 8px; background: rgba(59, 130, 246, 0.05);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <h4 style="margin: 0; color: #3b82f6; font-size: 1rem;">Gap Range Filter (Zoom)</h4>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 0.9rem;">
                            <input type="checkbox" id="enableGapFilter" style="width: auto;" onchange="toggleGapFilter()">
                            <span style="color: #60a5fa; font-weight: 600;">Enable Filter</span>
                        </label>
                    </div>
                    
                    <div id="gapFilterControls" style="display: none;">
                        <p style="font-size: 0.85rem; color: #94a3b8; margin: 0 0 12px 0;">
                            Filter which gaps appear in all charts. Perfect for examining larger gaps without small gaps dominating.
                        </p>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                            <div>
                                <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: #94a3b8;">Min Gap</label>
                                <input type="number" id="minGapFilter" value="2" min="0" max="1000" step="2" 
                                       style="width: 100%; padding: 6px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0;"
                                       onchange="updateGapFilterDisplay()">
                            </div>
                            <div>
                                <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: #94a3b8;">Max Gap</label>
                                <input type="number" id="maxGapFilter" value="50" min="2" max="1000" step="2" 
                                       style="width: 100%; padding: 6px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0;"
                                       onchange="updateGapFilterDisplay()">
                            </div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; font-size: 0.85rem; margin-bottom: 6px; color: #94a3b8;">Quick Presets:</label>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                <button onclick="setGapRange(2, 10)" class="preset-btn">Tiny (2-10)</button>
                                <button onclick="setGapRange(2, 20)" class="preset-btn">Small (2-20)</button>
                                <button onclick="setGapRange(20, 50)" class="preset-btn">Medium (20-50)</button>
                                <button onclick="setGapRange(30, 90)" class="preset-btn">Large (30-90)</button>
                                <button onclick="setGapRange(50, 150)" class="preset-btn">Huge (50-150)</button>
                                <button onclick="setGapRangeToLast(20)" class="preset-btn" style="background: #ea580c;">Last 20</button>
                                <button onclick="setGapRangeToLast(10)" class="preset-btn" style="background: #ea580c;">Last 10</button>
                                <button onclick="resetGapFilter()" class="preset-btn" style="background: #475569;">Reset</button>
                            </div>
                        </div>

                        <div style="background: rgba(34, 197, 94, 0.1); padding: 10px; border-radius: 6px; border-left: 3px solid #22c55e;">
                            <p style="margin: 0; font-size: 0.85rem; color: #4ade80;">
                                <strong>Active:</strong> <span id="gapFilterStatus">Showing all gaps</span>
                            </p>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>
                        Animation Speed (ms delay)
                        <span class="control-value" id="animSpeedDisplay">100</span>
                    </label>
                    <input type="range" id="animSpeed" min="10" max="500" value="100" step="10"
                           oninput="document.getElementById('animSpeedDisplay').textContent = this.value">
                    <div style="margin-top: 4px; font-size: 0.75rem; color: #888;">
                        Lower = Faster | Higher = Slower
                    </div>
                </div>
                
                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="useMaxPrimeForAnim" style="width: auto;" checked>
                        <span>Animate from 0 to Max Prime</span>
                    </label>
                    <div style="margin-top: 4px; font-size: 0.75rem; color: #888;">
                        Uncheck to set custom range below
                    </div>
                </div>

                <div class="control-group">
                    <label>
                        Custom Start (if unchecked above)
                        <span class="control-value" id="animStartDisplay">1</span>
                    </label>
                    <input type="number" id="animStart" value="1" min="1" max="10000000" step="100">
                </div>
                
                <div class="control-group">
                    <label>
                        Custom End (if unchecked above)
                        <span class="control-value" id="animEndDisplay">10000000</span>
                    </label>
                    <input type="number" id="animEnd" value="10000000" min="1000" max="10000000" step="1000">
                </div>
            </div>
            
            <div style="margin-top: 20px; padding: 16px; background: rgba(139, 92, 246, 0.05); border-radius: 8px; border-left: 4px solid #8b5cf6;">
                <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                    <input type="checkbox" id="enableComparison" style="width: auto;">
                    <div>
                        <span style="color: #8b5cf6; font-weight: 600; font-size: 1rem;">Enable Comparison Mode</span>
                        <div style="font-size: 0.85rem; color: #888; margin-top: 4px;">
                            Compare how gap contributions change across s = [1.5, 2, 3, 4, 5, 10]
                        </div>
                    </div>
                </label>
            </div>
            
            <div class="button-row">
                <button class="btn" onclick="runAnalysis()">Run Analysis</button>
                <button class="btn btn-secondary" onclick="startAnimation()">Start Animation</button>
                <button class="btn btn-secondary" onclick="stopAnimation()">Stop Animation</button>
                <button class="btn btn-secondary" onclick="exportAllData()">Export All Data (CSV)</button>
                <button class="btn btn-secondary" onclick="exportAllCharts()">Export All Charts (PNG)</button>
            </div>
            
            <div id="statusBar" class="status-bar" style="display: none;">
                Ready to compute...
            </div>
            
            <div id="progressContainer" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <h3>Chart Options</h3>
            
            <div class="toggle-wrapper">
                <label class="toggle">
                    <input type="checkbox" id="showGapContributions" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span>Show Gap Contributions Chart</span>
            </div>
            
            <div class="toggle-wrapper">
                <label class="toggle">
                    <input type="checkbox" id="showConvergence" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span>Show Progressive Convergence</span>
            </div>
            
            <div class="toggle-wrapper">
                <label class="toggle">
                    <input type="checkbox" id="showGapDistribution" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span>Show Gap Distribution</span>
            </div>
            
            <div class="toggle-wrapper">
                <label class="toggle">
                    <input type="checkbox" id="showPercentageContrib" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span>Show Percentage Contributions</span>
            </div>
            
            <div class="toggle-wrapper">
                <label class="toggle">
                    <input type="checkbox" id="showErrorAnalysis" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span>Show Error Analysis</span>
            </div>
            
            <div class="toggle-wrapper">
                <label class="toggle">
                    <input type="checkbox" id="showLogScale" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span>Show Log-Scale Product Analysis</span>
            </div>
        </div>
        
        <div id="statsPanel" class="control-panel" style="display: none;">
            <h3>Analysis Statistics</h3>
            <div class="stats-grid" id="statsGrid"></div>
        </div>
    </div>
    
    <div class="charts-container">
        <div class="chart-wrapper" id="convergenceWrapper">
            <div class="chart-title">Progressive Convergence to ζ(2) = π²/6</div>
            <canvas id="convergenceChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Progressive Convergence Data</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="convergencePrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('convergenceTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="convergenceTable">
                    <table class="stats-table" id="convergenceTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('convergence')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG('convergenceChart', 'convergence')">Export Chart PNG</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="gapContribWrapper">
            <div class="chart-title">Individual Gap Family Products P<sub>g</sub></div>
            <canvas id="gapContribChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Gap Family Product Values</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="gapContribPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('gapContribTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="gapContribTable">
                    <table class="stats-table" id="gapContribTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('gapContrib')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG('gapContribChart', 'gap_contributions')">Export Chart PNG</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="gapDistWrapper">
            <div class="chart-title">Prime Distribution by Gap Class</div>
            <canvas id="gapDistChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Prime Count and Distribution</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="gapDistPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('gapDistTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="gapDistTable">
                    <table class="stats-table" id="gapDistTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('gapDist')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG('gapDistChart', 'gap_distribution')">Export Chart PNG</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="percentageWrapper">
            <div class="chart-title">Percentage Contribution to ζ(2) by Gap Family</div>
            <canvas id="percentageChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Contribution Percentages</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="percentagePrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('percentageTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="percentageTable">
                    <table class="stats-table" id="percentageTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('percentage')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG('percentageChart', 'percentage_contributions')">Export Chart PNG</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="errorWrapper">
            <div class="chart-title">Convergence Error Analysis</div>
            <canvas id="errorChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Error Metrics by Gap</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="errorPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('errorTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="errorTable">
                    <table class="stats-table" id="errorTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('error')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG('errorChart', 'error_analysis')">Export Chart PNG</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="logScaleWrapper">
            <div class="chart-title">Log-Scale Product Growth P<sub>g</sub></div>
            <canvas id="logScaleChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Logarithmic Product Analysis</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="logScalePrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('logScaleTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="logScaleTable">
                    <table class="stats-table" id="logScaleTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('logScale')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG('logScaleChart', 'log_scale_products')">Export Chart PNG</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="stepByStepWrapper">
            <div class="chart-title">Step-by-Step Gap Accumulation: ζ(2) = P<sub>0</sub> × P<sub>2</sub> × P<sub>4</sub> × ...</div>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Progressive Product Construction</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="stepByStepPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                            <option value="12" selected>12</option>
                            <option value="15">15</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('stepByStepTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container expanded" id="stepByStepTable">
                    <table class="stats-table" id="stepByStepTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('stepByStep')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportStepByStepTablePNG()">Export Table PNG</button>
                </div>
            </div>
        </div>
        
        <!-- COMPARISON CHART (Only shown when comparison mode enabled) -->
        <div class="chart-wrapper" id="comparisonWrapper" style="display: none;">
            <div class="chart-title">Gap Contribution Evolution Across ζ(s)</div>
            <canvas id="comparisonChart" width="3840" height="2400"></canvas>
            <div class="stats-table-wrapper">
                <div class="chart-description" style="background: rgba(139, 92, 246, 0.1); padding: 16px; border-radius: 6px; border-left: 4px solid #8b5cf6;">
                    <strong>How Gap Contributions Change with s:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>s → 1:</strong> All gaps contribute equally (divergent series)</li>
                        <li><strong>s = 1.5:</strong> Gap 1 (45%), Gap 2 (39%) - Balanced</li>
                        <li><strong>s = 2:</strong> Gap 1 (58%), Gap 2 (35%) - Current tool focus</li>
                        <li><strong>s = 4:</strong> Gap 1 (82%), Gap 2 (18%) - Gap 1 dominant</li>
                        <li><strong>s = 10:</strong> Gap 1 (98%), Gap 2 (2%) - Almost entirely Gap 1</li>
                    </ul>
                    <p style="margin-top: 12px; color: #a78bfa;">
                        <strong>Key Insight:</strong> Twin primes (Gap 2) dominate at s=2, but prime 2 (Gap 1) dominates at higher s values!
                    </p>
                </div>
                <div id="comparisonTableDiv"></div>
                <div class="export-row">
                    <button class="export-btn png" onclick="exportComparisonPNG()">Export Comparison PNG</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="controls-container">
        <div class="control-panel">
            <h3>Composite Screenshot Export</h3>
            <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 20px;">
                Generate a comprehensive image combining selected charts with analysis summary and mathematical narrative
            </p>
            
            <div style="background: rgba(78, 205, 196, 0.05); padding: 16px; border-radius: 8px; border-left: 4px solid #4ecdc4; margin-bottom: 20px;">
                <h4 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1rem;">Global Export Settings</h4>
                <p style="margin: 0 0 12px 0; color: #888; font-size: 0.85rem;">
                    These settings apply to ALL chart exports (individual and composite)
                </p>
                
                <div class="control-grid" style="grid-template-columns: 1fr;">
                    <div class="control-group">
                        <label>Data Rows in Exported Tables</label>
                        <select id="globalExportRows">
                            <option value="5">5 rows</option>
                            <option value="10">10 rows</option>
                            <option value="15" selected>15 rows</option>
                            <option value="20">20 rows</option>
                            <option value="25">25 rows</option>
                            <option value="30">30 rows</option>
                            <option value="40">40 rows</option>
                            <option value="50">50 rows</option>
                            <option value="all">All rows (may be very large)</option>
                        </select>
                        <div style="margin-top: 4px; font-size: 0.75rem; color: #888;">
                            When you click "Export Chart PNG" or "Export Table PNG", this many rows will be included
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-grid" style="grid-template-columns: repeat(3, 1fr);">
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotConvergence" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Progressive Convergence</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotGapContrib" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Gap Products</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotGapDist" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Gap Distribution</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotPercentage" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Percentage Contributions</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotError" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Error Analysis</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotLogScale" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Log-Scale Products</span>
                </div>
            </div>
            
            <div class="section-divider"></div>
            
            <div class="control-group">
                <label>Main Title</label>
                <input type="text" id="screenshotTitle" value="Gap-Class Decomposition of ζ(2) = π²/6">
            </div>
            
            <div class="control-group">
                <label>Subtitle</label>
                <input type="text" id="screenshotSubtitle" value="Analytical Partition of the Euler Product">
            </div>
            
            <div class="control-group">
                <label>Layout</label>
                <select id="screenshotLayout">
                    <option value="grid">Grid (2×3)</option>
                    <option value="vertical">Vertical Stack</option>
                    <option value="horizontal">Horizontal (2 rows)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Resolution</label>
                <select id="screenshotResolution">
                    <option value="1920">HD (1920×1080)</option>
                    <option value="2560">QHD (2560×1440)</option>
                    <option value="3840" selected>4K (3840×2160)</option>
                    <option value="7680">8K (7680×4320)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Data Table Rows in Screenshots</label>
                <select id="screenshotTableRows">
                    <option value="5">5 rows</option>
                    <option value="10">10 rows</option>
                    <option value="15" selected>15 rows</option>
                    <option value="20">20 rows</option>
                    <option value="25">25 rows</option>
                    <option value="30">30 rows</option>
                    <option value="40">40 rows</option>
                    <option value="50">50 rows</option>
                    <option value="all">All rows</option>
                </select>
                <div style="margin-top: 4px; font-size: 0.75rem; color: #888;">
                    Applies to: Step-by-Step table PNG export
                </div>
            </div>
            
            <div class="section-divider"></div>
            
            <button class="btn" onclick="generateCompositeScreenshot()" style="width: 100%; margin-bottom: 12px;">
                Generate Composite Screenshot
            </button>
            
            <div id="screenshotStatus" class="status-bar" style="display: none; margin-top: 12px;">
                Generating screenshot...
            </div>
        </div>
    </div>
    
    <!-- CREDITS SECTION -->
    <div class="controls-container" style="margin-top: 40px;">
        <div class="control-panel" style="background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%); border: 2px solid #ffd700;">
            <h3 style="color: #ffd700; margin-bottom: 20px; text-align: center; font-size: 1.4rem;">Credits & Attribution</h3>
            
            <div style="display: grid; gap: 20px;">
                <!-- Author -->
                <div style="background: rgba(255, 215, 0, 0.05); padding: 20px; border-radius: 8px; border-left: 4px solid #ffd700;">
                    <h4 style="color: #ffd700; margin: 0 0 10px 0; font-size: 1.1rem;">Author</h4>
                    <p style="margin: 0; color: #e0e0e0; line-height: 1.8;">
                        <strong>Wessen Getachew</strong><br>
                        Independent Mathematical Researcher<br>
                        Twitter: <a href="https://twitter.com/7dview" target="_blank" style="color: #4ecdc4; text-decoration: none;">@7dview</a>
                    </p>
                </div>
                
                <!-- Related Work -->
                <div style="background: rgba(78, 205, 196, 0.05); padding: 20px; border-radius: 8px; border-left: 4px solid #4ecdc4;">
                    <h4 style="color: #4ecdc4; margin: 0 0 10px 0; font-size: 1.1rem;">Related Research Tools</h4>
                    <p style="margin: 0 0 12px 0; color: #ccc;">
                        This tool is part of a broader investigation into prime number distribution and connections to the Riemann Hypothesis:
                    </p>
                    <ul style="margin: 0; padding-left: 20px; color: #ccc; line-height: 1.8;">
                        <li>
                            <a href="https://wessengetachew.github.io/Ethiopian/" target="_blank" style="color: #4ecdc4; text-decoration: none;">
                                Modular Sieve Calculator
                            </a> - Prime residue ring visualizations and ζ(2n) computations
                        </li>
                        <li>Farey Sequence Analysis - Fixed point at 1/2 and RH connections</li>
                        <li>Gap Phase Alignment Framework - φ(p,t) = t·log(p) - π/2 mechanism</li>
                        <li>Combinatorial Twin Prime Framework - T(M_n) = 3·2^n formula</li>
                    </ul>
                </div>
                
                <!-- Mathematical Foundation -->
                <div style="background: rgba(139, 92, 246, 0.05); padding: 20px; border-radius: 8px; border-left: 4px solid #8b5cf6;">
                    <h4 style="color: #8b5cf6; margin: 0 0 10px 0; font-size: 1.1rem;">Mathematical Framework</h4>
                    <p style="margin: 0; color: #ccc; line-height: 1.8;">
                        This analysis builds on Leonhard Euler's 1734 proof that ζ(2) = π²/6 and introduces a novel 
                        gap-class decomposition of the Euler product. The framework partitions primes by their forward 
                        differences, revealing that twin primes contribute approximately 34.79% to the logarithmic product 
                        log(ζ(2)), with contribution decay following precise combinatorial patterns.
                    </p>
                </div>
                
                <!-- License & Usage -->
                <div style="background: rgba(255, 255, 255, 0.02); padding: 20px; border-radius: 8px; border: 1px solid #2a2a4a;">
                    <h4 style="color: #aaa; margin: 0 0 10px 0; font-size: 1.1rem;">License & Usage</h4>
                    <p style="margin: 0; color: #888; font-size: 0.9rem; line-height: 1.6;">
                        This tool is provided for educational and research purposes. If you use this tool or its findings 
                        in academic work, presentations, or publications, please provide appropriate attribution to 
                        <strong>Wessen Getachew</strong> and cite the gap-class decomposition framework.
                    </p>
                </div>
                
                <!-- Build Info -->
                <div style="text-align: center; padding: 15px; color: #666; font-size: 0.85rem; border-top: 1px solid #2a2a4a;">
                    Gap-Class Decomposition Explorer v2.0 | Built February 2026<br>
                    Interactive Mathematical Research Tool
                </div>
            </div>
        </div>
    </div>
    
    <canvas id="compositeCanvas" style="display: none;"></canvas>
    
    
    <canvas id="compositeCanvas" style="display: none;"></canvas>
    
    <!-- Modal Popup for Gap Details -->
    <div class="modal-overlay" id="gapModal" onclick="closeGapModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Gap Details</h2>
                <div style="display: flex; gap: 12px;">
                    <button class="modal-screenshot" onclick="screenshotModal()">Screenshot (4K)</button>
                    <button class="modal-close" onclick="closeGapModal()">Close</button>
                </div>
            </div>
            <div id="modalBody"></div>
        </div>
    </div>
    
    </div>
    <!-- END TAB: Main -->

    <script>
        // Gap Decomposition Analyzer v2.1 - Fixed xPos scope issue
        // Global variables
        let analysisResults = null;
        let animationId = null;
        let isAnimating = false;

        // Gap filter functions
        function toggleGapFilter() {
            const enabled = document.getElementById('enableGapFilter').checked;
            const controls = document.getElementById('gapFilterControls');
            controls.style.display = enabled ? 'block' : 'none';
            
            if (enabled) {
                updateGapFilterDisplay();
            } else {
                document.getElementById('gapFilterStatus').textContent = 'Showing all gaps';
            }
            
            if (analysisResults) {
                renderAllCharts();
            }
        }

        function setGapRange(min, max) {
            document.getElementById('minGapFilter').value = min;
            document.getElementById('maxGapFilter').value = max;
            document.getElementById('enableGapFilter').checked = true;
            toggleGapFilter();
            if (analysisResults) {
                renderAllCharts();
            }
        }

        function setGapRangeToLast(count) {
            if (!analysisResults || !analysisResults.evenGaps) {
                alert('Please run analysis first');
                return;
            }
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const lastGaps = gaps.slice(-count);
            const min = Math.min(...lastGaps);
            const max = Math.max(...lastGaps);
            
            setGapRange(min, max);
        }

        function resetGapFilter() {
            document.getElementById('minGapFilter').value = 2;
            document.getElementById('maxGapFilter').value = 50;
            document.getElementById('enableGapFilter').checked = false;
            toggleGapFilter();
        }

        function updateGapFilterDisplay() {
            const min = parseInt(document.getElementById('minGapFilter').value);
            const max = parseInt(document.getElementById('maxGapFilter').value);
            document.getElementById('gapFilterStatus').textContent = `Showing gaps ${min} to ${max}`;
            
            if (analysisResults) {
                renderAllCharts();
            }
        }

        function getFilteredGaps() {
            if (!analysisResults) return [];
            
            const filterEnabled = document.getElementById('enableGapFilter').checked;
            if (!filterEnabled) {
                return analysisResults.evenGaps;
            }
            
            const min = parseInt(document.getElementById('minGapFilter').value);
            const max = parseInt(document.getElementById('maxGapFilter').value);
            
            return analysisResults.evenGaps.filter(g => g >= min && g <= max);
        }

        function getFilteredProgressiveProducts() {
            if (!analysisResults) return [];
            
            const filteredGaps = getFilteredGaps();
            return analysisResults.progressiveProducts.filter(p => filteredGaps.includes(p.gap));
        }

        function getFilteredGapProducts() {
            if (!analysisResults) return {};
            
            const filteredGaps = getFilteredGaps();
            const filtered = {};
            filteredGaps.forEach(gap => {
                if (analysisResults.gapProducts[gap]) {
                    filtered[gap] = analysisResults.gapProducts[gap];
                }
            });
            return filtered;
        }
        
        // Sieve of Eratosthenes
        function sievePrimes(max) {
            const sieve = new Array(max + 1).fill(true);
            sieve[0] = sieve[1] = false;
            
            for (let i = 2; i * i <= max; i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= max; j += i) {
                        sieve[j] = false;
                    }
                }
            }
            
            const primes = [];
            for (let i = 2; i <= max; i++) {
                if (sieve[i]) primes.push(i);
            }
            return primes;
        }
        
        // Core analysis function
        function computeGapDecomposition(maxPrime, maxGap) {
            const primes = sievePrimes(maxPrime);
            const targetZeta2 = Math.PI * Math.PI / 6;
            
            // Calculate gaps and classify primes
            const gapFamilies = {}; // Will be populated by loop - gap 1 gets prime 2 from 3-2=1
            const gaps = [];
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i + 1] - primes[i];
                gaps.push(gap);
                
                if (!gapFamilies[gap]) {
                    gapFamilies[gap] = [];
                }
                gapFamilies[gap].push(primes[i]);
            }
            
            // Calculate products for each gap family
            const gapProducts = {};
            const evenGaps = [1]; // Start with gap 1 (the only odd gap: 3-2)
            
            for (let g = 2; g <= maxGap; g += 2) {
                if (gapFamilies[g] && gapFamilies[g].length > 0) {
                    evenGaps.push(g);
                }
            }
            
            evenGaps.forEach(gap => {
                if (gapFamilies[gap] && gapFamilies[gap].length > 0) {
                    let product = 1;
                    let logProduct = 0;
                    
                    gapFamilies[gap].forEach(p => {
                        const factor = (p * p) / (p * p - 1);
                        product *= factor;
                        logProduct += Math.log(factor);
                    });
                    
                    gapProducts[gap] = {
                        product: product,
                        logProduct: logProduct,
                        count: gapFamilies[gap].length,
                        primes: gapFamilies[gap].slice(0, 100) // Store first 100
                    };
                }
            });
            
            // Calculate progressive convergence
            const progressiveProducts = [];
            let cumulative = 1;
            let cumulativeLog = 0;
            
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    cumulative *= gapProducts[gap].product;
                    cumulativeLog += gapProducts[gap].logProduct;
                    
                    progressiveProducts.push({
                        gap: gap,
                        value: cumulative,
                        logValue: cumulativeLog,
                        error: Math.abs(cumulative - targetZeta2),
                        relativeError: Math.abs(cumulative - targetZeta2) / targetZeta2
                    });
                }
            });
            
            // Calculate percentage contributions
            const percentageContributions = {};
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    const contribution = Math.log(gapProducts[gap].product) / Math.log(targetZeta2);
                    percentageContributions[gap] = contribution * 100;
                }
            });
            
            return {
                primes: primes,
                totalPrimes: primes.length,
                maxPrime: maxPrime,
                targetZeta2: targetZeta2,
                gapFamilies: gapFamilies,
                gapProducts: gapProducts,
                evenGaps: evenGaps,
                progressiveProducts: progressiveProducts,
                percentageContributions: percentageContributions,
                finalProduct: cumulative,
                finalError: Math.abs(cumulative - targetZeta2),
                finalRelativeError: Math.abs(cumulative - targetZeta2) / targetZeta2
            };
        }
        
        // Update displays
        function updateDisplays() {
            document.getElementById('maxPrimeDisplay').textContent = 
                parseInt(document.getElementById('maxPrime').value).toLocaleString();
            document.getElementById('maxGapDisplay').textContent = 
                document.getElementById('maxGap').value;
            document.getElementById('animStartDisplay').textContent = 
                parseInt(document.getElementById('animStart').value).toLocaleString();
            document.getElementById('animEndDisplay').textContent = 
                parseInt(document.getElementById('animEnd').value).toLocaleString();
        }
        
        // Run analysis
        function runAnalysis() {
            const maxPrime = parseInt(document.getElementById('maxPrime').value);
            let maxGap = parseInt(document.getElementById('maxGap').value);
            const autoDetect = document.getElementById('autoDetectMaxGap').checked;
            const s = parseFloat(document.getElementById('zetaS').value);
            const comparisonMode = document.getElementById('enableComparison').checked;
            
            const statusBar = document.getElementById('statusBar');
            statusBar.style.display = 'block';
            statusBar.className = 'status-bar computing';
            
            if (comparisonMode) {
                statusBar.textContent = `Computing comparison across s = [1.5, 2, 3, 4, 5, 10]...`;
            } else {
                statusBar.textContent = `Computing ζ(${s.toFixed(2)}) for primes up to ${maxPrime.toLocaleString()}...`;
            }
            
            // Use setTimeout to allow UI update
            setTimeout(() => {
                try {
                    // First pass to detect max gap if needed
                    if (autoDetect) {
                        const primes = sievePrimes(maxPrime);
                        let detectedMaxGap = 0;
                        for (let i = 0; i < primes.length - 1; i++) {
                            const gap = primes[i + 1] - primes[i];
                            if (gap > detectedMaxGap) {
                                detectedMaxGap = gap;
                            }
                        }
                        if (detectedMaxGap % 2 === 1 && detectedMaxGap > 1) detectedMaxGap--; // Make even if odd
                        maxGap = Math.max(detectedMaxGap, maxGap);
                        document.getElementById('maxGap').value = maxGap;
                        document.getElementById('maxGapDisplay').textContent = maxGap;
                    }
                    
                    if (comparisonMode) {
                        // Compute for multiple s values
                        const compData = computeComparisonData();
                        // Use s=2 as primary result for compatibility
                        analysisResults = compData[2];
                        analysisResults.comparisonData = compData;
                        
                        statusBar.className = 'status-bar complete';
                        statusBar.textContent = `Comparison complete: Computed for s = [1.5, 2, 3, 4, 5, 10]`;
                    } else {
                        // Single s analysis
                        analysisResults = computeGapDecompositionWithS(maxPrime, maxGap, s);
                        
                        const known = getKnownZetaValue(s);
                        const zetaLabel = known ? `ζ(${s}) = ${known.formula}` : `ζ(${s.toFixed(2)})`;
                        
                        statusBar.className = 'status-bar complete';
                        statusBar.textContent = `${zetaLabel}: ${analysisResults.totalPrimes} primes, ${analysisResults.evenGaps.length} gap families, error = ${(analysisResults.finalRelativeError * 100).toFixed(8)}%`;
                    }
                    
                    updateStatistics();
                    renderAllCharts();
                    
                    if (comparisonMode) {
                        showComparisonSummary();
                    }
                } catch (error) {
                    statusBar.className = 'status-bar';
                    statusBar.style.color = '#ff6464';
                    statusBar.textContent = `Error: ${error.message}`;
                    console.error(error);
                }
            }, 50);
        }
        
        function showComparisonSummary() {
            if (!analysisResults.comparisonData) return;
            
            console.log("=== Gap Contribution Comparison ===");
            const sValues = [1.5, 2, 3, 4, 5, 10];
            sValues.forEach(s => {
                const data = analysisResults.comparisonData[s];
                const gap1 = data.percentageContributions[1] || 0;
                const gap2 = data.percentageContributions[2] || 0;
                console.log(`s=${s}: Gap 1 = ${gap1.toFixed(1)}%, Gap 2 = ${gap2.toFixed(1)}%`);
            });
        }
        
        // Update statistics panel
        function updateStatistics() {
            if (!analysisResults) return;
            
            const statsPanel = document.getElementById('statsPanel');
            const statsGrid = document.getElementById('statsGrid');
            statsPanel.style.display = 'block';
            
            // Calculate π using the formula: π = √6 × √(∏P_g)
            const productRoot = Math.sqrt(analysisResults.finalProduct);
            const calculatedPi = Math.sqrt(6) * productRoot;
            const actualPi = Math.PI;
            const piError = Math.abs(calculatedPi - actualPi);
            const piRelError = (piError / actualPi) * 100;
            
            // Calculate additional stats
            const primes = analysisResults.primes;
            const primeSet = new Set(primes);
            let twinCount = 0;
            let cousinCount = 0;
            let sexyCount = 0;
            
            for (let i = 0; i < primes.length - 1; i++) {
                const p = primes[i];
                if (primes[i+1] - p === 2) twinCount++;
                if (primeSet.has(p + 4)) cousinCount++;
                if (primeSet.has(p + 6)) sexyCount++;
            }
            
            // Find most common gap
            const gapCounts = {};
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i+1] - primes[i];
                gapCounts[gap] = (gapCounts[gap] || 0) + 1;
            }
            const mostCommonGap = Object.entries(gapCounts)
                .sort((a, b) => b[1] - a[1])[0];
            
            const stats = [
                { label: 'Total Primes', value: analysisResults.totalPrimes.toLocaleString() },
                { label: 'Maximum Prime', value: analysisResults.maxPrime.toLocaleString() },
                { label: 'Gap Families', value: analysisResults.evenGaps.length },
                { label: 'Twin Primes', value: twinCount, info: 'Pairs (p, p+2)' },
                { label: 'Cousin Primes', value: cousinCount, info: 'Pairs (p, p+4)' },
                { label: 'Sexy Primes', value: sexyCount, info: 'Pairs (p, p+6)' },
                { label: 'Most Common Gap', value: `${mostCommonGap[0]} (${mostCommonGap[1]}×)` },
                { label: 'Largest Gap', value: Math.max(...analysisResults.evenGaps) },
                { label: 'Target ζ(2)', value: analysisResults.targetZeta2.toFixed(12) },
                { label: 'Computed Product', value: analysisResults.finalProduct.toFixed(12) },
                { label: 'Absolute Error', value: analysisResults.finalError.toExponential(6) },
                { label: 'Relative Error', value: (analysisResults.finalRelativeError * 100).toFixed(10) + '%' },
                { label: 'Calculated π', value: calculatedPi.toFixed(12), formula: 'π = √6 × √(∏P_g)' },
                { label: 'Actual π', value: actualPi.toFixed(12) },
                { label: 'π Error', value: piError.toExponential(6) },
                { label: 'π Rel. Error', value: piRelError.toFixed(10) + '%' }
            ];
            
            statsGrid.innerHTML = stats.map(stat => `
                <div class="stat-card">
                    <div class="stat-label">${stat.label}${stat.info ? '<br><span style="font-size: 0.65rem; color: #666;">' + stat.info + '</span>' : ''}${stat.formula ? '<br><span style="font-size: 0.65rem; color: #666;">' + stat.formula + '</span>' : ''}</div>
                    <div class="stat-value">${stat.value}</div>
                </div>
            `).join('');
        }
        
        // Render all charts
        function renderAllCharts() {
            if (!analysisResults) return;
            
            if (document.getElementById('showConvergence').checked) {
                renderConvergenceChart();
            }
            if (document.getElementById('showGapContributions').checked) {
                renderGapContributionsChart();
            }
            if (document.getElementById('showGapDistribution').checked) {
                renderGapDistributionChart();
            }
            if (document.getElementById('showPercentageContrib').checked) {
                renderPercentageChart();
            }
            if (document.getElementById('showErrorAnalysis').checked) {
                renderErrorChart();
            }
            if (document.getElementById('showLogScale').checked) {
                renderLogScaleChart();
            }
            
            // Render comparison chart if in comparison mode
            if (analysisResults.comparisonData) {
                renderComparisonChartActual();
            }
            
            // Update statistical tables
            updateStatsTables();
        }
        
        // Chart rendering functions

        // CLICK-TO-HIGHLIGHT FUNCTIONALITY
        let highlightedGap = null;
        
        function addTableClickHandlers() {
            // Add click handlers to all stat tables after they're rendered
            const tables = [
                'convergenceTableContent',
                'gapContribTableContent', 
                'gapDistTableContent',
                'percentageTableContent',
                'errorTableContent',
                'logScaleTableContent',
                'stepByStepTableContent'
            ];
            
            tables.forEach(tableId => {
                const table = document.getElementById(tableId);
                if (!table) return;
                
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach((row, index) => {
                    row.style.cursor = 'pointer';
                    row.addEventListener('click', function() {
                        // Remove previous highlights
                        document.querySelectorAll('.stats-table tr.highlighted').forEach(r => {
                            r.classList.remove('highlighted');
                        });
                        
                        // Add highlight to clicked row
                        this.classList.add('highlighted');
                        
                        // Get gap value from the row
                        const gapCell = this.cells[0] || this.cells[1]; // Try first or second column
                        if (gapCell) {
                            const gapValue = parseInt(gapCell.textContent);
                            if (!isNaN(gapValue)) {
                                highlightedGap = gapValue;
                                highlightGapOnCharts(gapValue);
                                
                                // Show detailed popup
                                showGapDetails(gapValue);
                            }
                        }
                    });
                });
            });
        }
        
        function highlightGapOnCharts(gap) {
            // Re-render charts with highlight
            if (document.getElementById('showGapContributions').checked) {
                renderGapContributionsChart(gap);
            }
            if (document.getElementById('showGapDistribution').checked) {
                renderGapDistributionChart(gap);
            }
            if (document.getElementById('showPercentageContrib').checked) {
                renderPercentageChart(gap);
            }
        }
        function renderConvergenceChart() {
            const canvas = document.getElementById('convergenceChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            // Clear
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const data = getFilteredProgressiveProducts();
            if (data.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data in selected gap range', w/2, h/2);
                return;
            }
            
            const target = analysisResults.targetZeta2;
            
            // Margins
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Scales
            const maxY = Math.max(target * 1.1, ...data.map(d => d.value));
            const minY = Math.min(0.8, ...data.map(d => d.value));
            const xScale = chartW / (data.length - 1);
            const yScale = chartH / (maxY - minY);
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxY - (maxY - minY) * (i / 10);
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(4), margin.left - 20, y + 12);
            }
            
            // Target line
            const targetY = margin.top + chartH - (target - minY) * yScale;
            ctx.strokeStyle = '#ff6464';
            ctx.lineWidth = 4;
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.moveTo(margin.left, targetY);
            ctx.lineTo(w - margin.right, targetY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ff6464';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`ζ(2) = π²/6 = ${target.toFixed(8)}`, margin.left + 40, targetY - 30);
            
            // Convergence line
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 6;
            ctx.beginPath();
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - (point.value - minY) * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Points
            ctx.fillStyle = '#ffd700';
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - (point.value - minY) * yScale;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // X-axis labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            data.forEach((point, i) => {
                if (i % Math.max(1, Math.floor(data.length / 15)) === 0) {
                    const x = margin.left + i * xScale;
                    ctx.fillText(`Gap ${point.gap}`, x, h - margin.bottom + 60);
                }
            });
            
            // Axis labels
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Progressive Product Convergence to ζ(2)', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Product Value', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Family', w / 2, h - 40);
        }
        
        function renderGapContributionsChart(highlightGap) {
            const canvas = document.getElementById('gapContribChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data in selected gap range', w/2, h/2);
                return;
            }
            
            const products = gaps.map(g => analysisResults.gapProducts[g]);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxProduct = Math.max(...products.map(p => p.product));
            const yScale = chartH / maxProduct;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxProduct - (maxProduct * (i / 10));
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(6), margin.left - 20, y + 12);
            }
            
            // Bars
            products.forEach((prod, i) => {
                const gap = gaps[i];
                const x = margin.left + i * barWidth;
                const barH = prod.product * yScale;
                const y = margin.top + chartH - barH;
                
                const isHighlighted = highlightGap && gap === highlightGap;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                if (isHighlighted) {
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#cc0000');
                } else {
                    gradient.addColorStop(0, '#ffd700');
                    gradient.addColorStop(1, '#ffaa00');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = isHighlighted ? '#ff0000' : '#ffaa00';
                ctx.lineWidth = isHighlighted ? 8 : 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                const isHighlighted = highlightGap && gap === highlightGap;
                ctx.fillStyle = isHighlighted ? '#ff0000' : '#aaa';
                ctx.font = isHighlighted ? 'bold 32px monospace' : 'bold 24px monospace';
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Individual Gap Family Products P_g', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Product P_g', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderGapDistributionChart(highlightGap) {
            const canvas = document.getElementById('gapDistChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data in selected gap range', w/2, h/2);
                return;
            }
            
            const counts = gaps.map(g => analysisResults.gapProducts[g].count);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxCount = Math.max(...counts);
            const yScale = chartH / maxCount;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxCount - (maxCount * (i / 10));
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(value).toLocaleString(), margin.left - 20, y + 12);
            }
            
            // Bars
            counts.forEach((count, i) => {
                const x = margin.left + i * barWidth;
                const barH = count * yScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                gradient.addColorStop(0, '#64ff64');
                gradient.addColorStop(1, '#32aa32');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = '#32aa32';
                ctx.lineWidth = 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Number of Primes per Gap Family', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Prime Count', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderPercentageChart(highlightGap) {
            const canvas = document.getElementById('percentageChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const percentages = gaps.map(g => analysisResults.percentageContributions[g]);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxPct = Math.max(...percentages);
            const yScale = chartH / maxPct;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxPct - (maxPct * (i / 10));
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(2) + '%', margin.left - 20, y + 12);
            }
            
            // Bars
            percentages.forEach((pct, i) => {
                const x = margin.left + i * barWidth;
                const barH = pct * yScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                gradient.addColorStop(0, '#ff6464');
                gradient.addColorStop(1, '#aa3232');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = '#aa3232';
                ctx.lineWidth = 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Percentage Contribution to log(ζ(2))', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Contribution %', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderErrorChart() {
            const canvas = document.getElementById('errorChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const data = analysisResults.progressiveProducts;
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const xScale = chartW / (data.length - 1);
            const errors = data.map(d => d.relativeError);
            const maxError = Math.max(...errors);
            const minError = Math.min(...errors);
            const yScale = chartH / (maxError - minError);
            
            // Grid (log scale for y-axis)
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const logValue = Math.log10(maxError) - (Math.log10(maxError) - Math.log10(minError)) * (i / 10);
                const value = Math.pow(10, logValue);
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText((value * 100).toExponential(2) + '%', margin.left - 20, y + 12);
            }
            
            // Error line
            ctx.strokeStyle = '#64ffff';
            ctx.lineWidth = 6;
            ctx.beginPath();
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const logError = Math.log10(point.relativeError);
                const normalizedLog = (logError - Math.log10(minError)) / (Math.log10(maxError) - Math.log10(minError));
                const y = margin.top + chartH * (1 - normalizedLog);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Points
            ctx.fillStyle = '#64ffff';
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const logError = Math.log10(point.relativeError);
                const normalizedLog = (logError - Math.log10(minError)) / (Math.log10(maxError) - Math.log10(minError));
                const y = margin.top + chartH * (1 - normalizedLog);
                
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            data.forEach((point, i) => {
                if (i % Math.max(1, Math.floor(data.length / 15)) === 0) {
                    const x = margin.left + i * xScale;
                    ctx.fillText(`Gap ${point.gap}`, x, h - margin.bottom + 60);
                }
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Relative Error vs Target (Log Scale)', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Relative Error', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Family', w / 2, h - 40);
        }
        
        function renderLogScaleChart() {
            const canvas = document.getElementById('logScaleChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const logProducts = gaps.map(g => analysisResults.gapProducts[g].logProduct);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxLog = Math.max(...logProducts);
            const minLog = Math.min(0, ...logProducts);
            const yScale = chartH / (maxLog - minLog);
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxLog - (maxLog - minLog) * (i / 10);
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(4), margin.left - 20, y + 12);
            }
            
            // Bars
            logProducts.forEach((logProd, i) => {
                const x = margin.left + i * barWidth;
                const barH = (logProd - minLog) * yScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                gradient.addColorStop(0, '#aa64ff');
                gradient.addColorStop(1, '#6432aa');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = '#6432aa';
                ctx.lineWidth = 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Log-Scale Product Growth: log(P_g)', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('log(P_g)', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        // Animation functions
        function startAnimation() {
            if (isAnimating) return;
            
            const useMaxPrime = document.getElementById('useMaxPrimeForAnim').checked;
            let startRange, endRange;
            
            if (useMaxPrime) {
                startRange = 100;
                endRange = parseInt(document.getElementById('maxPrime').value);
            } else {
                startRange = parseInt(document.getElementById('animStart').value);
                endRange = parseInt(document.getElementById('animEnd').value);
            }
            
            if (startRange >= endRange) {
                alert('Animation start must be less than end');
                return;
            }
            
            const animSpeed = parseInt(document.getElementById('animSpeed').value);
            
            isAnimating = true;
            let currentRange = startRange;
            const step = Math.max(100, Math.floor((endRange - startRange) / 100));
            
            const statusBar = document.getElementById('statusBar');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            
            statusBar.style.display = 'block';
            progressContainer.style.display = 'block';
            
            function animateFrame() {
                if (!isAnimating || currentRange > endRange) {
                    stopAnimation();
                    return;
                }
                
                const maxGap = parseInt(document.getElementById('maxGap').value);
                analysisResults = computeGapDecomposition(currentRange, maxGap);
                
                const progress = ((currentRange - startRange) / (endRange - startRange)) * 100;
                progressFill.style.width = progress + '%';
                
                statusBar.className = 'status-bar computing';
                statusBar.textContent = `Animating: ${currentRange.toLocaleString()} / ${endRange.toLocaleString()} primes (${progress.toFixed(1)}%)`;
                
                updateStatistics();
                renderAllCharts();
                
                currentRange += step;
                
                // Use setTimeout with speed control instead of requestAnimationFrame
                setTimeout(() => {
                    animationId = requestAnimationFrame(animateFrame);
                }, animSpeed);
            }
            
            animateFrame();
        }
        
        function stopAnimation() {
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            const statusBar = document.getElementById('statusBar');
            const progressContainer = document.getElementById('progressContainer');
            
            statusBar.className = 'status-bar complete';
            statusBar.textContent = 'Animation complete';
            progressContainer.style.display = 'none';
        }
        
        // Export functions
        function exportAllData() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            let csv = 'Gap-Class Decomposition of zeta(2) = pi^2/6\n';
            csv += `Analysis Date,${new Date().toISOString()}\n`;
            csv += `Maximum Prime,${analysisResults.maxPrime}\n`;
            csv += `Total Primes,${analysisResults.totalPrimes}\n`;
            csv += `Target zeta(2),${analysisResults.targetZeta2}\n`;
            csv += `Computed Product,${analysisResults.finalProduct}\n`;
            csv += `Absolute Error,${analysisResults.finalError}\n`;
            csv += `Relative Error,${analysisResults.finalRelativeError}\n\n`;
            
            csv += 'Gap Family Analysis\n';
            csv += 'Gap,Prime Count,Product P_g,Log Product,Percentage Contribution,First 20 Primes\n';
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = analysisResults.percentageContributions[gap];
                const primes = data.primes.slice(0, 20).join(' ');
                csv += `${gap},${data.count},${data.product},${data.logProduct},${pct},"${primes}"\n`;
            });
            
            csv += '\nProgressive Convergence\n';
            csv += 'Gap,Cumulative Product,Log Product,Absolute Error,Relative Error\n';
            analysisResults.progressiveProducts.forEach(p => {
                csv += `${p.gap},${p.value},${p.logValue},${p.error},${p.relativeError}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.download = `gap_decomposition_${analysisResults.maxPrime}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function exportAllCharts() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const canvases = [
                { id: 'convergenceChart', name: 'convergence' },
                { id: 'gapContribChart', name: 'gap_contributions' },
                { id: 'gapDistChart', name: 'gap_distribution' },
                { id: 'percentageChart', name: 'percentage' },
                { id: 'errorChart', name: 'error_analysis' },
                { id: 'logScaleChart', name: 'log_scale' }
            ];
            
            canvases.forEach(({ id, name }) => {
                const canvas = document.getElementById(id);
                const link = document.createElement('a');
                link.download = `${name}_${analysisResults.maxPrime}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        }
        
        // Event listeners
        document.getElementById('maxPrime').addEventListener('input', updateDisplays);
        document.getElementById('maxGap').addEventListener('input', updateDisplays);
        document.getElementById('animStart').addEventListener('input', updateDisplays);
        document.getElementById('animEnd').addEventListener('input', updateDisplays);
        
        // Table toggle function
        const tableStates = {
            convergenceTable: false,
            gapContribTable: false,
            gapDistTable: false,
            percentageTable: false,
            errorTable: false,
            logScaleTable: false,
            stepByStepTable: true
        };
        
        function toggleTable(tableId) {
            const container = document.getElementById(tableId);
            const button = event.target;
            
            tableStates[tableId] = !tableStates[tableId];
            
            if (tableStates[tableId]) {
                container.classList.add('expanded');
                button.textContent = 'Show Less';
            } else {
                container.classList.remove('expanded');
                button.textContent = 'Show All';
            }
            
            updateStatsTables();
        }
        
        // Update all stats tables
        function updateStatsTables() {
            if (!analysisResults) return;
            
            updateConvergenceTable();
            updateGapContribTable();
            updateGapDistTable();
            updatePercentageTable();
            updateErrorTable();
            updateLogScaleTable();
            updateStepByStepTable();
            
            // Add click handlers after tables are populated
            setTimeout(() => addTableClickHandlers(), 100);
        }
        
        function updateConvergenceTable() {
            const precision = parseInt(document.getElementById('convergencePrecision').value);
            const showAll = tableStates.convergenceTable;
            const data = analysisResults.progressiveProducts;
            const displayData = showAll ? data : data.slice(0, 5);
            
            const table = document.getElementById('convergenceTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Cumulative Product</th>
                        <th>Log Product</th>
                        <th>Target ζ(2)</th>
                        <th>Absolute Error</th>
                        <th>Relative Error (%)</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayData.forEach(row => {
                html += `
                    <tr>
                        <td>${row.gap}</td>
                        <td>${row.value.toFixed(precision)}</td>
                        <td>${row.logValue.toFixed(precision)}</td>
                        <td>${analysisResults.targetZeta2.toFixed(precision)}</td>
                        <td>${row.error.toExponential(precision)}</td>
                        <td>${(row.relativeError * 100).toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            if (!showAll && data.length > 5) {
                html += `
                    <tr>
                        <td colspan="6" style="text-align: center; color: #888; font-style: italic;">
                            ... ${data.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateGapContribTable() {
            const precision = parseInt(document.getElementById('gapContribPrecision').value);
            const showAll = tableStates.gapContribTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const table = document.getElementById('gapContribTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Product P<sub>g</sub></th>
                        <th>Log(P<sub>g</sub>)</th>
                        <th>Prime Count</th>
                        <th>First 10 Primes</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const primeList = data.primes.slice(0, 10).join(', ');
                html += `
                    <tr>
                        <td>${gap}</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                        <td>${data.count}</td>
                        <td class="prime-list">${primeList}${data.count > 10 ? '...' : ''}</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateGapDistTable() {
            const precision = parseInt(document.getElementById('gapDistPrecision').value);
            const showAll = tableStates.gapDistTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const totalPrimes = analysisResults.totalPrimes;
            
            const table = document.getElementById('gapDistTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Prime Count</th>
                        <th>Percentage of Total</th>
                        <th>Cumulative Count</th>
                        <th>Cumulative %</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            let cumulative = 0;
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                cumulative += data.count;
                const percentage = (data.count / totalPrimes) * 100;
                const cumulativePercentage = (cumulative / totalPrimes) * 100;
                
                html += `
                    <tr>
                        <td>${gap}</td>
                        <td>${data.count}</td>
                        <td>${percentage.toFixed(precision)}%</td>
                        <td>${cumulative}</td>
                        <td>${cumulativePercentage.toFixed(precision)}%</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updatePercentageTable() {
            const precision = parseInt(document.getElementById('percentagePrecision').value);
            const showAll = tableStates.percentageTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const table = document.getElementById('percentageTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Contribution to log(ζ(2))</th>
                        <th>Product P<sub>g</sub></th>
                        <th>Ratio to ζ(2)</th>
                        <th>Log Contribution</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const percentage = analysisResults.percentageContributions[gap];
                const ratio = data.product / analysisResults.targetZeta2;
                
                html += `
                    <tr>
                        <td>${gap}</td>
                        <td>${percentage.toFixed(precision)}%</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${ratio.toFixed(precision)}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateErrorTable() {
            const precision = parseInt(document.getElementById('errorPrecision').value);
            const showAll = tableStates.errorTable;
            const data = analysisResults.progressiveProducts;
            const displayData = showAll ? data : data.slice(0, 5);
            
            const table = document.getElementById('errorTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Product Value</th>
                        <th>Absolute Error</th>
                        <th>Relative Error</th>
                        <th>Log10(Error)</th>
                        <th>Error Reduction</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayData.forEach((row, idx) => {
                const logError = Math.log10(row.relativeError);
                const prevError = idx > 0 ? data[idx - 1].relativeError : row.relativeError;
                const errorReduction = idx > 0 ? ((prevError - row.relativeError) / prevError * 100) : 0;
                
                html += `
                    <tr>
                        <td>${row.gap}</td>
                        <td>${row.value.toFixed(precision)}</td>
                        <td>${row.error.toExponential(precision)}</td>
                        <td>${(row.relativeError * 100).toFixed(precision)}%</td>
                        <td>${logError.toFixed(precision)}</td>
                        <td>${errorReduction.toFixed(precision)}%</td>
                    </tr>
                `;
            });
            
            if (!showAll && data.length > 5) {
                html += `
                    <tr>
                        <td colspan="6" style="text-align: center; color: #888; font-style: italic;">
                            ... ${data.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateLogScaleTable() {
            const precision = parseInt(document.getElementById('logScalePrecision').value);
            const showAll = tableStates.logScaleTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const table = document.getElementById('logScaleTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Log(P<sub>g</sub>)</th>
                        <th>P<sub>g</sub></th>
                        <th>Prime Count</th>
                        <th>Avg Log per Prime</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const avgLogPerPrime = data.logProduct / data.count;
                
                html += `
                    <tr>
                        <td>${gap}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${data.count}</td>
                        <td>${avgLogPerPrime.toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateStepByStepTable() {
            const precision = parseInt(document.getElementById('stepByStepPrecision').value);
            const showAll = tableStates.stepByStepTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            const target = analysisResults.targetZeta2;
            
            const table = document.getElementById('stepByStepTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Gap Added</th>
                        <th>P<sub>g</sub></th>
                        <th>Formula</th>
                        <th>Cumulative Product</th>
                        <th>Distance to π²/6</th>
                        <th>% Complete</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach((gap, idx) => {
                const data = analysisResults.gapProducts[gap];
                const cumulative = analysisResults.progressiveProducts[idx].value;
                const distance = target - cumulative;
                const percentComplete = (cumulative / target) * 100;
                
                // Build formula string showing multiplication
                let formula = 'P₁';
                for (let i = 1; i <= idx; i++) {
                    formula += ` × P${gaps[i]}`;
                }
                
                html += `
                    <tr>
                        <td>${idx + 1}</td>
                        <td>${gap}</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td style="font-size: 0.85rem; color: #aaa;">${formula}</td>
                        <td>${cumulative.toFixed(precision)}</td>
                        <td>${distance.toFixed(precision)}</td>
                        <td>${percentComplete.toFixed(precision)}%</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="7" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            // Add final target row
            html += `
                <tr style="border-top: 3px solid #ffd700; background: rgba(255, 215, 0, 0.1); font-weight: 600;">
                    <td>Target</td>
                    <td colspan="3" style="text-align: center;">ζ(2) = π²/6</td>
                    <td>${target.toFixed(precision)}</td>
                    <td>0.${'0'.repeat(precision)}</td>
                    <td>100.${'0'.repeat(precision)}%</td>
                </tr>
            `;
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        // Export functions for individual tables and charts
        function exportTableCSV(tableType) {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const maxPrime = analysisResults.maxPrime;
            let csv = '';
            let filename = '';
            
            switch(tableType) {
                case 'convergence':
                    csv = generateConvergenceCSV();
                    filename = `convergence_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'gapContrib':
                    csv = generateGapContribCSV();
                    filename = `gap_contributions_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'gapDist':
                    csv = generateGapDistCSV();
                    filename = `gap_distribution_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'percentage':
                    csv = generatePercentageCSV();
                    filename = `percentage_contributions_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'error':
                    csv = generateErrorCSV();
                    filename = `error_analysis_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'logScale':
                    csv = generateLogScaleCSV();
                    filename = `log_scale_products_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'stepByStep':
                    csv = generateStepByStepCSV();
                    filename = `step_by_step_${maxPrime}_${timestamp}.csv`;
                    break;
            }
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
        
        function exportChartPNG(canvasId, chartName) {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            
            // Create composite canvas
            const compositeCanvas = document.createElement('canvas');
            const ctx = compositeCanvas.getContext('2d');
            
            // Get source chart
            const sourceCanvas = document.getElementById(canvasId);
            const chartW = sourceCanvas.width;
            const chartH = sourceCanvas.height;
            
            // Get row count from global export setting
            const rowCountSetting = document.getElementById('globalExportRows')?.value || '15';
            const maxRows = rowCountSetting === 'all' ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            
            // Calculate dynamic dimensions
            const headerH = 250;
            const statsBarH = 120;
            const tableHeaderH = 60;
            const rowHeight = 50;
            const tableH = tableHeaderH + (maxRows * rowHeight) + 100; // Header + rows + bottom padding
            const padding = 40;
            const footerSpace = 80; // Empty space at bottom
            
            compositeCanvas.width = chartW;
            compositeCanvas.height = headerH + statsBarH + chartH + tableH + footerSpace;
            
            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
            
            // Title section
            const titleMap = {
                'convergenceChart': 'Progressive Convergence to ζ(2) = π²/6',
                'gapContribChart': 'Individual Gap Family Products P_g',
                'gapDistChart': 'Prime Distribution by Gap Class',
                'percentageChart': 'Percentage Contribution to ζ(2)',
                'errorChart': 'Convergence Error Analysis',
                'logScaleChart': 'Log-Scale Product Growth'
            };
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 72px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(titleMap[canvasId] || 'Chart', compositeCanvas.width / 2, 90);
            
            ctx.fillStyle = '#888';
            ctx.font = '36px monospace';
            const dateStr = new Date().toLocaleDateString('en-GB', { 
                day: '2-digit', 
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            ctx.fillText(`Analysis Date: ${dateStr}`, compositeCanvas.width / 2, 160);
            
            // Stats summary bar
            const statsY = headerH + padding;
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(padding, statsY, compositeCanvas.width - 2 * padding, statsBarH - 2 * padding);
            
            ctx.strokeStyle = '#3a3a5a';
            ctx.lineWidth = 3;
            ctx.strokeRect(padding, statsY, compositeCanvas.width - 2 * padding, statsBarH - 2 * padding);
            
            // Stats content - 6 boxes
            const boxW = (compositeCanvas.width - 2 * padding - 5 * 20) / 6;
            const statsData = [
                { label: 'N Range', value: analysisResults.maxPrime.toLocaleString() },
                { label: 'Total Primes', value: analysisResults.totalPrimes.toLocaleString() },
                { label: 'Gap Families', value: analysisResults.evenGaps.length.toString() },
                { label: 'Target ζ(2)', value: analysisResults.targetZeta2.toFixed(8) },
                { label: 'Final Product', value: analysisResults.finalProduct.toFixed(8) },
                { label: 'Rel. Error', value: (analysisResults.finalRelativeError * 100).toFixed(6) + '%' }
            ];
            
            statsData.forEach((stat, idx) => {
                const x = padding + idx * (boxW + 20);
                
                ctx.fillStyle = '#888';
                ctx.font = '28px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(stat.label, x + boxW / 2, statsY + 30);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 40px monospace';
                ctx.fillText(stat.value, x + boxW / 2, statsY + 70);
            });
            
            // Draw chart
            const chartY = headerH + statsBarH;
            ctx.drawImage(sourceCanvas, 0, chartY, chartW, chartH);
            
            // Draw stats table
            const tableY = chartY + chartH + padding;
            const actualTableHeight = renderStatsTableToCanvas(ctx, canvasId, tableY, compositeCanvas.width, maxRows);
            
            // Add footer info
            const footerY = tableY + actualTableHeight + 30;
            ctx.fillStyle = '#666';
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Showing ${maxRows} rows | Analysis: ${analysisResults.totalPrimes.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, compositeCanvas.width / 2, footerY);
            
            // Export
            const link = document.createElement('a');
            link.download = `${chartName}_with_stats_${analysisResults.maxPrime}_${timestamp}.png`;
            link.href = compositeCanvas.toDataURL('image/png');
            link.click();
        }
        
        function renderStatsTableToCanvas(ctx, canvasId, startY, canvasWidth, maxRows) {
            // Determine which table data to render based on canvasId
            const tableMap = {
                'convergenceChart': renderConvergenceTableData,
                'gapContribChart': renderGapContribTableData,
                'gapDistChart': renderGapDistTableData,
                'percentageChart': renderPercentageTableData,
                'errorChart': renderErrorTableData,
                'logScaleChart': renderLogScaleTableData
            };
            
            const renderFunc = tableMap[canvasId];
            if (renderFunc) {
                return renderFunc(ctx, startY, canvasWidth, maxRows);
            }
            return 0;
        }
        
        function renderConvergenceTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                // Fallback if called without maxRows
                const rowCountSetting = document.getElementById('globalExportRows')?.value || '15';
                maxRows = rowCountSetting === 'all' ? analysisResults.progressiveProducts.length : parseInt(rowCountSetting);
            }
            
            const precision = parseInt(document.getElementById('convergencePrecision').value);
            const data = analysisResults.progressiveProducts.slice(0, maxRows);
            
            const headers = ['Gap', 'Cumulative Product', 'Log Product', 'Target ζ(2)', 'Abs Error', 'Rel Error (%)'];
            const colW = (canvasWidth - 80) / headers.length;
            
            // Header background
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            // Headers
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            // Rows
            ctx.font = '28px monospace';
            data.forEach((row, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                
                // Alternating row background
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const rowData = [
                    row.gap.toString(),
                    row.value.toFixed(precision),
                    row.logValue.toFixed(precision),
                    analysisResults.targetZeta2.toFixed(precision),
                    row.error.toExponential(precision),
                    (row.relativeError * 100).toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add TARGET row
            const targetY = startY + 60 + data.length * 50;
            
            // Target row background (gold border)
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, targetY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, targetY, canvasWidth - 80, 50);
            
            // Target row data
            const s = analysisResults.s || 2;
            const known = getKnownZetaValue(s);
            const zetaLabel = known ? known.formula : `ζ(${s.toFixed(1)})`;
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const targetData = [
                'Target',
                '∞',
                zetaLabel,
                analysisResults.targetZeta2.toFixed(precision),
                '0.0',
                '100.0'
            ];
            
            targetData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + colIdx * colW + colW / 2, targetY + 35);
            });
            
            // Return actual height used (including target row)
            const tableHeaderH = 60;
            const rowHeight = 50;
            return tableHeaderH + (data.length * rowHeight) + rowHeight; // +1 for target row
        }
        
        function renderGapContribTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            
            const precision = parseInt(document.getElementById('gapContribPrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Product P_g', 'Log(P_g)', 'Prime Count', 'First Primes'];
            const colWidths = [0.1, 0.2, 0.2, 0.15, 0.35];
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            let xPos = 40;
            headers.forEach((header, idx) => {
                const w = (canvasWidth - 80) * colWidths[idx];
                ctx.fillText(header, xPos + w / 2, startY + 40);
                xPos += w;
            });
            
            ctx.font = '28px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const primes = data.primes.slice(0, 5).join(', ');
                const rowData = [
                    gap.toString(),
                    data.product.toFixed(precision),
                    data.logProduct.toFixed(precision),
                    data.count.toString(),
                    primes
                ];
                
                xPos = 40;
                rowData.forEach((cell, colIdx) => {
                    const w = (canvasWidth - 80) * colWidths[colIdx];
                    ctx.textAlign = colIdx === 4 ? 'left' : 'center';
                    const textX = colIdx === 4 ? xPos + 10 : xPos + w / 2;
                    ctx.fillText(cell, textX, y + 35);
                    xPos += w;
                });
            });
            
            // Add TARGET row
            const targetY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, targetY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, targetY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const targetData = ['Target', '∞', '1.0', analysisResults.targetZeta2.toFixed(precision), 'ALL'];
            
            xPos = 0; // Reuse existing xPos variable
            targetData.forEach((cell, colIdx) => {
                const w = (canvasWidth - 80) * colWidths[colIdx];
                ctx.textAlign = colIdx === 4 ? 'left' : 'center';
                const textX = colIdx === 4 ? 40 + xPos + 10 : 40 + xPos + w / 2;
                ctx.fillText(cell, textX, targetY + 35);
                xPos += w;
            });
            
            return 60 + (gaps.length * 50) + 50; // Header + rows + target
        }
        
        function renderGapDistTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('gapDistPrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Count', '% of Total', 'Cumulative', 'Cumulative %'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            let cumulative = 0;
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                cumulative += data.count;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const percentage = (data.count / analysisResults.totalPrimes) * 100;
                const cumulativePercentage = (cumulative / analysisResults.totalPrimes) * 100;
                
                const rowData = [
                    gap.toString(),
                    data.count.toString(),
                    percentage.toFixed(precision) + '%',
                    cumulative.toString(),
                    cumulativePercentage.toFixed(precision) + '%'
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add TARGET row
            const targetY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, targetY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, targetY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const targetData = ['Total', analysisResults.totalPrimes.toLocaleString(), '100.0%', analysisResults.totalPrimes.toLocaleString(), '100.0%'];
            
            targetData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + colIdx * colW + colW / 2, targetY + 35);
            });
            
            return 60 + (gaps.length * 50) + 50; // Header + rows + target
        }
        
        function renderPercentageTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('percentagePrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Contribution %', 'Product P_g', 'Ratio', 'Log Contrib'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const percentage = analysisResults.percentageContributions[gap];
                const ratio = data.product / analysisResults.targetZeta2;
                
                const rowData = [
                    gap.toString(),
                    percentage.toFixed(precision) + '%',
                    data.product.toFixed(precision),
                    ratio.toFixed(precision),
                    data.logProduct.toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add TARGET row  
            const targetY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, targetY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, targetY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const totalLogProduct = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.logProduct || 0), 0);
            const targetData = ['Total', '100.0%', analysisResults.targetZeta2.toFixed(precision), '1.0', totalLogProduct.toFixed(precision)];
            
            targetData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + colIdx * colW + colW / 2, targetY + 35);
            });
            
            return 60 + (gaps.length * 50) + 50;
        }
        
        function renderErrorTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.progressiveProducts.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('errorPrecision').value);
            const data = analysisResults.progressiveProducts.slice(0, maxRows);
            
            const headers = ['Gap', 'Product', 'Abs Error', 'Rel Error', 'Log10(Error)'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            data.forEach((row, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const logError = Math.log10(row.relativeError);
                
                const rowData = [
                    row.gap.toString(),
                    row.value.toFixed(precision),
                    row.error.toExponential(precision),
                    (row.relativeError * 100).toFixed(precision) + '%',
                    logError.toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add TARGET row
            const targetY = startY + 60 + data.length * 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, targetY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, targetY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const targetData = ['Target', analysisResults.targetZeta2.toFixed(precision), '0.0', '0.0%', '—'];
            
            targetData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + colIdx * colW + colW / 2, targetY + 35);
            });
            
            return 60 + (data.length * 50) + 50;
        }
        
        function renderLogScaleTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('logScalePrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Log(P_g)', 'P_g', 'Count', 'Avg/Prime'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const avgLogPerPrime = data.logProduct / data.count;
                
                const rowData = [
                    gap.toString(),
                    data.logProduct.toFixed(precision),
                    data.product.toFixed(precision),
                    data.count.toString(),
                    avgLogPerPrime.toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add TARGET row
            const targetY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, targetY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, targetY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const totalLog = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.logProduct || 0), 0);
            const targetData = ['Total', totalLog.toFixed(precision), analysisResults.targetZeta2.toFixed(precision), analysisResults.totalPrimes.toLocaleString(), '—'];
            
            targetData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + colIdx * colW + colW / 2, targetY + 35);
            });
            
            return 60 + (gaps.length * 50) + 50;
        }
        
        function generateConvergenceCSV() {
            const precision = parseInt(document.getElementById('convergencePrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Progressive Convergence Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset presents the progressive convergence of the gap-class decomposition\n';
            csv += 'of the Riemann zeta function at s=2. By partitioning the Euler product according\n';
            csv += 'to prime gap classes, we observe how each gap family P_g contributes to the final\n';
            csv += 'value of pi^2/6. The cumulative product demonstrates geometric convergence as\n';
            csv += 'additional gap families are incorporated into the decomposition.\n\n';
            
            csv += 'METHODOLOGY:\n';
            csv += 'For each even gap g, we compute P_g = product over all primes p with gap(p)=g of p^2/(p^2-1)\n';
            csv += 'The progressive product tracks: zeta(2) = P_1 × P_2 × P_4 × P_6 × ...\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime Analyzed:,${analysisResults.maxPrime}\n`;
            csv += `Total Primes Found:,${analysisResults.totalPrimes}\n`;
            csv += `Number of Gap Families:,${analysisResults.evenGaps.length}\n`;
            csv += `Target Value (pi^2/6):,${analysisResults.targetZeta2}\n`;
            csv += `Final Computed Product:,${analysisResults.finalProduct}\n`;
            csv += `Final Absolute Error:,${analysisResults.finalError}\n`;
            csv += `Final Relative Error:,${analysisResults.finalRelativeError}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Cumulative Product,Log Product,Target zeta(2),Absolute Error,Relative Error (%)\n';
            
            analysisResults.progressiveProducts.forEach(row => {
                csv += `${row.gap},${row.value.toFixed(precision)},${row.logValue.toFixed(precision)},`;
                csv += `${analysisResults.targetZeta2.toFixed(precision)},${row.error.toExponential(precision)},`;
                csv += `${(row.relativeError * 100).toFixed(precision)}\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateGapContribCSV() {
            const precision = parseInt(document.getElementById('gapContribPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Individual Gap Family Products\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset contains the individual product values P_g for each gap family.\n';
            csv += 'Each P_g represents the contribution of all primes with forward gap g to the\n';
            csv += 'overall Euler product. The data includes prime counts, product values, logarithmic\n';
            csv += 'contributions, and the first primes in each family for verification and further analysis.\n\n';
            
            csv += 'FORMULA:\n';
            csv += 'P_g = product over all primes p where gap(p)=g of [p^2 / (p^2 - 1)]\n';
            csv += 'where gap(p) = next_prime(p) - p\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Total Primes:,${analysisResults.totalPrimes}\n`;
            csv += `Total Gap Families:,${analysisResults.evenGaps.length}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Product P_g,Log(P_g),Prime Count,Percentage of Total,First 20 Primes in Family\n';
            
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = (data.count / analysisResults.totalPrimes * 100).toFixed(4);
                const primes = data.primes.slice(0, 20).join(' ');
                csv += `${gap},${data.product.toFixed(precision)},${data.logProduct.toFixed(precision)},`;
                csv += `${data.count},${pct}%,"${primes}"\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateGapDistCSV() {
            const precision = parseInt(document.getElementById('gapDistPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Prime Distribution by Gap Class\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset analyzes how primes distribute across different gap classes.\n';
            csv += 'For each even gap g, we count how many primes have forward gap g, compute\n';
            csv += 'the percentage of total primes this represents, and track cumulative statistics.\n';
            csv += 'This data is essential for understanding prime constellation frequencies and\n';
            csv += 'testing conjectures about gap distribution (e.g., Twin Prime Conjecture).\n\n';
            
            csv += 'DEFINITIONS:\n';
            csv += '- Gap g: The difference between consecutive primes (p_n+1 - p_n)\n';
            csv += '- Count: Number of primes p where gap(p) = g\n';
            csv += '- Percentage: (Count / Total Primes) × 100\n';
            csv += '- Cumulative: Running total of primes accounted for\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Total Primes Analyzed:,${analysisResults.totalPrimes}\n`;
            csv += `Distinct Gap Families:,${analysisResults.evenGaps.length}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Prime Count,Percentage of Total,Cumulative Count,Cumulative Percentage\n';
            
            let cumulative = 0;
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                cumulative += data.count;
                const percentage = (data.count / analysisResults.totalPrimes) * 100;
                const cumulativePercentage = (cumulative / analysisResults.totalPrimes) * 100;
                
                csv += `${gap},${data.count},${percentage.toFixed(precision)}%,`;
                csv += `${cumulative},${cumulativePercentage.toFixed(precision)}%\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generatePercentageCSV() {
            const precision = parseInt(document.getElementById('percentagePrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Percentage Contribution Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset quantifies the relative contribution of each gap family to the\n';
            csv += 'final value of zeta(2) = pi^2/6. Contributions are measured logarithmically\n';
            csv += 'since the Euler product is multiplicative. The data reveals which gap classes\n';
            csv += 'dominate the convergence and how contribution scales with gap size.\n\n';
            
            csv += 'METHODOLOGY:\n';
            csv += 'Contribution percentage = [log(P_g) / log(zeta(2))] × 100\n';
            csv += 'This measures what fraction of the logarithmic sum comes from each gap class.\n';
            csv += 'Ratio = P_g / zeta(2) shows the multiplicative contribution.\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Target zeta(2):,${analysisResults.targetZeta2}\n`;
            csv += `Final Product:,${analysisResults.finalProduct}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Contribution to log(zeta(2)) (%),Product P_g,Ratio to zeta(2),Log Contribution\n';
            
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const percentage = analysisResults.percentageContributions[gap];
                const ratio = data.product / analysisResults.targetZeta2;
                
                csv += `${gap},${percentage.toFixed(precision)}%,${data.product.toFixed(precision)},`;
                csv += `${ratio.toFixed(precision)},${data.logProduct.toFixed(precision)}\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateErrorCSV() {
            const precision = parseInt(document.getElementById('errorPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Convergence Error Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset tracks the convergence error as additional gap families are\n';
            csv += 'incorporated into the decomposition. Multiple error metrics are provided:\n';
            csv += 'absolute error, relative error, logarithmic error, and error reduction rate.\n';
            csv += 'The data demonstrates geometric convergence to pi^2/6 and can be used to\n';
            csv += 'estimate asymptotic convergence rates.\n\n';
            
            csv += 'ERROR DEFINITIONS:\n';
            csv += '- Absolute Error: |Product - pi^2/6|\n';
            csv += '- Relative Error: Absolute Error / pi^2/6\n';
            csv += '- Log10(Error): Logarithmic scale for visualization\n';
            csv += '- Error Reduction: Percentage decrease from previous step\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Target zeta(2):,${analysisResults.targetZeta2}\n`;
            csv += `Final Relative Error:,${(analysisResults.finalRelativeError * 100).toFixed(precision)}%\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Product Value,Absolute Error,Relative Error (%),Log10(Error),Error Reduction (%)\n';
            
            const data = analysisResults.progressiveProducts;
            data.forEach((row, idx) => {
                const logError = Math.log10(row.relativeError);
                const prevError = idx > 0 ? data[idx - 1].relativeError : row.relativeError;
                const errorReduction = idx > 0 ? ((prevError - row.relativeError) / prevError * 100) : 0;
                
                csv += `${row.gap},${row.value.toFixed(precision)},${row.error.toExponential(precision)},`;
                csv += `${(row.relativeError * 100).toFixed(precision)}%,${logError.toFixed(precision)},`;
                csv += `${errorReduction.toFixed(precision)}%\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateLogScaleCSV() {
            const precision = parseInt(document.getElementById('logScalePrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Logarithmic Product Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset presents logarithmic analysis of gap family products.\n';
            csv += 'Working in log space reveals linear patterns that may be obscured in\n';
            csv += 'multiplicative form. The average log contribution per prime in each\n';
            csv += 'gap family can reveal scaling relationships and potential closed-form\n';
            csv += 'expressions for P_g involving pi or other fundamental constants.\n\n';
            
            csv += 'ANALYTICAL VALUE:\n';
            csv += 'Log-scale analysis is crucial for:\n';
            csv += '- Detecting power-law relationships in P_g vs g\n';
            csv += '- Identifying potential pi-based formulas for individual gap products\n';
            csv += '- Computing asymptotic behavior as g → infinity\n';
            csv += '- Stable numerical analysis of very small/large products\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Total Gap Families:,${analysisResults.evenGaps.length}\n`;
            csv += `log(zeta(2)):,${Math.log(analysisResults.targetZeta2).toFixed(precision)}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Log(P_g),P_g,Prime Count,Average Log per Prime,Log Density\n';
            
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const avgLogPerPrime = data.logProduct / data.count;
                const logDensity = data.logProduct / gap;
                
                csv += `${gap},${data.logProduct.toFixed(precision)},${data.product.toFixed(precision)},`;
                csv += `${data.count},${avgLogPerPrime.toFixed(precision)},${logDensity.toFixed(precision)}\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateStepByStepCSV() {
            const precision = parseInt(document.getElementById('stepByStepPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Step-by-Step Accumulation Process\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset provides a sequential view of how the gap-class decomposition\n';
            csv += 'builds toward pi^2/6. Each row shows the addition of one gap family to the\n';
            csv += 'cumulative product, demonstrating the geometric convergence process step by step.\n';
            csv += 'The formula column explicitly shows which gap families have been multiplied together.\n\n';
            
            csv += 'INTERPRETATION GUIDE:\n';
            csv += '- Step: Sequential order of gap family addition\n';
            csv += '- Gap Added: The gap g being incorporated in this step\n';
            csv += '- P_g: The product value for this specific gap family\n';
            csv += '- Formula: Explicit product notation (P_1 × P_2 × P_4 × ...)\n';
            csv += '- Cumulative Product: Running product after this step\n';
            csv += '- Distance to pi^2/6: How far from target value\n';
            csv += '- Percent Complete: (Cumulative / pi^2/6) × 100\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Target zeta(2):,${analysisResults.targetZeta2}\n`;
            csv += `Total Gap Families:,${analysisResults.evenGaps.length}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Step,Gap Added,P_g,Formula,Cumulative Product,Distance to pi^2/6,Percent Complete\n';
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            gaps.forEach((gap, idx) => {
                const data = analysisResults.gapProducts[gap];
                const cumulative = analysisResults.progressiveProducts[idx].value;
                const distance = analysisResults.targetZeta2 - cumulative;
                const percentComplete = (cumulative / analysisResults.targetZeta2) * 100;
                
                let formula = 'P_1';
                for (let i = 1; i <= idx; i++) {
                    formula += ` × P_${gaps[i]}`;
                }
                
                csv += `${idx + 1},${gap},${data.product.toFixed(precision)},"${formula}",`;
                csv += `${cumulative.toFixed(precision)},${distance.toFixed(precision)},`;
                csv += `${percentComplete.toFixed(precision)}%\n`;
            });
            
            csv += `\nFINAL TARGET,∞,1.0,"zeta(2) = pi^2/6",${analysisResults.targetZeta2.toFixed(precision)},0.0,100.0%\n`;
            
            csv += '\n=================================================\n';
            csv += 'RESEARCH NOTES:\n';
            csv += 'This decomposition provides a novel perspective on the Basel problem.\n';
            csv += 'By organizing the Euler product by prime gaps rather than sequential primes,\n';
            csv += 'we reveal connections between prime constellation distributions and the\n';
            csv += 'fundamental constant pi. The rapid convergence suggests each gap family P_g\n';
            csv += 'may admit closed-form expressions in terms of pi and gap parameters.\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function exportStepByStepTablePNG() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const precision = parseInt(document.getElementById('stepByStepPrecision').value);
            
            // Get row count from global export setting (fallback to screenshot setting, then 15)
            const globalRows = document.getElementById('globalExportRows')?.value;
            const screenshotRows = document.getElementById('screenshotTableRows')?.value;
            const rowCountSetting = globalRows || screenshotRows || '15';
            
            const maxRows = rowCountSetting === 'all' ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate dimensions
            const headerH = 200;
            const tableHeaderH = 80;
            const rowH = 60;
            const footerH = 100;
            const padding = 40;
            
            const canvasW = 3840;
            const canvasH = headerH + tableHeaderH + (gaps.length + 1) * rowH + footerH;
            
            canvas.width = canvasW;
            canvas.height = canvasH;
            
            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvasW, canvasH);
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 64px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Step-by-Step Gap Accumulation: ζ(2) = P₁ × P₂ × P₄ × ...', canvasW / 2, 80);
            
            ctx.fillStyle = '#888';
            ctx.font = '32px monospace';
            ctx.fillText(`Analysis: ${analysisResults.totalPrimes.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, canvasW / 2, 140);
            
            // Table headers
            const tableY = headerH + padding;
            const headers = ['Step', 'Gap', 'P_g', 'Cumulative Product', 'Distance to π²/6', '% Complete'];
            const colWidths = [0.08, 0.08, 0.18, 0.24, 0.22, 0.20];
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(padding, tableY, canvasW - 2 * padding, tableHeaderH);
            
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.strokeRect(padding, tableY, canvasW - 2 * padding, tableHeaderH);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            
            let xPos = padding;
            headers.forEach((header, idx) => {
                const w = (canvasW - 2 * padding) * colWidths[idx];
                ctx.fillText(header, xPos + w / 2, tableY + 50);
                xPos += w;
            });
            
            // Table rows
            ctx.font = '32px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = tableY + tableHeaderH + rowIdx * rowH;
                const data = analysisResults.gapProducts[gap];
                const cumulative = analysisResults.progressiveProducts[rowIdx].value;
                const distance = analysisResults.targetZeta2 - cumulative;
                const percentComplete = (cumulative / analysisResults.targetZeta2) * 100;
                
                // Alternating row background
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(padding, y, canvasW - 2 * padding, rowH);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const rowData = [
                    (rowIdx + 1).toString(),
                    gap.toString(),
                    data.product.toFixed(precision),
                    cumulative.toFixed(precision),
                    distance.toFixed(precision),
                    percentComplete.toFixed(precision) + '%'
                ];
                
                xPos = padding;
                rowData.forEach((cell, colIdx) => {
                    const w = (canvasW - 2 * padding) * colWidths[colIdx];
                    ctx.fillText(cell, xPos + w / 2, y + 42);
                    xPos += w;
                });
            });
            
            // Target row
            const targetY = tableY + tableHeaderH + gaps.length * rowH;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(padding, targetY, canvasW - 2 * padding, rowH);
            
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.strokeRect(padding, targetY, canvasW - 2 * padding, rowH);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 36px monospace';
            
            const targetData = [
                'Target',
                '∞',
                '1.0',
                analysisResults.targetZeta2.toFixed(precision),
                '0.' + '0'.repeat(precision),
                '100.' + '0'.repeat(precision) + '%'
            ];
            
            xPos = padding;
            targetData.forEach((cell, colIdx) => {
                const w = (canvasW - 2 * padding) * colWidths[colIdx];
                ctx.fillText(cell, xPos + w / 2, targetY + 42);
                xPos += w;
            });
            
            // Footer
            ctx.fillStyle = '#666';
            ctx.font = '28px monospace';
            ctx.textAlign = 'right';
            const dateStr = new Date().toLocaleDateString('en-GB', { 
                day: '2-digit', 
                month: 'long', 
                year: 'numeric' 
            });
            ctx.fillText(dateStr, canvasW - padding, canvasH - 40);
            
            // Export
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const link = document.createElement('a');
            link.download = `step_by_step_table_${analysisResults.maxPrime}_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        // Composite screenshot generation
        function generateCompositeScreenshot() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const statusBar = document.getElementById('screenshotStatus');
            statusBar.style.display = 'block';
            statusBar.className = 'status-bar computing';
            statusBar.textContent = 'Generating composite screenshot...';
            
            setTimeout(() => {
                try {
                    // Collect selected charts
                    const chartSelections = {
                        convergence: document.getElementById('screenshotConvergence').checked,
                        gapContrib: document.getElementById('screenshotGapContrib').checked,
                        gapDist: document.getElementById('screenshotGapDist').checked,
                        percentage: document.getElementById('screenshotPercentage').checked,
                        error: document.getElementById('screenshotError').checked,
                        logScale: document.getElementById('screenshotLogScale').checked
                    };
                    
                    const selectedCharts = [];
                    const chartCanvasIds = {
                        convergence: 'convergenceChart',
                        gapContrib: 'gapContribChart',
                        gapDist: 'gapDistChart',
                        percentage: 'percentageChart',
                        error: 'errorChart',
                        logScale: 'logScaleChart'
                    };
                    
                    Object.keys(chartSelections).forEach(key => {
                        if (chartSelections[key]) {
                            selectedCharts.push({
                                name: key,
                                canvasId: chartCanvasIds[key]
                            });
                        }
                    });
                    
                    if (selectedCharts.length === 0) {
                        statusBar.className = 'status-bar';
                        statusBar.style.color = '#ff6464';
                        statusBar.textContent = 'Please select at least one chart';
                        return;
                    }
                    
                    const baseRes = parseInt(document.getElementById('screenshotResolution').value);
                    const scale = baseRes / 1920;
                    
                    const layout = document.getElementById('screenshotLayout').value;
                    const title = document.getElementById('screenshotTitle').value;
                    const subtitle = document.getElementById('screenshotSubtitle').value;
                    
                    // Calculate dimensions
                    let cols, rows;
                    if (layout === 'grid') {
                        cols = 2;
                        rows = Math.ceil(selectedCharts.length / 2);
                    } else if (layout === 'vertical') {
                        cols = 1;
                        rows = selectedCharts.length;
                    } else { // horizontal
                        cols = Math.min(3, selectedCharts.length);
                        rows = Math.ceil(selectedCharts.length / cols);
                    }
                    
                    const chartW = 1920 * scale;
                    const chartH = 1080 * scale;
                    const headerH = 250 * scale;
                    // Adjust footer based on number of charts - less space for single chart
                    const footerH = selectedCharts.length === 1 ? 400 * scale : 600 * scale;
                    const padding = 40 * scale;
                    const statsH = 100 * scale;
                    
                    const canvasW = cols * chartW + (cols + 1) * padding;
                    const canvasH = headerH + statsH + rows * chartH + (rows + 1) * padding + footerH;
                    
                    const canvas = document.getElementById('compositeCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = canvasW;
                    canvas.height = canvasH;
                    
                    // Background
                    ctx.fillStyle = '#0a0a0f';
                    ctx.fillRect(0, 0, canvasW, canvasH);
                    
                    // Header section
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${72 * scale}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(title, canvasW / 2, 80 * scale);
                    
                    ctx.fillStyle = '#aaa';
                    ctx.font = `${36 * scale}px sans-serif`;
                    ctx.fillText(subtitle, canvasW / 2, 140 * scale);
                    
                    // Stats summary bar
                    const statsY = headerH + 20 * scale;
                    ctx.fillStyle = '#1a1a2a';
                    ctx.fillRect(padding, statsY, canvasW - 2 * padding, statsH - 40 * scale);
                    
                    ctx.strokeStyle = '#3a3a5a';
                    ctx.lineWidth = 2 * scale;
                    ctx.strokeRect(padding, statsY, canvasW - 2 * padding, statsH - 40 * scale);
                    
                    const statsText = `${analysisResults.totalPrimes.toLocaleString()} primes analyzed | Maximum: ${analysisResults.maxPrime.toLocaleString()} | ${analysisResults.evenGaps.length} gap families | Final error: ${(analysisResults.finalRelativeError * 100).toFixed(8)}%`;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `${28 * scale}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText(statsText, canvasW / 2, statsY + (statsH - 40 * scale) / 2 + 10 * scale);
                    
                    // Draw charts
                    selectedCharts.forEach((chart, idx) => {
                        const row = Math.floor(idx / cols);
                        const col = idx % cols;
                        
                        const x = col * chartW + (col + 1) * padding;
                        const y = headerH + statsH + row * chartH + (row + 1) * padding;
                        
                        const sourceCanvas = document.getElementById(chart.canvasId);
                        
                        // Draw border
                        ctx.strokeStyle = '#2a2a4a';
                        ctx.lineWidth = 3 * scale;
                        ctx.strokeRect(x - 2 * scale, y - 2 * scale, chartW + 4 * scale, chartH + 4 * scale);
                        
                        // Draw chart
                        ctx.drawImage(sourceCanvas, x, y, chartW, chartH);
                    });
                    
                    // Footer narrative section
                    const footerY = headerH + statsH + rows * chartH + (rows + 1) * padding + 40 * scale;
                    
                    ctx.fillStyle = '#12121a';
                    ctx.fillRect(padding, footerY, canvasW - 2 * padding, footerH - 80 * scale);
                    
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 4 * scale;
                    ctx.strokeRect(padding, footerY, canvasW - 2 * padding, footerH - 80 * scale);
                    
                    // Narrative title
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${38 * scale}px serif`;
                    ctx.textAlign = 'left';
                    ctx.fillText('Mathematical Observations', padding + 30 * scale, footerY + 50 * scale);
                    
                    // Generate and render narrative
                    const narrative = generateRamanujanNarrative();
                    ctx.fillStyle = '#e0e0e0';
                    // Smaller font for single chart to fit better
                    const fontSize = selectedCharts.length === 1 ? 22 : 26;
                    ctx.font = `${fontSize * scale}px Georgia, serif`;
                    
                    const maxLineWidth = canvasW - 2 * padding - 60 * scale;
                    const lineHeight = (fontSize + 12) * scale;
                    let currentY = footerY + 100 * scale;
                    
                    const paragraphs = narrative.split('\n\n');
                    paragraphs.forEach(para => {
                        const words = para.split(' ');
                        let line = '';
                        
                        for (let i = 0; i < words.length; i++) {
                            const testLine = line + words[i] + ' ';
                            const metrics = ctx.measureText(testLine);
                            
                            if (metrics.width > maxLineWidth && line !== '') {
                                ctx.fillText(line.trim(), padding + 30 * scale, currentY);
                                currentY += lineHeight;
                                line = words[i] + ' ';
                            } else {
                                line = testLine;
                            }
                        }
                        
                        if (line.trim() !== '') {
                            ctx.fillText(line.trim(), padding + 30 * scale, currentY);
                            currentY += lineHeight;
                        }
                        currentY += lineHeight * 0.3;
                    });
                    
                    // Date stamp
                    ctx.fillStyle = '#666';
                    ctx.font = `${22 * scale}px monospace`;
                    ctx.textAlign = 'right';
                    const dateStr = new Date().toLocaleDateString('en-GB', { 
                        day: '2-digit', 
                        month: 'long', 
                        year: 'numeric' 
                    });
                    ctx.fillText(dateStr, canvasW - padding - 30 * scale, canvasH - 30 * scale);
                    
                    // Export
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const resLabel = baseRes >= 3840 ? (baseRes >= 7680 ? '8K' : '4K') : (baseRes >= 2560 ? 'QHD' : 'HD');
                    const link = document.createElement('a');
                    link.download = `gap_decomposition_composite_${analysisResults.maxPrime}_${resLabel}_${timestamp}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    
                    statusBar.className = 'status-bar complete';
                    statusBar.textContent = `Composite screenshot generated: ${selectedCharts.length} charts, ${resLabel} resolution`;
                    
                } catch (error) {
                    statusBar.className = 'status-bar';
                    statusBar.style.color = '#ff6464';
                    statusBar.textContent = `Error: ${error.message}`;
                    console.error(error);
                }
            }, 100);
        }
        
        function generateRamanujanNarrative() {
            const r = analysisResults;
            
            // Extract key numerical insights
            const twinCount = r.gapProducts[2] ? r.gapProducts[2].count : 0;
            const twinPct = r.percentageContributions[2] ? r.percentageContributions[2].toFixed(3) : 0;
            
            const gap4Count = r.gapProducts[4] ? r.gapProducts[4].count : 0;
            const gap4Pct = r.percentageContributions[4] ? r.percentageContributions[4].toFixed(3) : 0;
            
            const gap6Count = r.gapProducts[6] ? r.gapProducts[6].count : 0;
            const gap6Pct = r.percentageContributions[6] ? r.percentageContributions[6].toFixed(3) : 0;
            
            const errorExp = Math.floor(Math.log10(r.finalRelativeError));
            const errorMantissa = (r.finalRelativeError / Math.pow(10, errorExp)).toFixed(2);
            
            // Random variation selector - always Euler style
            const variation = Math.floor(Math.random() * 5);
            
            const eulerVariations = [
                `Concerning the partition of ζ(2) by prime gaps: among ${r.totalPrimes.toLocaleString()} primes, the ${twinCount} twin pairs contribute ${twinPct}% logarithmically. With ${r.evenGaps.length} gap families, we achieve ${errorMantissa} × 10^${errorExp} precision relative to π²/6. The geometric rapidity of convergence suggests π emerges from prime gap arithmetic itself.`,
                
                `The decomposition ∏P_g reveals that ${twinCount} twin primes provide ${twinPct}% of log(ζ(2)). Partitioning ${r.totalPrimes.toLocaleString()} primes across ${r.evenGaps.length} gap classes yields error ${errorMantissa} × 10^${errorExp}. This elegant structure connects circular geometry to prime distribution.`,
                
                `By gap-class partition, ζ(2) = ∏P_g exhibits rapid convergence. The ${twinCount} twins contribute ${twinPct}%, while ${r.evenGaps.length} families suffice for ${errorMantissa} × 10^${errorExp} precision. A remarkable bridge between discrete gaps and π²/6.`,
                
                `The ${r.evenGaps.length} gap families demonstrate hierarchical contribution: twins (${twinCount} pairs) at ${twinPct}%, cousins (${gap4Count} pairs) at ${gap4Pct}%, sexy primes (${gap6Count} pairs) at ${gap6Pct}%. Convergence to π²/6 proceeds with error ${errorMantissa} × 10^${errorExp}, revealing π's arithmetic foundation.`,
                
                `Among ${r.totalPrimes.toLocaleString()} primes examined, the gap decomposition yields ${r.evenGaps.length} distinct families. Twin primes alone account for ${twinPct}% of the logarithmic sum. The finite product approximates π²/6 with merely ${errorMantissa} × 10^${errorExp} relative deviation, a testament to the profound regularity underlying prime distribution.`
            ];
            
            return eulerVariations[variation];
        }
        
        // Initialize
        updateDisplays();

        // ========== ZETA(S) GENERALIZATION ==========
        
        function getKnownZetaValue(s) {
            const knownValues = {
                2: { value: Math.PI**2 / 6, formula: "π²/6" },
                4: { value: Math.PI**4 / 90, formula: "π⁴/90" },
                6: { value: Math.PI**6 / 945, formula: "π⁶/945" },
                8: { value: Math.PI**8 / 9450, formula: "π⁸/9450" },
                10: { value: Math.PI**10 / 93555, formula: "π¹⁰/93555" }
            };
            return knownValues[s] || null;
        }
        
        function setZetaS(value) {
            document.getElementById('zetaS').value = value;
            updateZetaSDisplay();
        }
        
        function updateZetaSDisplay() {
            const s = parseFloat(document.getElementById('zetaS').value);
            document.getElementById('zetaSDisplay').textContent = s.toFixed(2);
            
            const known = getKnownZetaValue(s);
            const infoDiv = document.getElementById('zetaSInfo');
            const behaviorDiv = document.getElementById('zetaSBehavior');
            
            if (known) {
                infoDiv.innerHTML = `<strong>ζ(${s}) = ${known.formula} ≈ ${known.value.toFixed(6)}</strong>`;
            } else {
                const approx = computeApproximateZeta(s);
                infoDiv.innerHTML = `ζ(${s.toFixed(2)}) ≈ ${approx.toFixed(6)}`;
            }
            
            // Update behavioral description
            if (s < 1.3) {
                behaviorDiv.textContent = 'Approaches divergence - all gaps contribute equally';
            } else if (s < 1.8) {
                behaviorDiv.textContent = 'Gap 1 and Gap 2 nearly balanced (~45% vs 39%)';
            } else if (s < 2.5) {
                behaviorDiv.textContent = 'Twin primes (Gap 2) dominate - optimal for twin prime research';
            } else if (s < 3.5) {
                behaviorDiv.textContent = 'Gap 1 begins to dominate - twin prime influence fading';
            } else if (s < 5) {
                behaviorDiv.textContent = 'Gap 1 strongly dominant (~80%) - small primes control ζ(s)';
            } else {
                behaviorDiv.textContent = 'Gap 1 nearly total dominance (>90%) - prime 2 dominates everything';
            }
        }
        
        function computeApproximateZeta(s) {
            // Quick approximation using first 1000 terms
            let sum = 0;
            for (let n = 1; n <= 1000; n++) {
                sum += 1 / Math.pow(n, s);
            }
            return sum;
        }
        
        function computeGapDecompositionWithS(maxPrime, maxGap, s) {
            const primes = sievePrimes(maxPrime);
            
            // Get target value
            const known = getKnownZetaValue(s);
            const targetZeta = known ? known.value : computeApproximateZeta(s);
            
            // Calculate gaps and classify primes
            const gapFamilies = {}; // Will be populated by loop - gap 1 gets prime 2 from 3-2=1
            const gaps = [];
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i + 1] - primes[i];
                gaps.push(gap);
                
                if (!gapFamilies[gap]) {
                    gapFamilies[gap] = [];
                }
                gapFamilies[gap].push(primes[i]);
            }
            
            // Calculate products for each gap family using p^s/(p^s-1)
            const gapProducts = {};
            const evenGaps = [1];
            
            for (let g = 2; g <= maxGap; g += 2) {
                if (gapFamilies[g] && gapFamilies[g].length > 0) {
                    evenGaps.push(g);
                }
            }
            
            evenGaps.forEach(gap => {
                if (gapFamilies[gap] && gapFamilies[gap].length > 0) {
                    let product = 1;
                    let logProduct = 0;
                    
                    gapFamilies[gap].forEach(p => {
                        const ps = Math.pow(p, s);
                        const factor = ps / (ps - 1);
                        product *= factor;
                        logProduct += Math.log(factor);
                    });
                    
                    gapProducts[gap] = {
                        product: product,
                        logProduct: logProduct,
                        count: gapFamilies[gap].length,
                        primes: gapFamilies[gap].slice(0, 100)
                    };
                }
            });
            
            // Add last prime contribution
            const lastPrime = primes[primes.length - 1];
            const lastPs = Math.pow(lastPrime, s);
            const lastFactor = lastPs / (lastPs - 1);
            
            // Calculate progressive convergence
            const progressiveProducts = [];
            let cumulative = 1;
            let cumulativeLog = 0;
            
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    cumulative *= gapProducts[gap].product;
                    cumulativeLog += gapProducts[gap].logProduct;
                    
                    progressiveProducts.push({
                        gap: gap,
                        value: cumulative,
                        logValue: cumulativeLog,
                        error: Math.abs(cumulative - targetZeta),
                        relativeError: Math.abs(cumulative - targetZeta) / targetZeta
                    });
                }
            });
            
            // Multiply by last prime
            cumulative *= lastFactor;
            const finalProduct = cumulative;
            const finalError = Math.abs(finalProduct - targetZeta);
            
            // Calculate percentage contributions
            const totalLogProduct = cumulativeLog + Math.log(lastFactor);
            const percentageContributions = {};
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    const contribution = gapProducts[gap].logProduct / totalLogProduct;
                    percentageContributions[gap] = contribution * 100;
                }
            });
            
            return {
                s: s,
                primes: primes,
                totalPrimes: primes.length,
                maxPrime: maxPrime,
                targetZeta: targetZeta,
                targetZeta2: targetZeta, // Keep for compatibility
                gapFamilies: gapFamilies,
                evenGaps: evenGaps,
                gapProducts: gapProducts,
                progressiveProducts: progressiveProducts,
                percentageContributions: percentageContributions,
                finalProduct: finalProduct,
                finalError: finalError,
                finalRelativeError: finalError / targetZeta
            };
        }
        
        function computeComparisonData() {
            const maxPrime = parseInt(document.getElementById('maxPrime').value);
            const maxGap = parseInt(document.getElementById('maxGap').value);
            const sValues = [1.5, 2, 3, 4, 5, 10];
            
            const comparisonResults = {};
            
            sValues.forEach(s => {
                comparisonResults[s] = computeGapDecompositionWithS(maxPrime, maxGap, s);
            });
            
            return comparisonResults;
        }
        
        function renderComparisonChart() {
            const canvas = document.createElement('canvas');
            canvas.width = 3840;
            canvas.height = 2400;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, 3840, 2400);
            
            const compData = computeComparisonData();
            const sValues = [1.5, 2, 3, 4, 5, 10];
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 72px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Contribution Evolution Across ζ(s)', 1920, 100);
            
            // Draw comparison bars
            const margin = {left: 250, right: 100, top: 200, bottom: 150};
            const chartW = 3840 - margin.left - margin.right;
            const chartH = 2400 - margin.top - margin.bottom;
            
            const barWidth = chartW / (sValues.length * 5); // 5 gaps shown
            
            sValues.forEach((s, sIdx) => {
                const data = compData[s];
                const topGaps = [1, 2, 4, 6, 8].filter(g => data.percentageContributions[g]);
                
                topGaps.forEach((gap, gapIdx) => {
                    const pct = data.percentageContributions[gap] || 0;
                    const x = margin.left + (sIdx * 5 + gapIdx) * barWidth;
                    const barH = (pct / 100) * chartH;
                    const y = margin.top + chartH - barH;
                    
                    const colors = ['#ff4444', '#ffd700', '#4ecdc4', '#8b5cf6', '#06b6d4'];
                    ctx.fillStyle = colors[gapIdx];
                    ctx.fillRect(x, y, barWidth * 0.8, barH);
                });
                
                // Label s value
                ctx.fillStyle = '#aaa';
                ctx.font = 'bold 32px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`s=${s}`, margin.left + (sIdx * 5 + 2) * barWidth, 2400 - 50);
            });
            
            // Legend
            const legendX = margin.left;
            const legendY = 150;
            const gapLabels = ['Gap 1', 'Gap 2', 'Gap 4', 'Gap 6', 'Gap 8'];
            const colors = ['#ff4444', '#ffd700', '#4ecdc4', '#8b5cf6', '#06b6d4'];
            
            gapLabels.forEach((label, i) => {
                ctx.fillStyle = colors[i];
                ctx.fillRect(legendX + i * 180, legendY, 40, 40);
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 28px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(label, legendX + i * 180 + 50, legendY + 30);
            });
            
            return canvas;
        }
        function applyResearchPreset(preset) {
            const presets = {
                'twins': { maxPrime: 100000, maxGap: 10, gapFilter: true, minGap: 2, maxGapFilter: 10, desc: 'Twin Prime Focus' },
                'goldbach': { maxPrime: 500000, maxGap: 30, gapFilter: false, minGap: 2, maxGapFilter: 30, desc: 'Goldbach Range' },
                'topology': { maxPrime: 1000000, maxGap: 150, gapFilter: true, minGap: 30, maxGapFilter: 90, desc: 'Large Gap Topology' },
                'extreme': { maxPrime: 5000000, maxGap: 500, gapFilter: true, minGap: 100, maxGapFilter: 500, desc: 'Extreme Range' },
                'full': { maxPrime: 1000000, maxGap: 200, gapFilter: false, minGap: 2, maxGapFilter: 200, desc: 'Full Spectrum' },
                'rh': { maxPrime: 2000000, maxGap: 50, gapFilter: false, minGap: 2, maxGapFilter: 50, desc: 'RH Investigation' }
            };
            const config = presets[preset];
            if (!config) return;
            document.getElementById('maxPrime').value = config.maxPrime;
            document.getElementById('maxGap').value = config.maxGap;
            document.getElementById('enableGapFilter').checked = config.gapFilter;
            document.getElementById('minGapFilter').value = config.minGap;
            document.getElementById('maxGapFilter').value = config.maxGapFilter;
            toggleGapFilter();
            const statusBar = document.getElementById('statusBar');
            statusBar.style.display = 'block';
            statusBar.style.background = 'rgba(34, 197, 94, 0.2)';
            statusBar.style.borderLeft = '4px solid #22c55e';
            statusBar.textContent = 'Applied preset: ' + config.desc + '. Click "Run Analysis" to compute.';
            setTimeout(() => statusBar.style.display = 'none', 4000);
        }


        // TAB SWITCHING
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById('tab-' + tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // PRIME DENSITY ANALYSIS
        let densityData = null;
        
        function computeDensity() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            const maxPrime = primes[primes.length - 1];
            const intervalSize = Math.max(1000, Math.floor(maxPrime / 20));
            
            densityData = [];
            let intervalStart = 2;
            
            while (intervalStart < maxPrime) {
                const intervalEnd = Math.min(intervalStart + intervalSize, maxPrime);
                const primesInInterval = primes.filter(p => p >= intervalStart && p < intervalEnd).length;
                const density = primesInInterval / intervalSize;
                const midpoint = (intervalStart + intervalEnd) / 2;
                const predicted = 1 / Math.log(midpoint);
                
                densityData.push({
                    start: intervalStart,
                    end: intervalEnd,
                    count: primesInInterval,
                    density: density.toFixed(6),
                    predicted: predicted.toFixed(6)
                });
                
                intervalStart = intervalEnd;
            }
            
            document.getElementById('densityStatus').style.display = 'block';
            document.getElementById('densityStatus').innerHTML = `
                <strong>Prime Density Analysis Complete</strong><br>
                Analyzed ${densityData.length} intervals of size ~${intervalSize.toLocaleString()}<br>
                Max prime: ${maxPrime.toLocaleString()}
            `;
            
            renderDensityTable();
            renderDensityChart();
        }

        function renderDensityTable() {
            const tbody = document.getElementById('densityTableBody');
            tbody.innerHTML = '';
            
            densityData.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = item.start.toLocaleString();
                row.insertCell(1).textContent = item.end.toLocaleString();
                row.insertCell(2).textContent = item.count;
                row.insertCell(3).textContent = item.density;
                row.insertCell(4).textContent = item.predicted;
            });
        }

        function renderDensityChart() {
            const canvas = document.getElementById('densityChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 250, right: 150, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const densities = densityData.map(d => parseFloat(d.density));
            const maxDensity = Math.max(...densities);
            
            const xScale = chartW / densityData.length;
            const yScale = chartH / maxDensity;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
            }
            
            // Bars
            densityData.forEach((item, i) => {
                const barH = parseFloat(item.density) * yScale;
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barH);
                gradient.addColorStop(0, '#ffd700');
                gradient.addColorStop(1, '#ff8800');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + xScale * 0.1, y, xScale * 0.8, barH);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Density by Interval', w / 2, 120);
            
            // Y-axis label
            ctx.save();
            ctx.translate(100, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Density (primes per unit)', 0, 0);
            ctx.restore();
            
            // X-axis label
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Interval Number', w / 2, h - 80);
        }

        function copyDensityList() {
            const text = densityData.map(d => `[${d.start}-${d.end}]: ${d.count} primes, density ${d.density}`).join('\n');
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportDensityCSV() {
            let csv = 'Range Start,Range End,Prime Count,Actual Density,Predicted Density\n';
            densityData.forEach(item => {
                csv += `${item.start},${item.end},${item.count},${item.density},${item.predicted}\n`;
            });
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'prime_density.csv';
            a.click();
        }

        // TWIN PRIMES
        let twinsData = null;
        
        function computeTwinPrimes() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            twinsData = [];
            
            for (let i = 0; i < primes.length - 1; i++) {
                if (primes[i+1] - primes[i] === 2) {
                    const gapBefore = i > 0 ? primes[i] - primes[i-1] : 0;
                    const gapAfter = i < primes.length - 2 ? primes[i+2] - primes[i+1] : 0;
                    twinsData.push({
                        p: primes[i],
                        q: primes[i+1],
                        gapBefore,
                        gapAfter
                    });
                }
            }
            
            document.getElementById('twinsStatus').style.display = 'block';
            document.getElementById('twinsStatus').innerHTML = `
                <strong>Twin Prime Search Complete</strong><br>
                Found ${twinsData.length} twin prime pairs<br>
                Largest pair: (${twinsData[twinsData.length-1].p}, ${twinsData[twinsData.length-1].q})
            `;
            
            renderTwinsTable();
            renderTwinsChart();
        }

        function renderTwinsTable() {
            const tbody = document.getElementById('twinsTableBody');
            tbody.innerHTML = '';
            
            twinsData.forEach((item, idx) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = idx + 1;
                row.insertCell(1).textContent = `(${item.p}, ${item.q})`;
                row.insertCell(2).textContent = item.gapBefore || 'N/A';
                row.insertCell(3).textContent = item.gapAfter || 'N/A';
            });
        }

        function renderTwinsChart() {
            const canvas = document.getElementById('twinsChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 250, right: 150, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Sample every Nth twin to avoid overcrowding
            const sampleRate = Math.max(1, Math.floor(twinsData.length / 100));
            const sampledTwins = twinsData.filter((_, i) => i % sampleRate === 0);
            
            const xScale = chartW / sampledTwins.length;
            const maxP = twinsData[twinsData.length - 1].p;
            const yScale = chartH / maxP;
            
            // Plot twin primes
            ctx.fillStyle = '#ffd700';
            sampledTwins.forEach((twin, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - (twin.p * yScale);
                ctx.fillRect(x, y, xScale * 0.6, 10);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Twin Primes Distribution (${twinsData.length} pairs)`, w/2, 120);
            
            ctx.font = 'bold 50px sans-serif';
            ctx.fillText(`Sampled every ${sampleRate} pairs for visualization`, w/2, h - 80);
        }

        function copyTwinsList() {
            const text = twinsData.map(d => `(${d.p}, ${d.q})`).join('\n');
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportTwinsCSV() {
            let csv = 'Index,Prime 1,Prime 2,Gap Before,Gap After\n';
            twinsData.forEach((item, idx) => {
                csv += `${idx+1},${item.p},${item.q},${item.gapBefore},${item.gapAfter}\n`;
            });
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'twin_primes.csv';
            a.click();
        }

        // PRIME GAPS
        let gapsStatsData = null;
        
        function computeGapStats() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            const gapCounts = {};
            const firstOccurrence = {};
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i+1] - primes[i];
                gapCounts[gap] = (gapCounts[gap] || 0) + 1;
                if (!firstOccurrence[gap]) {
                    firstOccurrence[gap] = `${primes[i]} → ${primes[i+1]}`;
                }
            }
            
            const totalGaps = primes.length - 1;
            gapsStatsData = Object.entries(gapCounts).map(([gap, count]) => ({
                gap: parseInt(gap),
                count,
                percentage: (count / totalGaps * 100).toFixed(2),
                first: firstOccurrence[gap]
            })).sort((a, b) => a.gap - b.gap);
            
            const mostCommon = gapsStatsData.reduce((a,b) => a.count > b.count ? a : b);
            
            document.getElementById('gapsStatus').style.display = 'block';
            document.getElementById('gapsStatus').innerHTML = `
                <strong>Gap Analysis Complete</strong><br>
                Found ${gapsStatsData.length} different gap sizes<br>
                Most common: gap ${mostCommon.gap} (${mostCommon.count} occurrences, ${mostCommon.percentage}%)
            `;
            
            renderGapsTable();
            renderGapsChart();
        }

        function renderGapsTable() {
            const tbody = document.getElementById('gapsTableBody');
            tbody.innerHTML = '';
            
            gapsStatsData.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = item.gap;
                row.insertCell(1).textContent = item.count;
                row.insertCell(2).textContent = item.percentage + '%';
                row.insertCell(3).textContent = item.first;
            });
        }

        function renderGapsChart() {
            const canvas = document.getElementById('gapsChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 250, right: 150, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Show top 50 most frequent gaps
            const topGaps = [...gapsStatsData].sort((a,b) => b.count - a.count).slice(0, 50);
            
            const xScale = chartW / topGaps.length;
            const maxCount = Math.max(...topGaps.map(g => g.count));
            const yScale = chartH / maxCount;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
            }
            
            // Bars
            topGaps.forEach((item, i) => {
                const barH = item.count * yScale;
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barH);
                gradient.addColorStop(0, '#4ecdc4');
                gradient.addColorStop(1, '#2a7a73');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + xScale * 0.1, y, xScale * 0.8, barH);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Gap Frequency Distribution (Top 50)', w / 2, 120);
            
            ctx.save();
            ctx.translate(100, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Frequency', 0, 0);
            ctx.restore();
        }

        function copyGapsList() {
            const text = gapsStatsData.map(d => `Gap ${d.gap}: ${d.count} (${d.percentage}%)`).join('\n');
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportGapsCSV() {
            let csv = 'Gap Size,Frequency,Percentage,First Occurrence\n';
            gapsStatsData.forEach(item => {
                csv += `${item.gap},${item.count},${item.percentage},${item.first}\n`;
            });
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gap_statistics.csv';
            a.click();
        }

        // PRIME CONSTELLATIONS
        let constellationsData = null;
        
        function computeConstellations() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            const primeSet = new Set(primes);
            
            constellationsData = {
                twins: [],
                cousins: [],
                sexy: [],
                triplets: [],
                quadruplets: []
            };
            
            primes.forEach(p => {
                if (primeSet.has(p+2)) constellationsData.twins.push([p, p+2]);
                if (primeSet.has(p+4)) constellationsData.cousins.push([p, p+4]);
                if (primeSet.has(p+6)) constellationsData.sexy.push([p, p+6]);
                if (primeSet.has(p+2) && primeSet.has(p+6)) constellationsData.triplets.push([p, p+2, p+6]);
                if (primeSet.has(p+2) && primeSet.has(p+6) && primeSet.has(p+8)) constellationsData.quadruplets.push([p, p+2, p+6, p+8]);
            });
            
            document.getElementById('constellationsStatus').style.display = 'block';
            document.getElementById('constellationsStatus').innerHTML = `
                <strong>Constellation Search Complete</strong><br>
                Twins: ${constellationsData.twins.length} | Cousins: ${constellationsData.cousins.length} | Sexy: ${constellationsData.sexy.length}<br>
                Triplets: ${constellationsData.triplets.length} | Quadruplets: ${constellationsData.quadruplets.length}
            `;
            
            renderConstellationsTable();
            renderConstellationsChart();
        }

        function renderConstellationsTable() {
            const tbody = document.getElementById('constellationsTableBody');
            tbody.innerHTML = '';
            
            Object.entries(constellationsData).forEach(([type, items]) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = type.charAt(0).toUpperCase() + type.slice(1);
                row.insertCell(1).textContent = items.length;
                const examples = items.slice(0, 5).map(p => '(' + p.join(',') + ')').join(' ');
                row.insertCell(2).textContent = examples;
            });
        }

        function renderConstellationsChart() {
            const canvas = document.getElementById('constellationsChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 300, right: 150, top: 200, bottom: 250};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const types = Object.entries(constellationsData);
            const counts = types.map(([_, items]) => items.length);
            const maxCount = Math.max(...counts);
            
            const barWidth = chartW / types.length;
            const yScale = chartH / maxCount;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxCount - (maxCount * (i / 10));
                ctx.fillStyle = '#888';
                ctx.font = 'bold 40px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(Math.floor(value).toLocaleString(), margin.left - 30, y + 15);
            }
            
            // Bars
            const colors = ['#ffd700', '#ff8800', '#ff4444', '#8b5cf6', '#06b6d4'];
            types.forEach(([name, items], i) => {
                const barH = items.length * yScale;
                const x = margin.left + i * barWidth;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barH);
                gradient.addColorStop(0, colors[i]);
                gradient.addColorStop(1, colors[i] + '88');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                // Labels
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 50px sans-serif';
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(x + barWidth / 2, h - margin.bottom + 80);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(name.charAt(0).toUpperCase() + name.slice(1), 0, 0);
                ctx.restore();
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Constellation Counts', w / 2, 120);
            
            ctx.save();
            ctx.translate(100, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Count', 0, 0);
            ctx.restore();
        }

        function copyConstellationsList() {
            let text = '';
            Object.entries(constellationsData).forEach(([type, items]) => {
                text += `${type}: ${items.length}\n`;
            });
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportConstellationsCSV() {
            let csv = 'Type,Count,Examples (first 10)\n';
            Object.entries(constellationsData).forEach(([type, items]) => {
                const examples = items.slice(0, 10).map(p => '(' + p.join(',') + ')').join('; ');
                csv += `${type},${items.length},"${examples}"\n`;
            });
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'prime_constellations.csv';
            a.click();
        }
        
        // Auto-run analysis on page load with 10M default
        window.addEventListener('DOMContentLoaded', function() {
            console.log('Auto-running analysis with 10M primes...');
            setTimeout(() => {
                runAnalysis();
            }, 500); // Small delay to ensure everything is loaded
        });

        function renderComparisonChartActual() {
            if (!analysisResults?.comparisonData) {
                document.getElementById('comparisonWrapper').style.display = 'none';
                return;
            }
            
            document.getElementById('comparisonWrapper').style.display = 'block';
            
            const canvas = document.getElementById('comparisonChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const sValues = [1.5, 2, 3, 4, 5, 10];
            const gapColors = {1: '#ff4444', 2: '#ffd700', 4: '#4ecdc4', 6: '#8b5cf6', 8: '#06b6d4'};
            
            const margin = {left: 250, right: 200, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Contribution Evolution: How ζ(s) Changes Gap Dominance', w/2, 120);
            
            // Draw stacked bars for each s
            const barW = chartW / sValues.length * 0.8;
            const spacing = chartW / sValues.length;
            
            sValues.forEach((s, idx) => {
                const data = analysisResults.comparisonData[s];
                const x = margin.left + idx * spacing + spacing * 0.1;
                let yOffset = 0;
                
                [1, 2, 4, 6, 8].forEach(gap => {
                    const pct = data.percentageContributions[gap] || 0;
                    const barH = (pct / 100) * chartH;
                    
                    ctx.fillStyle = gapColors[gap];
                    ctx.fillRect(x, margin.top + chartH - yOffset - barH, barW, barH);
                    
                    yOffset += barH;
                });
                
                // Label
                ctx.fillStyle = '#aaa';
                ctx.font = 'bold 40px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`s=${s}`, x + barW/2, h - 100);
            });
            
            // Legend
            let legendY = margin.top + 50;
            Object.entries(gapColors).forEach(([gap, color]) => {
                ctx.fillStyle = color;
                ctx.fillRect(w - margin.right + 20, legendY, 50, 50);
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 36px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`Gap ${gap}`, w - margin.right + 80, legendY + 38);
                legendY += 80;
            });
        }
        
        function exportComparisonPNG() {
            const canvas = document.getElementById('comparisonChart');
            const link = document.createElement('a');
            link.download = `zeta_s_comparison_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // ========== CONVERGENCE ANALYSIS FUNCTIONS ==========
        
        function getConvergenceAnalysis(gap, product, s) {
            const TWIN_PRIME_CONSTANT = 0.6601618158468695739278121100145557784326233602847334;
            
            if (gap === 1) {
                const exact = Math.pow(2, s) / (Math.pow(2, s) - 1);
                const error = Math.abs(product - exact);
                const converged = error < 1e-10;
                
                return `
                    <strong style="color: #ffd700;">EXACT CONVERGENCE</strong><br><br>
                    
                    <strong>Theoretical Value:</strong><br>
                    P<sub>1</sub>(${s}) = 2<sup>${s}</sup>/(2<sup>${s}</sup>-1) = <strong>${exact.toFixed(15)}</strong><br><br>
                    
                    <strong>Computed Value:</strong><br>
                    P<sub>1</sub>(${s}) = <strong>${product.toFixed(15)}</strong><br><br>
                    
                    <strong>Error:</strong> ${error.toExponential(3)}<br>
                    <strong>Status:</strong> <span style="color: ${converged ? '#0f0' : '#f00'}">${converged ? '✓ FULLY CONVERGED' : 'Still converging'}</span><br><br>
                    
                    <strong>Why Exact?</strong><br>
                    Gap 1 contains only <strong>one prime: 2</strong>. Since there's only one term in the product,
                    the value is exactly 2<sup>${s}</sup>/(2<sup>${s}</sup>-1) with no approximation needed.
                `;
            }
            
            if (gap === 2) {
                const twinConstantRelated = 1.8 * TWIN_PRIME_CONSTANT;
                const remaining = (Math.PI**2 / 6) / ((4/3) * product);
                
                return `
                    <strong style="color: #ffd700;">TWIN PRIME CONVERGENCE</strong><br><br>
                    
                    <strong>Computed Value:</strong><br>
                    P<sub>2</sub>(2) = <strong>${product.toFixed(15)}</strong><br><br>
                    
                    <strong>Relationship to Twin Prime Constant:</strong><br>
                    Twin Prime Constant C₂ = ${TWIN_PRIME_CONSTANT.toFixed(15)}<br>
                    Empirical: P<sub>2</sub> ≈ 1.8 × C₂ ≈ ${twinConstantRelated.toFixed(15)}<br>
                    Your value differs by: ${Math.abs(product - twinConstantRelated).toFixed(15)}<br><br>
                    
                    <strong>Contribution to π²/6:</strong><br>
                    P<sub>1</sub> × P<sub>2</sub> = (4/3) × ${product.toFixed(6)} = ${(4/3 * product).toFixed(15)}<br>
                    Remaining: P<sub>4</sub> × P<sub>6</sub> × ... ≈ ${remaining.toFixed(15)}<br><br>
                    
                    <strong>Convergence Pattern:</strong><br>
                    As N → ∞, P<sub>2</sub> converges to a value related to the density of twin primes.<br>
                    Current convergence at ${analysisResults.maxPrime.toLocaleString()}: <strong>${((1 - Math.abs(product - twinConstantRelated)/product) * 100).toFixed(3)}%</strong><br><br>
                    
                    <strong>Hypothesis:</strong> If twin primes are infinite (unproven!), then P<sub>2</sub> converges to a constant.
                    If twin primes are finite, P<sub>2</sub> would plateau at some maximum value.
                `;
            }
            
            if (gap === 4) {
                return `
                    <strong style="color: #ffd700;">COUSIN PRIME CONVERGENCE</strong><br><br>
                    
                    <strong>Computed Value:</strong><br>
                    P<sub>4</sub>(2) = <strong>${product.toFixed(15)}</strong><br><br>
                    
                    <strong>Pattern:</strong><br>
                    Cousin primes (p, p+4) are less common than twin primes.<br>
                    P<sub>4</sub> < P<sub>2</sub> reflects this lower density.<br><br>
                    
                    <strong>Convergence:</strong><br>
                    Approaching 1 + small contribution (≈${product.toFixed(6)})<br>
                    Log contribution: ${Math.log(product).toFixed(15)}<br><br>
                    
                    This gap class contributes about ${((product - 1) * 100).toFixed(3)}% above baseline (1.0).
                `;
            }
            
            if (gap === 6) {
                return `
                    <strong style="color: #4ecdc4;">SEXY PRIME CONVERGENCE</strong><br><br>
                    
                    <strong>Computed Value:</strong><br>
                    P<sub>6</sub>(2) = <strong>${product.toFixed(15)}</strong><br><br>
                    
                    <strong>Pattern:</strong><br>
                    Sexy primes (p, p+6) are relatively common due to modular arithmetic patterns.<br>
                    P<sub>6</sub> shows significant contribution despite larger gap.<br><br>
                    
                    <strong>Convergence Speed:</strong><br>
                    Log(P<sub>6</sub>) = ${Math.log(product).toFixed(15)}<br>
                    Contribution: ${((product - 1) * 100).toFixed(3)}% above baseline<br><br>
                    
                    <strong>Modular Pattern:</strong><br>
                    Gap 6 is divisible by 6, creating patterns in prime distribution.
                `;
            }
            
            const logContrib = Math.log(product);
            const percentAbove = ((product - 1) * 100);
            
            return `
                <strong style="color: #4ecdc4;">GENERAL GAP CONVERGENCE</strong><br><br>
                
                <strong>Computed Value:</strong><br>
                P<sub>${gap}</sub>(${s}) = <strong>${product.toFixed(15)}</strong><br><br>
                
                <strong>Convergence Pattern:</strong><br>
                As gap size increases, fewer primes have this gap.<br>
                P<sub>${gap}</sub> approaches 1 as the gap gets larger.<br><br>
                
                <strong>Current State:</strong><br>
                Log(P<sub>${gap}</sub>) = ${logContrib.toFixed(15)}<br>
                Deviation from 1: ${percentAbove.toFixed(6)}%<br><br>
                
                <strong>Asymptotic Behavior:</strong><br>
                lim<sub>g→∞</sub> P<sub>g</sub>(s) = 1<br>
                (Larger gaps contribute less to the overall product)
            `;
        }

        // ========== MODAL POPUP FUNCTIONS ==========
        
        function showGapDetails(gap) {
            if (!analysisResults) return;
            
            const modal = document.getElementById('gapModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');
            
            const gapData = analysisResults.gapProducts[gap];
            if (!gapData) {
                alert(`No data available for gap ${gap}`);
                return;
            }
            
            const s = analysisResults.s || 2;
            const known = getKnownZetaValue(s);
            const zetaLabel = known ? `ζ(${s}) = ${known.formula}` : `ζ(${s.toFixed(2)})`;
            
            // Calculate additional statistics
            const pctContribution = analysisResults.percentageContributions[gap] || 0;
            const avgPrimeInGap = gapData.primes.reduce((a, b) => a + b, 0) / gapData.primes.length;
            
            // Find constellation type
            let gapType = '';
            if (gap === 1) gapType = 'Only Odd Gap (3-2=1)';
            else if (gap === 2) gapType = 'Twin Primes (p, p+2)';
            else if (gap === 4) gapType = 'Cousin Primes (p, p+4)';
            else if (gap === 6) gapType = 'Sexy Primes (p, p+6)';
            else if (gap % 6 === 0) gapType = 'Divisible by 6';
            else gapType = 'General Gap';
            
            title.textContent = `Gap ${gap} - Detailed Analysis`;
            
            body.innerHTML = `
                <div class="modal-section">
                    <div class="modal-section-title">Basic Information</div>
                    <div class="modal-stat-grid">
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Gap Size</div>
                            <div class="modal-stat-value">${gap}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Constellation Type</div>
                            <div class="modal-stat-value" style="font-size: 1rem;">${gapType}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Prime Count in Gap Family</div>
                            <div class="modal-stat-value">${gapData.count.toLocaleString()}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Current s Value</div>
                            <div class="modal-stat-value">s = ${s.toFixed(2)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Gap Product: P<sub>${gap}</sub>(s)</div>
                    <div class="modal-stat-grid">
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Product Value P<sub>${gap}</sub></div>
                            <div class="modal-stat-value">${gapData.product.toFixed(12)}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Log Product (log P<sub>${gap}</sub>)</div>
                            <div class="modal-stat-value">${gapData.logProduct.toFixed(12)}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Contribution to log(${zetaLabel})</div>
                            <div class="modal-stat-value">${pctContribution.toFixed(6)}%</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Formula</div>
                            <div class="modal-stat-value" style="font-size: 0.9rem;">∏<sub>p∈Gap${gap}</sub> p<sup>${s.toFixed(1)}</sup>/(p<sup>${s.toFixed(1)}</sup>-1)</div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Statistical Properties</div>
                    <div class="modal-stat-grid">
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Average Prime in Gap</div>
                            <div class="modal-stat-value">${avgPrimeInGap.toFixed(2)}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Smallest Prime</div>
                            <div class="modal-stat-value">${Math.min(...gapData.primes).toLocaleString()}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Largest Prime (shown)</div>
                            <div class="modal-stat-value">${Math.max(...gapData.primes).toLocaleString()}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Density (primes per 1000)</div>
                            <div class="modal-stat-value">${((gapData.count / analysisResults.maxPrime) * 1000).toFixed(3)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">All ${gapData.count.toLocaleString()} Primes in Gap ${gap} Family</div>
                    <div class="modal-prime-list">
                        <code>${gapData.primes.map(p => p.toLocaleString()).join(', ')}</code>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Convergence Analysis: What does P<sub>${gap}</sub> converge to?</div>
                    <div style="background: rgba(255, 215, 0, 0.05); padding: 16px; border-radius: 6px; border-left: 3px solid #ffd700; color: #ccc; line-height: 1.8;">
                        ${getConvergenceAnalysis(gap, gapData.product, s)}
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Mathematical Context</div>
                    <div style="background: rgba(139, 92, 246, 0.05); padding: 16px; border-radius: 6px; border-left: 3px solid #8b5cf6; color: #ccc; line-height: 1.8;">
                        <strong>Gap Decomposition Theorem:</strong><br>
                        ζ(s) = ∏<sub>g∈{1,2,4,6,...}</sub> P<sub>g</sub>(s)<br><br>
                        
                        For this gap:<br>
                        P<sub>${gap}</sub>(${s.toFixed(2)}) = ${gapData.product.toFixed(6)}<br>
                        Contributing ${pctContribution.toFixed(2)}% to the logarithmic product.<br><br>
                        
                        ${gap === 1 ? '<strong style="color: #ffd700;">Special Note:</strong> Gap 1 contains only prime 2, the only even prime and the only odd gap (3-2=1).' : ''}
                        ${gap === 2 ? '<strong style="color: #ffd700;">Twin Prime Note:</strong> These are primes p where p+2 is also prime. They dominate ζ(2) decomposition!' : ''}
                        ${gap === 6 ? '<strong style="color: #4ecdc4;">Sexy Prime Note:</strong> These are primes p where p+6 is also prime, named "sexy" from Latin "sex" (six).' : ''}
                    </div>
                </div>
            `;
            
            modal.classList.add('active');
        }
        
        function closeGapModal(event) {
            if (event && event.target.className !== 'modal-overlay') return;
            document.getElementById('gapModal').classList.remove('active');
        }
        
        function screenshotModal() {
            const modalContent = document.querySelector('.modal-content');
            
            // Use html2canvas to capture the modal
            html2canvas(modalContent, {
                scale: 3, // 4K quality (3x scale)
                backgroundColor: '#1a1a2e',
                logging: false,
                useCORS: true,
                width: modalContent.scrollWidth,
                height: modalContent.scrollHeight
            }).then(canvas => {
                // Convert to blob and download
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const modalTitle = document.getElementById('modalTitle').textContent.replace(/[^a-zA-Z0-9]/g, '_');
                    link.download = `${modalTitle}_${timestamp}_4K.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                }, 'image/png');
            }).catch(err => {
                console.error('Screenshot failed:', err);
                alert('Screenshot failed. Please try again.');
            });
        }
        
        // Make charts clickable
        function addChartClickHandlers() {
            const chartIds = ['gapContribChart', 'gapDistChart', 'percentageChart', 'errorChart', 'logScaleChart'];
            
            chartIds.forEach(chartId => {
                const canvas = document.getElementById(chartId);
                if (!canvas) return;
                
                canvas.style.cursor = 'pointer';
                canvas.onclick = (e) => handleChartClick(e, chartId);
            });
        }
        
        function handleChartClick(event, canvasId) {
            if (!analysisResults) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Scale to canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = x * scaleX;
            const canvasY = y * scaleY;
            
            // Determine which gap was clicked based on chart type
            const gaps = getFilteredGaps();
            const margin = {left: 250, right: 150, top: 200, bottom: 150};
            const chartW = canvas.width - margin.left - margin.right;
            const chartH = canvas.height - margin.top - margin.bottom;
            
            // Check if click is in chart area
            if (canvasX < margin.left || canvasX > canvas.width - margin.right ||
                canvasY < margin.top || canvasY > canvas.height - margin.bottom) {
                return;
            }
            
            // Determine clicked gap (assuming vertical bar chart layout)
            const barWidth = chartW / gaps.length;
            const clickedIndex = Math.floor((canvasX - margin.left) / barWidth);
            
            if (clickedIndex >= 0 && clickedIndex < gaps.length) {
                const clickedGap = gaps[clickedIndex];
                showGapDetails(clickedGap);
            }
        }
    </script>
</body>
</html>

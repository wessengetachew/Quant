<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farey Sector Formula - Complete Research Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0f1a; color: #e2e8f0; line-height: 1.6; font-size: 14px; }
        
        /* GLOBAL HARMONIC TOOLBAR - TOP DROPDOWN */
        .harmonic-toolbar {
            background: linear-gradient(90deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%);
            border-bottom: 2px solid #8b5cf6;
            position: sticky;
            top: 38px;
            z-index: 500;
        }
        .harmonic-toolbar-header {
            display: flex;
            align-items: center;
            padding: 6px 15px;
            cursor: pointer;
            gap: 15px;
        }
        .harmonic-toolbar-header:hover { background: rgba(139, 92, 246, 0.1); }
        .harmonic-toolbar-toggle {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border: none;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .harmonic-toolbar-toggle:hover { opacity: 0.9; }
        .harmonic-toolbar-toggle .icon { font-size: 14px; }
        .harmonic-toolbar-toggle.playing { background: linear-gradient(135deg, #22c55e, #16a34a); animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        @keyframes horizonPulse { 0%, 100% { transform: scale(1.15); box-shadow: 0 0 10px #8b5cf6; } 50% { transform: scale(1.2); box-shadow: 0 0 15px #8b5cf6; } }
        @keyframes audioPulse { 
            0%, 100% { background: linear-gradient(135deg, #22c55e, #16a34a); box-shadow: 0 0 8px rgba(34, 197, 94, 0.6); }
            50% { background: linear-gradient(135deg, #4ade80, #22c55e); box-shadow: 0 0 15px rgba(74, 222, 128, 0.9); }
        }
        .audio-toggle-label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-left: 12px;
            padding: 4px 10px;
            border-radius: 6px;
            cursor: pointer;
            animation: audioPulse 2s ease-in-out infinite;
            border: 1px solid #22c55e;
            transition: all 0.3s;
        }
        .audio-toggle-label:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(34, 197, 94, 1);
        }
        .audio-toggle-label span {
            font-size: 11px;
            color: #fff;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .audio-toggle-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #22c55e;
        }
        .horizon-frac-playing { animation: horizonPulse 0.3s ease-in-out; transition: all 0.15s ease; }
        .horizon-frac { transition: all 0.15s ease; }
        .horizon-frac:hover { transform: scale(1.1); filter: brightness(1.2); }
        .harmonic-quick-display {
            display: flex;
            align-items: center;
            gap: 20px;
            flex: 1;
            margin-left: 15px;
        }
        .harmonic-quick-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }
        .harmonic-quick-item label { color: #94a3b8; font-size: 11px; }
        .harmonic-quick-item .value { color: #8b5cf6; font-weight: 600; font-family: monospace; font-size: 13px; }
        .harmonic-quick-item .note { color: #22c55e; font-weight: 600; font-size: 13px; }
        .harmonic-quick-btns {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }
        .harmonic-quick-btn {
            padding: 5px 10px;
            font-size: 11px;
            background: rgba(99, 102, 241, 0.3);
            border: 1px solid #6366f1;
            border-radius: 4px;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.2s;
        }
        .harmonic-quick-btn:hover { background: rgba(99, 102, 241, 0.5); transform: translateY(-1px); }
        .harmonic-quick-btn.play { background: rgba(34, 197, 94, 0.3); border-color: #22c55e; }
        .harmonic-quick-btn.play:hover { background: rgba(34, 197, 94, 0.5); }
        .harmonic-quick-btn.stop { background: rgba(239, 68, 68, 0.3); border-color: #ef4444; }
        .harmonic-quick-btn.stop:hover { background: rgba(239, 68, 68, 0.5); }
        
        .harmonic-panel-dropdown {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
            background: #0f172a;
        }
        .harmonic-panel-dropdown.expanded { 
            max-height: 600px; 
            overflow-y: auto; 
        }
        .harmonic-panel-content {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }
        .harmonic-toolbar-header.expanded .harmonic-toolbar-toggle {
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }
        #harmonicArrow.rotated {
            transform: rotate(180deg);
        }
        .harmonic-card {
            background: #1e293b;
            border-radius: 6px;
            padding: 12px;
            border: 1px solid #334155;
        }
        .harmonic-card h5 {
            color: #a5b4fc;
            font-size: 11px;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .harmonic-card h5 .badge { background: #22c55e; padding: 2px 6px; border-radius: 8px; font-size: 8px; color: white; }
        .harmonic-card-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
        .harmonic-card-row:last-child { margin-bottom: 0; }
        .harmonic-card-row label { font-size: 10px; color: #94a3b8; min-width: 55px; }
        .harmonic-card-row input[type="range"] { flex: 1; height: 4px; cursor: pointer; }
        .harmonic-card-row input[type="number"] { width: 55px; padding: 3px 5px; font-size: 10px; background: #0f172a; border: 1px solid #475569; border-radius: 3px; color: #e2e8f0; }
        .harmonic-card-row select { flex: 1; padding: 4px 6px; font-size: 10px; background: #0f172a; border: 1px solid #475569; border-radius: 3px; color: #e2e8f0; }
        .harmonic-card-row .val { font-size: 10px; color: #8b5cf6; font-weight: 600; min-width: 40px; text-align: right; font-family: monospace; }
        
        .interval-grid-compact { display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px; }
        .interval-btn-sm { padding: 5px 3px; font-size: 9px; background: #0f172a; border: 1px solid #475569; border-radius: 3px; color: #e2e8f0; cursor: pointer; text-align: center; transition: all 0.2s; font-family: monospace; }
        .interval-btn-sm:hover { background: #334155; border-color: #6366f1; transform: translateY(-1px); }
        .interval-btn-sm.active { background: #6366f1; border-color: #8b5cf6; color: white; }
        
        .phase-preset-btn { padding: 4px 8px; font-size: 10px; background: #0f172a; border: 1px solid #00bcd4; border-radius: 4px; color: #00bcd4; cursor: pointer; font-family: monospace; transition: all 0.2s; }
        .phase-preset-btn:hover { background: #00bcd4; color: #0f172a; transform: translateY(-1px); }
        .phase-preset-btn.active { background: #00bcd4; color: #0f172a; box-shadow: 0 0 8px #00bcd4; }
        
        .mode-badge { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 9px; font-weight: 600; }
        .mode-badge.unison { background: #22c55e30; color: #4ade80; }
        .mode-badge.consonant { background: #3b82f630; color: #60a5fa; }
        .mode-badge.complex { background: #f59e0b30; color: #fbbf24; }
        .mode-badge.dissonant { background: #ef444430; color: #f87171; }
        
        .freq-box { background: #0f172a; padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #334155; }
        .freq-box .big { font-size: 20px; font-weight: bold; color: #8b5cf6; font-family: monospace; }
        .freq-box .small { font-size: 11px; color: #64748b; margin-top: 2px; }
        
        .arnold-canvas-sm { width: 100%; height: 70px; background: #0f172a; border-radius: 4px; border: 1px solid #334155; display: block; }
        .spectrum-canvas-sm { width: 100%; height: 40px; background: #0f172a; border-radius: 4px; border: 1px solid #334155; display: block; }
        
        .keyboard-row { display: flex; gap: 1px; height: 28px; }
        .key-white { flex: 1; background: linear-gradient(180deg, #f1f5f9, #cbd5e1); border-radius: 0 0 2px 2px; cursor: pointer; min-width: 14px; }
        .key-white:hover { background: #a5b4fc; }
        .key-white.active { background: #6366f1; }
        .key-black { width: 12px; background: linear-gradient(180deg, #1e293b, #0f172a); margin: 0 -6px; z-index: 1; height: 18px; border-radius: 0 0 2px 2px; cursor: pointer; }
        .key-black:hover { background: #475569; }
        .key-black.active { background: #8b5cf6; }
        
        .nav-links { background: linear-gradient(90deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%); padding: 8px 15px; border-bottom: 1px solid #4338ca; overflow-x: auto; white-space: nowrap; position: sticky; top: 0; z-index: 500; }
        .nav-links::-webkit-scrollbar { height: 4px; }
        .nav-links::-webkit-scrollbar-track { background: #1e1b4b; }
        .nav-links::-webkit-scrollbar-thumb { background: #6366f1; border-radius: 2px; }
        .nav-links a { display: inline-block; padding: 4px 10px; margin: 2px 3px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 4px; color: #a5b4fc; text-decoration: none; font-size: 11px; font-weight: 500; transition: all 0.2s; }
        .nav-links a:hover { background: rgba(99, 102, 241, 0.4); color: #e0e7ff; border-color: #6366f1; transform: translateY(-1px); }
        .nav-links-label { color: #64748b; font-size: 10px; margin-right: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1000; overflow-y: auto; padding: 20px; }
        .modal-overlay.active { display: flex; justify-content: center; align-items: flex-start; }
        .modal-content { background: #1e293b; border-radius: 12px; max-width: 900px; width: 100%; border: 1px solid #475569; margin: 20px auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 18px; border-bottom: 1px solid #334155; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); border-radius: 12px 12px 0 0; }
        .modal-header h3 { margin: 0; font-size: 1.1em; }
        .modal-close { background: rgba(255,255,255,0.2); border: none; color: white; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 16px; }
        .modal-body { padding: 18px; max-height: 75vh; overflow-y: auto; }
        
        /* SOLVER STYLES */
        #solverPanel input:focus { border-color: #10b981; box-shadow: 0 0 0 3px rgba(16,185,129,0.2); }
        #solverPanel input::placeholder { color: #6b7280; }
        .solver-result-item { padding: 10px; background: rgba(16,185,129,0.1); border-radius: 6px; border: 1px solid rgba(16,185,129,0.2); }
        #solverResults table tr:hover { background: rgba(16,185,129,0.1); }
        #solverResults th { border-bottom: 1px solid #334155; padding-bottom: 8px; }
        
        /* Export buttons */
        
        .container { max-width: 1800px; margin: 0 auto; padding: 15px; }
        h1 { color: #f8fafc; font-size: 1.5em; margin-bottom: 4px; }
        .subtitle { color: #94a3b8; margin-bottom: 15px; font-size: 0.9em; }
        h2 { color: #f1f5f9; font-size: 1.1em; margin: 20px 0 12px 0; border-bottom: 1px solid #334155; padding-bottom: 6px; }
        h3 { color: #cbd5e1; font-size: 1em; margin: 12px 0 8px 0; }
        h4 { color: #94a3b8; font-size: 0.9em; margin: 8px 0 6px 0; }
        
        .formula-box { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 15px; border-radius: 10px; margin-bottom: 15px; }
        .formula-main { font-size: 1.3em; font-weight: bold; font-family: 'Cambria Math', serif; text-align: center; margin: 8px 0; }
        
        .control-panel { background: #1e293b; padding: 12px 15px; border-radius: 8px; margin-bottom: 12px; border: 1px solid #334155; }
        .control-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .control-row:last-child { margin-bottom: 0; }
        .control-group { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: #0f172a; border-radius: 5px; }
        .control-group.highlight { border: 1px solid #6366f1; background: #1e1b4b; }
        label { font-weight: 600; color: #cbd5e1; font-size: 0.8em; white-space: nowrap; }
        input[type="number"], input[type="text"], select, textarea { padding: 6px 8px; font-size: 13px; border: 1px solid #475569; border-radius: 5px; background: #1e293b; color: #e2e8f0; }
        input[type="number"] { width: 70px; }
        input:focus, select:focus, textarea:focus { outline: none; border-color: #6366f1; }
        select { min-width: 90px; }
        button { padding: 8px 14px; font-size: 12px; font-weight: 600; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { opacity: 0.9; }
        button.secondary { background: #334155; border: 1px solid #475569; }
        button.small { padding: 5px 10px; font-size: 11px; }
        .info-badge { background: #334155; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; color: #94a3b8; }
        .info-badge strong { color: #e2e8f0; }
        .info-badge.success { background: #14532d; border: 1px solid #16a34a; }
        .info-badge.warning { background: #713f12; border: 1px solid #a16207; }
        
        .mode-selector { display: flex; gap: 4px; }
        .mode-btn { padding: 6px 12px; background: #1e293b; border: 1px solid #475569; border-radius: 5px; cursor: pointer; font-size: 0.8em; color: #94a3b8; }
        .mode-btn.active { background: #6366f1; border-color: #6366f1; color: white; }
        
        .tabs { display: flex; gap: 3px; margin-bottom: 0; flex-wrap: wrap; }
        .tab { padding: 8px 16px; background: #1e293b; border: 1px solid #334155; border-radius: 5px 5px 0 0; cursor: pointer; font-size: 0.85em; color: #94a3b8; font-weight: 500; transition: all 0.2s; }
        .tab.active { background: #4f46e5; color: #f1f5f9; border-color: #4f46e5; }
        .tab:hover { color: #e2e8f0; background: #334155; }
        .subtabs { display: flex; gap: 5px; padding: 8px 20px; background: linear-gradient(180deg, #1e293b, #0f172a); border-bottom: 1px solid #334155; margin-bottom: 12px; }
        .subtab { padding: 5px 12px; background: transparent; border: 1px solid #475569; border-radius: 4px; cursor: pointer; font-size: 0.8em; color: #94a3b8; transition: all 0.2s; }
        .subtab:hover { background: #334155; color: #e2e8f0; }
        .subtab.active { background: #6366f1; color: white; border-color: #6366f1; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .panel { background: #1e293b; border-radius: 8px; padding: 15px; border: 1px solid #334155; margin-bottom: 15px; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
        .grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        @media (max-width: 1200px) { .grid-2, .grid-3, .grid-4 { grid-template-columns: 1fr; } }
        
        .chart-box { background: #0f172a; border-radius: 6px; padding: 12px; border: 1px solid #334155; }
        .chart-box h4 { margin-top: 0; }
        canvas { max-width: 100%; }
        
        table { width: 100%; border-collapse: collapse; font-size: 0.8em; }
        thead { background: #334155; }
        th { padding: 8px; text-align: left; font-weight: 600; color: #e2e8f0; }
        td { padding: 6px 8px; border-bottom: 1px solid #334155; }
        tbody tr:hover { background: #334155; }
        .table-scroll { max-height: 350px; overflow-y: auto; }
        
        .detail-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .detail-card { background: #0f172a; padding: 12px; border-radius: 6px; border: 1px solid #334155; }
        .detail-card h5 { color: #94a3b8; font-size: 0.75em; margin-bottom: 6px; text-transform: uppercase; }
        .detail-card .value { font-size: 1.2em; font-weight: bold; color: #6366f1; }
        .detail-card .sub { font-size: 0.8em; color: #64748b; margin-top: 3px; }
        
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; }
        .stat-card { background: #0f172a; padding: 10px; border-radius: 5px; border: 1px solid #334155; text-align: center; }
        .stat-value { font-size: 1.1em; font-weight: bold; color: #6366f1; }
        .stat-label { font-size: 0.7em; color: #94a3b8; margin-top: 3px; }
        
        .theorem-box { background: #1e1b4b; border-left: 3px solid #6366f1; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .derivation-box { background: #422006; border-left: 3px solid #f59e0b; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .rh-box { background: #450a0a; border-left: 3px solid #ef4444; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .connection-box { background: #14532d; border-left: 3px solid #22c55e; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        
        .ring-canvas { background: #0f172a; border-radius: 6px; border: 1px solid #334155; cursor: crosshair; }
        .point-tooltip { position: absolute; background: #1e293b; border: 1px solid #6366f1; padding: 8px 12px; border-radius: 6px; font-size: 0.8em; pointer-events: none; z-index: 100; display: none; min-width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .point-tooltip.visible { display: block; }
        .point-tooltip h5 { color: #6366f1; margin: 0 0 6px 0; font-size: 1em; }
        .point-tooltip .row { display: flex; justify-content: space-between; margin: 2px 0; }
        .point-tooltip .label { color: #94a3b8; }
        .point-tooltip .val { color: #e2e8f0; font-weight: 600; }
        
        .color-legend { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 8px; padding: 8px; background: #0f172a; border-radius: 5px; font-size: 0.75em; }
        .color-legend-item { display: flex; align-items: center; gap: 5px; }
        .color-swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid #475569; }
        
        .progress-bar { width: 100%; height: 5px; background: #334155; border-radius: 3px; overflow: hidden; margin: 8px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); transition: width 0.3s; }
        
        .matrix-display { font-family: 'Courier New', monospace; background: #0f172a; padding: 10px; border-radius: 5px; display: inline-block; margin: 5px; }
        .matrix-bracket { font-size: 2em; line-height: 1; }
        
        .residue-list { max-height: 180px; overflow-y: auto; background: #0f172a; padding: 8px; border-radius: 5px; font-family: monospace; font-size: 0.8em; }
        .residue-item { display: inline-block; padding: 3px 8px; margin: 3px; background: #334155; border-radius: 3px; cursor: default; transition: background 0.2s; }
        .residue-item:hover { background: #475569; }
        .residue-item.prime { background: #854d0e; color: #fbbf24; border: 1px solid #f59e0b; }
        .residue-item.prime:hover { background: #a16207; }
        .residue-item.twin { background: #166534; color: #4ade80; }
        
        .latex-output { background: #0f172a; padding: 12px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; border: 1px solid #334155; max-height: 250px; overflow-y: auto; }
        
        .cf-path { font-family: monospace; background: #334155; padding: 2px 6px; border-radius: 3px; margin: 2px; display: inline-block; }
        
        .screenshot-btn { position: absolute; top: 8px; right: 8px; padding: 4px 8px; background: rgba(99,102,241,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn { position: absolute; top: 8px; right: 90px; padding: 4px 8px; background: rgba(168,85,247,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn:hover { background: rgba(168,85,247,1); }
        .chart-wrapper { position: relative; }
        .composite-export-btn { margin-top: 10px; padding: 10px 16px; font-size: 13px; background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%); }
        .composite-export-btn:hover { opacity: 0.95; }
        #compositeCanvas { display: none; max-width: 100%; margin-top: 10px; }
        .composite-info { background: #1e1b4b; border: 1px solid #8b5cf6; padding: 10px 12px; border-radius: 5px; margin-top: 10px; font-size: 0.85em; color: #cbd5e1; }
        
        .screenshot-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; justify-content: center; align-items: center; flex-direction: column; padding: 20px; }
        .screenshot-overlay.active { display: flex; }
        .screenshot-preview { max-width: 90%; max-height: 60vh; border: 2px solid #6366f1; border-radius: 8px; }
        .screenshot-actions { margin-top: 20px; display: flex; gap: 10px; }
        .screenshot-actions button { padding: 12px 24px; font-size: 14px; }
        
        .heatmap-cell { display: inline-block; width: 20px; height: 20px; margin: 1px; border-radius: 2px; }
        
        .euler-term { display: inline-block; padding: 4px 8px; margin: 3px; background: #1e293b; border-radius: 4px; border: 1px solid #334155; font-family: monospace; }
        .euler-term.prime { border-color: #f59e0b; }
    </style>
</head>
<body>
<div class="nav-links">
    <span class="nav-links-label">Projects:</span>
    <a href="https://wessengetachew.github.io/2025/" target="_blank">2025</a>
    <a href="https://wessengetachew.github.io/Transform/" target="_blank">Transform</a>
    <a href="https://wessengetachew.github.io/finite/" target="_blank">Finite</a>
    <a href="https://wessengetachew.github.io/Primes/" target="_blank">Primes</a>
    <a href="https://wessengetachew.github.io/Farey/" target="_blank">Farey</a>
    <a href="https://wessengetachew.github.io/Composite/" target="_blank">Composite</a>
    <a href="https://wessengetachew.github.io/Ethiopian/" target="_blank">Ethiopian</a>
    <a href="https://wessengetachew.github.io/2pir/" target="_blank">2œÄr</a>
    <a href="https://wessengetachew.github.io/1-2/" target="_blank">1-2</a>
    <a href="https://wessengetachew.github.io/Rational-/" target="_blank">Rational</a>
    <a href="https://wessengetachew.github.io/Infinitemoduli/" target="_blank">Infinite Moduli</a>
    <a href="https://wessengetachew.github.io/Pythagorean-/" target="_blank">Pythagorean</a>
    <a href="https://wessengetachew.github.io/Phase/" target="_blank">Phase</a>
    <a href="https://wessengetachew.github.io/Gemini/" target="_blank">Gemini</a>
    <a href="https://wessengetachew.github.io/Rebuild/" target="_blank">Rebuild</a>
    <a href="https://wessengetachew.github.io/Goldbach/" target="_blank">Goldbach</a>
</div>

<!-- GLOBAL HARMONIC ANALYSIS PANEL - COMPLETE -->
<!-- HARMONIC TOOLBAR - COLLAPSED BY DEFAULT -->
<div class="harmonic-toolbar" id="harmonicToolbar">
    <div class="harmonic-toolbar-header" onclick="toggleHarmonicDropdown()">
        <button class="harmonic-toolbar-toggle" id="harmonicToggle">
            <span class="icon">‚ô™</span>
            HARMONIC ANALYSIS
            <span id="harmonicArrow" style="margin-left:8px;transition:transform 0.3s;">‚ñº</span>
        </button>
        <div class="harmonic-quick-display">
            <div class="harmonic-quick-item">
                <label>Selected:</label>
                <span class="value" id="quickFraction">1/2</span>
            </div>
            <div class="harmonic-quick-item">
                <label>Freq:</label>
                <span class="value" id="quickFreq">110 Hz</span>
            </div>
            <div class="harmonic-quick-item">
                <label>Œª:</label>
                <span class="value" id="quickWave" style="color:#f59e0b;">3.12 m</span>
            </div>
            <div class="harmonic-quick-item">
                <label>Note:</label>
                <span class="note" id="quickNote">A2</span>
            </div>
            <div class="harmonic-quick-item" id="playbackStatusContainer" style="display:none;">
                <label>Status:</label>
                <span class="value" id="playbackStatus" style="color:#22c55e;">Playing...</span>
            </div>
            <div class="harmonic-quick-btns">
                <button class="harmonic-quick-btn play" onclick="event.stopPropagation(); playSelectedFraction();" title="Play single note">‚ñ∂</button>
                <button class="harmonic-quick-btn" onclick="event.stopPropagation(); if(selectedTreePoint) playTreePathAudio('forward'); else playSectorSequence('forward');" title="Play sequence">‚ô™</button>
                <button class="harmonic-quick-btn stop" onclick="event.stopPropagation(); stopAllPlayback();" title="Stop all">‚ñ†</button>
            </div>
        </div>
    </div>
    <div class="harmonic-panel-dropdown" id="harmonicDropdown">
        <div class="harmonic-panel-content">
            <!-- AUDIO ENGINE -->
            <div class="harmonic-card">
                <h5>Audio Engine <span class="badge">LIVE</span></h5>
                <div class="harmonic-card-row">
                    <label>Base Hz:</label>
                    <input type="number" id="baseFreq" min="20" max="2000" value="440" step="1" style="width:70px;" oninput="updateBaseFreq()">
                    <input type="range" id="baseFreqSlider" min="55" max="880" value="440" oninput="document.getElementById('baseFreq').value=this.value; updateBaseFreq()">
                    <span class="val" id="baseFreqVal">440 Hz</span>
                </div>
                <div class="harmonic-card-row">
                    <label>Volume:</label>
                    <input type="range" id="harmonicVolume" min="0" max="100" value="100" oninput="updateHarmonicVolume()">
                    <span class="val" id="volumeVal">100%</span>
                </div>
                <div class="harmonic-card-row">
                    <label>Wave:</label>
                    <select id="waveform" onchange="updateWaveform()">
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="square">Square</option>
                        <option value="sawtooth">Sawtooth</option>
                    </select>
                </div>
                <div class="freq-box" style="margin-top:8px;">
                    <div class="big" id="currentFreqDisplay">110 Hz</div>
                    <div class="small" id="currentNoteDisplay">1/2 = A2</div>
                </div>
            </div>
            
            <!-- WAVELENGTH DISPLAY -->
            <div class="harmonic-card">
                <h5>Wave Properties <span class="badge" style="background:#f59e0b;">Œª</span></h5>
                <div class="freq-box" style="background:linear-gradient(135deg,#1e1b4b,#0f172a);">
                    <div class="big" id="wavelengthDisplay" style="color:#f59e0b;">78.0 cm</div>
                    <div class="small">Wavelength (v=343 m/s)</div>
                </div>
                <div style="margin-top:8px;font-size:10px;color:#64748b;">
                    <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                        <span>Period:</span>
                        <span id="periodDisplay" style="color:#a5b4fc;">2.27 ms</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                        <span>Angular œâ:</span>
                        <span id="angularFreqDisplay" style="color:#a5b4fc;">2764 rad/s</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;">
                        <span>Wavenumber k:</span>
                        <span id="wavenumberDisplay" style="color:#a5b4fc;">8.06 /m</span>
                    </div>
                </div>
            </div>
            
            <!-- MUSICAL INTERVALS -->
            <div class="harmonic-card">
                <h5>Musical Intervals</h5>
                <div class="interval-grid-compact" id="intervalGrid">
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(1,1)" title="Unison">1:1</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(16,15)" title="m2">16:15</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(9,8)" title="M2">9:8</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(6,5)" title="m3">6:5</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(5,4)" title="M3">5:4</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(4,3)" title="P4">4:3</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(45,32)" title="TT">45:32</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(3,2)" title="P5">3:2</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(8,5)" title="m6">8:5</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(5,3)" title="M6">5:3</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(9,5)" title="m7">9:5</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(15,8)" title="M7">15:8</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(2,1)" title="Oct">2:1</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(5,2)" title="10th">5:2</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(3,1)" title="12th">3:1</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(4,1)" title="2Oct">4:1</button>
                </div>
                <div id="customIntervalsGrid" class="interval-grid-compact" style="margin-top:4px;"></div>
                <div style="margin-top:6px;display:flex;gap:4px;align-items:center;">
                    <input type="text" id="customIntervalInput" placeholder="a:b (e.g. 7:4)" style="width:70px;padding:4px 6px;font-size:10px;font-family:monospace;background:#0f172a;border:1px solid #475569;border-radius:3px;color:#e2e8f0;text-align:center;">
                    <button onclick="addCustomInterval()" style="padding:4px 8px;font-size:10px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:3px;color:white;cursor:pointer;">+ Add</button>
                    <button onclick="clearCustomIntervals()" style="padding:4px 8px;font-size:10px;background:#475569;border:none;border-radius:3px;color:white;cursor:pointer;" title="Clear custom intervals">Clear</button>
                </div>
                <div style="margin-top:8px;display:flex;gap:4px;justify-content:center;flex-wrap:wrap;">
                    <button class="harmonic-quick-btn play" onclick="playSelectedFraction()">‚ñ∂ Play</button>
                    <button class="harmonic-quick-btn" onclick="playArpeggio()">Arpeggio</button>
                    <button class="harmonic-quick-btn" onclick="playChord()">Chord</button>
                    <button class="harmonic-quick-btn" id="randomIntervalBtn" onclick="toggleRandomIntervals()" style="background:linear-gradient(135deg,#f59e0b,#d97706);border-color:#f59e0b;">üé≤ Random</button>
                    <button class="harmonic-quick-btn stop" onclick="stopAudio(); stopRandomIntervals();">‚ñ† Stop</button>
                </div>
            </div>
            
            <!-- HARMONIC MODE -->
            <div class="harmonic-card">
                <h5>Harmonic Mode</h5>
                <div style="text-align:center;margin:8px 0;">
                    <span class="mode-badge consonant" id="harmonicModeIndicator">Consonant</span>
                    <span style="font-size:10px;color:#64748b;margin-left:6px;" id="modeQValue">q ‚â§ 4</span>
                </div>
                <div style="font-size:9px;color:#64748b;display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:8px;">
                    <div><span class="mode-badge unison" style="font-size:8px;">Unison</span> q=1</div>
                    <div><span class="mode-badge consonant" style="font-size:8px;">Consonant</span> q‚â§4</div>
                    <div><span class="mode-badge complex" style="font-size:8px;">Complex</span> q‚â§16</div>
                    <div><span class="mode-badge dissonant" style="font-size:8px;">Dissonant</span> q>16</div>
                </div>
            </div>
            
            <!-- ARNOLD TONGUE PREVIEW -->
            <div class="harmonic-card">
                <h5>Arnold Tongue</h5>
                <canvas id="arnoldMiniCanvas" class="arnold-canvas-sm" width="200" height="70"></canvas>
                <div class="harmonic-card-row" style="margin-top:6px;">
                    <label>K:</label>
                    <input type="range" id="arnoldK" min="0" max="100" value="50" oninput="updateArnoldTongue()">
                    <span class="val" id="arnoldKVal">0.50</span>
                </div>
            </div>
            
            <!-- HARMONIC SERIES -->
            <div class="harmonic-card">
                <h5>Harmonic Series</h5>
                <div class="harmonic-card-row">
                    <label>Partials:</label>
                    <input type="range" id="numPartials" min="1" max="16" value="8" oninput="updateHarmonicSeries()">
                    <span class="val" id="partialsVal">8</span>
                </div>
                <canvas id="harmonicSeriesCanvas" class="spectrum-canvas-sm" width="200" height="40"></canvas>
                <div style="margin-top:6px;display:flex;gap:4px;">
                    <button class="harmonic-quick-btn" onclick="playHarmonicSeries()" style="flex:1;">Harmonic</button>
                    <button class="harmonic-quick-btn" onclick="playSubharmonicSeries()" style="flex:1;">Subharmonic</button>
                </div>
            </div>
            
            <!-- GLOBAL OPTIONS -->
            <div class="harmonic-card">
                <h5>Options</h5>
                <div style="font-size:10px;display:flex;flex-direction:column;gap:4px;">
                    <label><input type="checkbox" id="applyHarmonicColor" onchange="applyHarmonicColoring()"> Color by consonance</label>
                    <label><input type="checkbox" id="showArnoldOnTree" onchange="drawSectorTree()"> Arnold on tree</label>
                    <label><input type="checkbox" id="showFreqOnHover"> Show freq on hover</label>
                </div>
            </div>
        
            <!-- SELECTED FRACTION -->
            <div class="harmonic-card">
                <h5>Selected Fraction</h5>
                <div id="selectedFractionInfo" style="font-size:10px;color:#94a3b8;">
                    Click any point to select
                </div>
            </div>
            
            <!-- RESET BUTTON & KEYBOARD HINTS -->
            <div class="harmonic-card" style="text-align:center;">
                <button class="harmonic-quick-btn" onclick="resetHarmonicDefaults()" style="padding:6px 12px;">Reset Defaults</button>
                <div style="margin-top:8px;font-size:9px;color:#64748b;text-align:left;">
                    <strong>Keyboard:</strong><br>
                    Space = toggle play<br>
                    ‚Üê/‚Üí = path direction<br>
                    ‚Üë/‚Üì = sector direction<br>
                    Esc = stop
                </div>
            </div>
        </div>
    </div>
</div>
<div class="container">
    <h1>Farey Sector Formula - Complete Research Platform</h1>
    <p class="subtitle">Comprehensive analysis with RH connections, modular arithmetic, and advanced visualizations</p>
    
    <div class="formula-box">
        <div class="formula-main" id="formulaDisplay">C(n, N) = 3N¬≤ / (œÄ¬≤ n(n+1))</div>
        <div id="formulaComputed" style="text-align:center; font-size:0.9em; color:#22c55e; margin-top:8px; display:none;"></div>
        <p style="text-align:center; font-size:0.85em; opacity:0.9;">Asymptotic count of coprime pairs (r, m) with r/m in sector S_n = (1/(n+1), 1/n]</p>
    </div>
    
    <div class="control-panel">
        <div class="control-row">
            <label>Mode:</label>
            <div class="mode-selector">
                <div class="mode-btn active" onclick="setMode('exact')" id="mode-exact">Exact</div>
                <div class="mode-btn" onclick="setMode('hybrid')" id="mode-hybrid">Hybrid</div>
                <div class="mode-btn" onclick="setMode('formula')" id="mode-formula">Formula</div>
            </div>
            <span class="info-badge" id="modeDescription">Exact enumeration</span>
        </div>
        <div class="control-row">
            <div class="control-group highlight">
                <label>N:</label>
                <input type="number" id="nMin" value="1" min="1" onchange="computeAll()"> to
                <input type="number" id="nMax" value="500" min="2" onchange="computeAll()">
            </div>
            <div class="control-group highlight">
                <label>Sectors:</label>
                <input type="number" id="sectorMin" value="1" min="1" onchange="computeAll()"> to
                <input type="number" id="sectorMax" value="275" min="1" onchange="computeAll()">
            </div>
            <button onclick="computeAll()">Compute</button>
            <button class="secondary" onclick="cancelComputation()">Cancel</button>
            <button class="secondary" onclick="exportAllWithCharts()" title="Export CSV + 4K charts">Export All + 4K</button>
            <label class="audio-toggle-label" title="Enable to play audio when clicking points">
                <input type="checkbox" id="autoPlayOnClick">
                <span>üîä Auto-play audio</span>
            </label>
        </div>
        
        <!-- Sector Bound Controls -->
        <div class="control-row" style="background:#0f172a;padding:8px 12px;border-radius:6px;margin-top:8px;border:1px solid #334155;">
            <label style="color:#94a3b8;font-size:11px;margin-right:8px;">Sector Bound:</label>
            <label style="font-size:11px;"><input type="checkbox" id="useSectorBound" checked onchange="updateSectorBound()"> Auto-bound</label>
            <label style="margin-left:12px;font-size:11px;">Constant:</label>
            <select id="sectorBoundPreset" onchange="applySectorBoundPreset()" style="font-size:11px;padding:3px 6px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;">
                <option value="sqrt3pi" selected>‚àö3/œÄ ‚âà 0.5513</option>
                <option value="sqrt6pi">‚àö6/œÄ ‚âà 0.7797</option>
                <option value="1pi">1/œÄ ‚âà 0.3183</option>
                <option value="2pi">2/œÄ ‚âà 0.6366</option>
                <option value="sqrt2pi">‚àö2/œÄ ‚âà 0.4502</option>
                <option value="1">1.0000</option>
                <option value="custom">Custom...</option>
            </select>
            <label style="margin-left:8px;font-size:11px;">or enter:</label>
            <input type="text" id="customSectorBound" value="sqrt(3)/pi" placeholder="e.g. sqrt(6)/pi" style="width:100px;font-size:11px;padding:3px 6px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;font-family:monospace;" onchange="applyCustomSectorBound()">
            <span id="sectorBoundValue" style="color:#22c55e;font-size:11px;font-family:monospace;margin-left:8px;">= 0.5513</span>
            <span id="sectorBoundResult" style="color:#f59e0b;font-size:11px;margin-left:8px;">‚Üí Max sector: 275</span>
        </div>
        
        <!-- Bounded P/C Analysis for Large N -->
        <div class="control-row" style="background:#1e1b4b;padding:8px 12px;border-radius:6px;margin-top:8px;border:1px solid #6366f1;">
            <label style="color:#a5b4fc;font-size:11px;font-weight:bold;margin-right:8px;">Large N P/C Analysis:</label>
            <label style="font-size:11px;"><input type="checkbox" id="computeBoundedPC"> Compute bounded window for P/C ratios</label>
            <label style="margin-left:12px;font-size:11px;">Window N:</label>
            <input type="number" id="boundedWindowN" value="2000" min="100" max="5000" style="width:70px;font-size:11px;padding:3px 6px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;">
            <span style="color:#64748b;font-size:10px;margin-left:8px;">(exact data computed up to this N for P/C ratios)</span>
            <button onclick="showConvergenceAnalysis()" class="secondary" style="margin-left:12px;font-size:10px;padding:4px 8px;">Convergence Analysis</button>
        </div>
        
        <!-- Global Display Format Controls -->
        <div class="control-row" style="background:linear-gradient(135deg,#1e1b4b,#312e81);padding:10px 15px;border-radius:6px;margin-top:10px;">
            <label style="color:#a5b4fc;font-weight:600;">Global Display:</label>
            <select id="globalDisplayFormat" onchange="updateGlobalDisplayFormat()" style="padding:5px 10px;background:#0f172a;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                <option value="fraction">Fraction (r/m)</option>
                <option value="decimal">Decimal</option>
                <option value="degree">Degrees (0-360¬∞)</option>
                <option value="radian">Radians (0-2œÄ)</option>
                <option value="pi">œÄ-fraction (√óœÄ)</option>
            </select>
            <label style="color:#a5b4fc;margin-left:15px;">Precision:</label>
            <select id="globalPrecision" onchange="updateGlobalDisplayFormat()" style="padding:5px 10px;background:#0f172a;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                <option value="2">2 decimals</option>
                <option value="4" selected>4 decimals</option>
                <option value="6">6 decimals</option>
                <option value="8">8 decimals</option>
                <option value="10">10 decimals</option>
                <option value="12">12 decimals</option>
            </select>
            <span id="globalFormatPreview" style="color:#22c55e;margin-left:15px;font-family:monospace;">1/2 = 0.5000</span>
        </div>
        
        <div class="progress-bar" id="progressBar" style="display:none;"><div class="progress-fill" id="progressFill"></div></div>
        <div id="statusArea"></div>
    </div>
    
    <div class="tabs">
        <div class="tab active" onclick="switchTab('main')">Explorer</div>
        <div class="tab" onclick="switchTab('analysis')">Analysis</div>
        <div class="tab" onclick="switchTab('theory')">Theory</div>
        <div class="tab" onclick="switchTab('geometry')">Geometry</div>
        <div class="tab" onclick="switchTab('connections')">Connections</div>
        <div class="tab" onclick="switchTab('advanced')">Advanced</div>
        <div class="tab" onclick="switchTab('references')">References</div>
    </div>
    
    <!-- SUB-TABS (shown based on active main tab) -->
    <div id="subtabs-main" class="subtabs" style="display:none;">
        <span class="subtab active" onclick="switchSubTab('mainview')">Main View</span>
        <span class="subtab" onclick="switchSubTab('erroranalysis')">Error Analysis</span>
    </div>
    <div id="subtabs-analysis" class="subtabs" style="display:none;">
        <span class="subtab active" onclick="switchSubTab('stats')">Statistics</span>
        <span class="subtab" onclick="switchSubTab('primes')">Primes</span>
        <span class="subtab" onclick="switchSubTab('gaps')">Gaps</span>
    </div>
    <div id="subtabs-theory" class="subtabs" style="display:none;">
        <span class="subtab active" onclick="switchSubTab('theory')">Foundations</span>
        <span class="subtab" onclick="switchSubTab('theoryviz')">Visualizations</span>
    </div>
    <div id="subtabs-geometry" class="subtabs" style="display:none;">
        <span class="subtab active" onclick="switchSubTab('3d')">3D Cone</span>
        <span class="subtab" onclick="switchSubTab('hyperbolic')">Hyperbolic</span>
        <span class="subtab" onclick="switchSubTab('smith')">Smith Chart</span>
    </div>
    <div id="subtabs-connections" class="subtabs" style="display:none;">
        <span class="subtab active" onclick="switchSubTab('franel')">Franel-Landau</span>
        <span class="subtab" onclick="switchSubTab('dedekind')">Dedekind</span>
        <span class="subtab" onclick="switchSubTab('cf')">Cont. Fractions</span>
        <span class="subtab" onclick="switchSubTab('euler')">Euler Product</span>
        <span class="subtab" onclick="switchSubTab('harmonic')">Harmonic</span>
    </div>
    <div id="subtabs-advanced" class="subtabs" style="display:none;">
        <span class="subtab active" onclick="switchSubTab('modular')">Modular</span>
        <span class="subtab" onclick="switchSubTab('psl')">PSL(2,Z)</span>
        <span class="subtab" onclick="switchSubTab('primorial')">Primorial</span>
        <span class="subtab" onclick="switchSubTab('numtheory')">NumTheory</span>
        <span class="subtab" onclick="switchSubTab('horizon')">Horizon</span>
        <span class="subtab" onclick="switchSubTab('animation')">Animation</span>
        <span class="subtab" onclick="switchSubTab('research')">Research</span>
    </div>
    
    <!-- MAIN TAB - MAIN VIEW -->
    <div id="tab-mainview" class="tab-content active">
        <!-- Hero Formula Banner -->
        <div style="background:linear-gradient(135deg,#1e1b4b,#312e81);padding:12px 20px;border-radius:8px;margin-bottom:15px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:12px;">
            <div>
                <span style="color:#a78bfa;font-size:0.9em;font-weight:500;">Farey Sector Formula</span>
                <div style="font-family:'Courier New',monospace;font-size:1.4em;color:#f1f5f9;margin-top:4px;">C(n,N) = 3N¬≤ / (œÄ¬≤ n(n+1))</div>
            </div>
            <div style="display:flex;gap:8px;align-items:center;">
                <span style="color:#64748b;font-size:0.8em;">Sector S‚Çô = (1/(n+1), 1/n]</span>
            </div>
        </div>
        
        <!-- PROJECTS SIDEBAR TOGGLE -->
        <div style="display:flex;gap:10px;margin-bottom:15px;">
            <button onclick="toggleProjectsSidebar()" style="background:linear-gradient(135deg,#f59e0b,#d97706);border:none;border-radius:6px;color:white;padding:8px 16px;cursor:pointer;font-weight:600;font-size:12px;">
                Projects <span id="projectCount" style="background:rgba(0,0,0,0.3);padding:2px 8px;border-radius:10px;margin-left:6px;">0</span>
            </button>
            <button onclick="quickSaveCurrentState()" class="secondary" style="padding:8px 16px;font-size:12px;">Quick Save</button>
            <button onclick="loadLastSession()" class="secondary" style="padding:8px 16px;font-size:12px;">Load Last</button>
        </div>
        
        <!-- Key Stats - 6 essential metrics -->
        <div id="mainStats" class="stat-grid" style="margin-bottom:15px;"></div>
        
        <!-- Main Controls Row -->
        <div style="display:flex;gap:15px;margin-bottom:15px;flex-wrap:wrap;">
            <div class="panel" style="flex:1;min-width:300px;padding:12px;">
                <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center;">
                    <label style="font-size:12px;">Sector: <select id="viewSector" onchange="state.highlightSectorOnly=null;drawMainRing();updateSectorStats(+this.value,state.residuesBySector[+this.value]||[]);updateSectorPointCount()">
                        <option value="1">1</option><option value="2" selected>2</option><option value="3">3</option>
                    </select></label>
                    <label style="font-size:12px;">Color: <select id="colorMode" onchange="drawMainRing()" style="padding:4px;">
                        <option value="sector">Sector</option>
                        <option value="prime">Prime/Composite</option>
                        <option value="denominator">Denominator</option>
                        <option value="harmonic">Harmonic</option>
                        <option value="rainbow">Rainbow</option>
                    </select></label>
                    <label style="font-size:12px;"><input type="checkbox" id="showAllSectors" checked onchange="state.highlightSectorOnly=null;drawMainRing()"> All Sectors</label>
                    <label style="font-size:12px;">Size: <input type="number" id="ringPointSize" min="0" max="100" value="5" step="0.5" style="width:65px;font-size:11px;" onchange="drawMainRing();updatePtSizeDisplay()"><span id="ptSizeDisplay" style="color:#6366f1;margin-left:4px;font-size:11px;">5</span></label>
                    <button onclick="setPointSize(0)" class="secondary" style="font-size:10px;padding:3px 6px;">Auto</button>
                    <button onclick="setPointSize(1)" class="secondary" style="font-size:10px;padding:3px 6px;">1</button>
                    <button onclick="setPointSize(3)" class="secondary" style="font-size:10px;padding:3px 6px;">3</button>
                    <button onclick="setPointSize(5)" class="secondary" style="font-size:10px;padding:3px 6px;">5</button>
                    <button onclick="setPointSize(8)" class="secondary" style="font-size:10px;padding:3px 6px;">8</button>
                    <label style="font-size:12px;margin-left:8px;">Spacing: <input type="number" id="ringSpacing" min="1" max="10" value="2" step="0.1" style="width:50px;font-size:11px;" onchange="drawMainRing()" title="Ring spacing multiplier"></label>
                    <label style="font-size:12px;margin-left:10px;">Canvas: <select id="ringCanvasSize" onchange="resizeRingCanvas()" style="padding:3px 6px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;font-size:11px;">
                        <option value="800">800x800</option>
                        <option value="1024">1K (1024x1024)</option>
                        <option value="2048">2K (2048x2048)</option>
                        <option value="4096" selected>4K (4096x4096)</option>
                    </select></label>
                </div>
            </div>
            <div style="display:flex;gap:8px;">
                <button onclick="toggleAdvancedControls()" class="secondary" style="padding:8px 12px;">Advanced ‚ñº</button>
                <button onclick="screenshotMainCanvas()" class="secondary" style="padding:8px 12px;">Screenshot</button>
            </div>
        </div>
        
        <!-- Advanced Controls (collapsed by default) -->
        <div id="advancedControlsPanel" style="display:none;margin-bottom:15px;">
            <div class="panel" style="background:#0f172a;border:1px solid #334155;">
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:12px;">
                    <!-- Rotation Controls -->
                    <div style="padding:12px;background:rgba(255,215,0,0.05);border-radius:6px;border:1px solid rgba(255,215,0,0.2);">
                        <strong style="color:#ffd700;font-size:11px;display:block;margin-bottom:10px;">Per-Ring Rotation</strong>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;">
                            <label style="font-size:11px;"><input type="checkbox" id="enableRingRotation" onchange="drawMainRing()"> Enable</label>
                            <label style="font-size:11px;">ŒîŒ∏: <input type="range" id="ringRotationAmount" min="0" max="360" value="0" step="0.5" style="width:80px;vertical-align:middle;" oninput="updateRotationFromSlider()"><span id="rotationAmountV" style="color:#ffd700;margin-left:4px;">0¬∞</span></label>
                            <label style="font-size:11px;">a/b: <input type="text" id="ringRotationFrac" value="0/1" style="width:50px;font-size:10px;padding:2px;background:#1e293b;border:1px solid #475569;color:#ffd700;border-radius:3px;text-align:center;" onchange="updateRotationFromFrac()"></label>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
                            <label style="font-size:11px;"><input type="checkbox" id="rotationCumulative" checked onchange="drawMainRing()"> Cumulative</label>
                            <label style="font-size:11px;">Phase: <input type="number" id="ringGlobalPhase" value="0" min="-360" max="360" step="1" style="width:50px;font-size:10px;padding:2px;" onchange="drawMainRing()">¬∞</label>
                            <button onclick="setRotationPreset(137.5078,'1/œÜ¬≤')" class="secondary" style="font-size:9px;padding:2px 6px;" title="Golden angle">œÜ</button>
                            <button onclick="setRotationPreset(60,'1/6')" class="secondary" style="font-size:9px;padding:2px 6px;">60¬∞</button>
                            <button onclick="setRotationPreset(90,'1/4')" class="secondary" style="font-size:9px;padding:2px 6px;">90¬∞</button>
                            <button onclick="setRotationPreset(120,'1/3')" class="secondary" style="font-size:9px;padding:2px 6px;">120¬∞</button>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,215,0,0.2);">
                            <button onclick="startRingRotation('cw')" style="background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;padding:4px 8px;cursor:pointer;font-size:10px;">‚ñ∂ CW</button>
                            <button onclick="startRingRotation('ccw')" style="background:linear-gradient(135deg,#16a34a,#15803d);border:none;border-radius:4px;color:white;padding:4px 8px;cursor:pointer;font-size:10px;">‚ñ∂ CCW</button>
                            <button onclick="stopRingRotation()" style="background:#ef4444;border:none;border-radius:4px;color:white;padding:4px 8px;cursor:pointer;font-size:10px;">‚ñ†</button>
                            <select id="ringRotationSpeed" style="padding:2px 4px;font-size:9px;background:#0f172a;border:1px solid #ffd700;border-radius:3px;color:#e2e8f0;">
                                <option value="0.5">Slow</option>
                                <option value="1" selected>Med</option>
                                <option value="2">Fast</option>
                            </select>
                            <select id="ringRotationMode" style="padding:2px 4px;font-size:9px;background:#0f172a;border:1px solid #ffd700;border-radius:3px;color:#e2e8f0;">
                                <option value="cumulative" selected>Cumul</option>
                                <option value="uniform">Uniform</option>
                                <option value="alternate">Alt</option>
                            </select>
                            <span id="ringRotationPhase" style="color:#ffd700;font-family:monospace;font-size:10px;">0¬∞</span>
                        </div>
                    </div>
                    
                    <!-- Sector Analysis -->
                    <div style="padding:12px;background:rgba(150,100,255,0.05);border-radius:6px;border:1px solid rgba(150,100,255,0.2);">
                        <strong style="color:#9664ff;font-size:11px;display:block;margin-bottom:10px;">Sector Analysis</strong>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;">
                            <label style="font-size:11px;"><input type="checkbox" id="showSectorBounds" onchange="drawMainRing()"> Bounds</label>
                            <label style="font-size:11px;"><input type="checkbox" id="showMedianLine" onchange="drawMainRing()"> Median</label>
                            <label style="font-size:11px;"><input type="checkbox" id="dimOutsideSector" onchange="drawMainRing()"> Dim Outside</label>
                            <label style="font-size:11px;"><input type="checkbox" id="highlightPrimeRings" onchange="drawMainRing()"> Prime Rings</label>
                        </div>
                    </div>
                    
                    <!-- Residue Tracker -->
                    <div style="padding:12px;background:rgba(0,255,255,0.05);border-radius:6px;border:1px solid rgba(0,255,255,0.2);">
                        <strong style="color:#00ffff;font-size:11px;display:block;margin-bottom:10px;">Residue Tracker</strong>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;">
                            <label style="font-size:11px;"><input type="checkbox" id="enableResidueTracker" onchange="drawMainRing()"> Enable</label>
                            <input type="text" id="trackResidues" placeholder="1,5,7 or 1-10" style="width:90px;font-size:10px;padding:4px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;" onchange="drawMainRing()">
                            <input type="color" id="trackerColor" value="#00ffff" style="width:28px;height:24px;border:none;cursor:pointer;" onchange="drawMainRing()">
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;">
                            <label style="font-size:11px;"><input type="checkbox" id="trackerGlow" onchange="drawMainRing()"> Glow</label>
                            <label style="font-size:11px;"><input type="checkbox" id="trackerConnect" onchange="drawMainRing()"> Connect</label>
                            <label style="font-size:11px;">Size: <input type="number" id="trackerSize" value="8" min="1" max="30" step="0.5" style="width:45px;font-size:10px;padding:2px;" onchange="drawMainRing()"></label>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;align-items:center;">
                            <label style="font-size:11px;">Filter: <select id="trackerModFilter" onchange="applyTrackerFilter()" style="font-size:10px;padding:2px;background:#1e293b;border:1px solid #475569;color:#e2e8f0;">
                                <option value="">None</option>
                                <option value="prime">Primes only</option>
                                <option value="composite">Composites only</option>
                                <option value="mod2_1">m‚â°1 (mod 2)</option>
                                <option value="mod3_1">m‚â°1 (mod 3)</option>
                                <option value="mod6_1">m‚â°1 (mod 6)</option>
                            </select></label>
                            <button onclick="clearTracker()" class="secondary" style="font-size:9px;padding:3px 8px;">Clear</button>
                        </div>
                        <input type="hidden" id="trackerMode" value="manual">
                        <input type="hidden" id="trackerSliderR" value="1">
                    </div>
                    
                    <!-- Display Options -->
                    <div style="padding:12px;background:rgba(99,102,241,0.05);border-radius:6px;border:1px solid rgba(99,102,241,0.2);">
                        <strong style="color:#6366f1;font-size:11px;display:block;margin-bottom:10px;">Display Options</strong>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;">
                            <label style="font-size:11px;"><input type="checkbox" id="invertRingOrder" onchange="drawMainRing()"> Invert Order</label>
                            <label style="font-size:11px;"><input type="checkbox" id="showRingLabels" onchange="drawMainRing()"> Ring Labels</label>
                            <label style="font-size:11px;"><input type="checkbox" id="showAllSectorLines" onchange="drawMainRing()"> All 1/n Lines</label>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
                            <label style="font-size:11px;"><input type="checkbox" id="showFractionLabels" onchange="drawMainRing()"> Point Labels</label>
                            <label style="font-size:11px;"><input type="checkbox" id="antialiasRing" checked onchange="drawMainRing()"> Antialias</label>
                            <label style="font-size:11px;">BG: <input type="color" id="ringBgColor" value="#0f172a" style="width:28px;height:20px;border:none;cursor:pointer;" onchange="drawMainRing()"></label>
                        </div>
                    </div>
                    
                    <!-- Filtering -->
                    <div style="padding:12px;background:rgba(34,197,94,0.05);border-radius:6px;border:1px solid rgba(34,197,94,0.2);">
                        <strong style="color:#22c55e;font-size:11px;display:block;margin-bottom:10px;">Filtering</strong>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;">
                            <label style="font-size:11px;">Show: <select id="pointFilter" onchange="drawMainRing()" style="font-size:10px;padding:2px;background:#1e293b;border:1px solid #475569;color:#e2e8f0;">
                                <option value="all">All Points</option>
                                <option value="prime_denom">Prime Denom</option>
                                <option value="composite_denom">Composite Denom</option>
                                <option value="prime_num">Prime Numerator</option>
                                <option value="twin_prime">Twin Prime Denom</option>
                            </select></label>
                            <label style="font-size:11px;">Min m: <input type="number" id="minDenomFilter" value="2" min="2" max="1000" style="width:55px;font-size:10px;padding:2px;" onchange="drawMainRing()"></label>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
                            <label style="font-size:11px;">Max m: <input type="number" id="maxDenomFilter" value="" placeholder="‚àû" min="2" style="width:55px;font-size:10px;padding:2px;" onchange="drawMainRing()"></label>
                            <label style="font-size:11px;"><input type="checkbox" id="hideSmallDenom" onchange="drawMainRing()"> Hide m‚â§5</label>
                            <button onclick="resetFilters()" class="secondary" style="font-size:9px;padding:3px 8px;">Reset</button>
                        </div>
                    </div>
                    
                    <!-- Animation -->
                    <div style="padding:12px;background:rgba(239,68,68,0.05);border-radius:6px;border:1px solid rgba(239,68,68,0.2);">
                        <strong style="color:#ef4444;font-size:11px;display:block;margin-bottom:10px;">Animation</strong>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-bottom:8px;">
                            <button onclick="startRingAnimation()" id="ringAnimBtn" style="font-size:10px;padding:4px 10px;background:linear-gradient(135deg,#ef4444,#dc2626);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ Animate</button>
                            <button onclick="stopRingAnimation()" class="secondary" style="font-size:10px;padding:4px 10px;">‚ñ† Stop</button>
                            <label style="font-size:11px;">Speed: <input type="range" id="ringAnimSpeed" min="1" max="100" value="30" style="width:60px;vertical-align:middle;"></label>
                        </div>
                        <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
                            <label style="font-size:11px;">Mode: <select id="ringAnimMode" style="font-size:10px;padding:2px;background:#1e293b;border:1px solid #475569;color:#e2e8f0;">
                                <option value="rotation">Rotate</option>
                                <option value="growth">Growth</option>
                                <option value="pulse">Pulse</option>
                                <option value="wave">Wave</option>
                            </select></label>
                            <label style="font-size:11px;"><input type="checkbox" id="ringAnimLoop" checked> Loop</label>
                        </div>
                    </div>
                </div>
                <input type="hidden" id="sectorColorMode" value="preserve">
            </div>
        </div>
        
        <!-- Ring Visualization (Hero) -->
        <div class="panel" style="text-align:center;padding:15px;position:relative;">
            <!-- Zoom Controls -->
            <div style="position:absolute;top:10px;right:10px;display:flex;gap:4px;z-index:10;background:rgba(15,23,42,0.9);padding:6px 10px;border-radius:6px;border:1px solid #334155;">
                <button onclick="zoomRing(-0.25)" class="secondary" style="padding:4px 10px;font-size:14px;font-weight:bold;">‚àí</button>
                <span id="ringZoomLevel" style="color:#8b5cf6;font-weight:bold;min-width:50px;text-align:center;line-height:28px;">100%</span>
                <button onclick="zoomRing(0.25)" class="secondary" style="padding:4px 10px;font-size:14px;font-weight:bold;">+</button>
                <button onclick="resetRingZoom()" class="secondary" style="padding:4px 10px;font-size:11px;">Reset</button>
                <button onclick="zoomRing(1)" class="secondary" style="padding:4px 8px;font-size:10px;" title="2x zoom">2x</button>
                <button onclick="zoomRing(3)" class="secondary" style="padding:4px 8px;font-size:10px;" title="4x zoom">4x</button>
            </div>
            
            <!-- Pan hint -->
            <div id="panHint" style="display:none;position:absolute;top:10px;left:10px;background:rgba(139,92,246,0.9);padding:4px 10px;border-radius:4px;font-size:11px;color:white;z-index:10;">
                Drag to pan ‚Ä¢ Scroll to zoom
            </div>
            
            <div style="overflow:hidden;position:relative;" id="ringContainer">
                <canvas id="mainRing" class="ring-canvas" width="800" height="800" style="max-width:100%;cursor:grab;"></canvas>
            </div>
            <div class="point-tooltip" id="pointTooltip"></div>
            
            <!-- Point Selector & Playback Controls -->
            <div style="display:flex;justify-content:center;gap:10px;margin-top:12px;flex-wrap:wrap;align-items:center;">
                <div style="display:flex;align-items:center;gap:6px;background:#1e293b;padding:6px 10px;border-radius:6px;border:1px solid #334155;">
                    <label style="font-size:11px;color:#94a3b8;">Select:</label>
                    <input type="text" id="pointSelectInput" placeholder="a/b" style="width:60px;padding:4px 6px;font-size:12px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#22c55e;text-align:center;font-family:monospace;" onkeydown="if(event.key==='Enter')selectPointByFraction()">
                    <button onclick="selectPointByFraction()" style="padding:4px 8px;font-size:11px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;">Go</button>
                </div>
                <button style="background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;padding:6px 12px;cursor:pointer;" onclick="playSectorSequence('forward')">‚ñ∂ Play Sector</button>
                <button class="secondary" onclick="stopAllPlayback()" style="padding:6px 12px;">‚ñ† Stop</button>
                <button class="secondary" onclick="openSectorModal(+document.getElementById('viewSector').value)" style="padding:6px 12px;">View Details</button>
                <button class="secondary" onclick="exportRingHiRes()" style="padding:6px 12px;">Export Ring</button>
            </div>
            
            <!-- Sector Range Playback Controls -->
            <div style="margin-top:8px;display:flex;align-items:center;gap:10px;flex-wrap:wrap;padding:8px 12px;background:#0d3320;border-radius:6px;border:1px solid #22c55e;">
                <span style="color:#86efac;font-size:11px;font-weight:600;">Play Range:</span>
                <select id="sectorRangeMode" onchange="updateSectorRangeInputs()" style="padding:3px 6px;font-size:10px;background:#0f172a;border:1px solid #22c55e;border-radius:3px;color:#e2e8f0;">
                    <option value="all">All Points</option>
                    <option value="first">First N</option>
                    <option value="last">Last N</option>
                    <option value="range">Custom Range</option>
                </select>
                <div id="sectorRangeInputs" style="display:none;align-items:center;gap:6px;">
                    <input type="number" id="sectorRangeStart" placeholder="Start" min="1" value="1" style="width:65px;padding:3px 6px;font-size:10px;background:#0f172a;border:1px solid #22c55e;border-radius:3px;color:#e2e8f0;">
                    <span style="color:#86efac;font-size:10px;">to</span>
                    <input type="number" id="sectorRangeEnd" placeholder="End" min="1" value="100" style="width:65px;padding:3px 6px;font-size:10px;background:#0f172a;border:1px solid #22c55e;border-radius:3px;color:#e2e8f0;">
                </div>
                <select id="sectorRangeN" style="display:none;padding:3px 6px;font-size:10px;background:#0f172a;border:1px solid #22c55e;border-radius:3px;color:#e2e8f0;">
                    <option value="10">10 points</option>
                    <option value="50">50 points</option>
                    <option value="100" selected>100 points</option>
                    <option value="250">250 points</option>
                    <option value="500">500 points</option>
                    <option value="1000">1000 points</option>
                    <option value="5000">5000 points</option>
                </select>
                <span style="color:#86efac;font-size:10px;">Total: <span id="sectorPointCount" style="color:#fbbf24;font-family:monospace;">-</span></span>
                <span style="color:#86efac;font-size:10px;margin-left:8px;">Speed:</span>
                <input type="number" id="playbackSpeed" min="50" max="2000" value="250" step="50" style="width:60px;padding:3px 6px;font-size:10px;background:#0f172a;border:1px solid #22c55e;border-radius:3px;color:#e2e8f0;text-align:center;" title="ms per note">
                <span style="color:#64748b;font-size:9px;">ms</span>
            </div>
            
            <!-- Ring Loop Playback Controls -->
            <div style="margin-top:8px;display:flex;align-items:center;gap:10px;flex-wrap:wrap;padding:8px 12px;background:#1e1b4b;border-radius:6px;border:1px solid #6366f1;">
                <span style="color:#a5b4fc;font-size:11px;font-weight:600;">Ring Loop:</span>
                <button onclick="playRingLoop('forward')" style="background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;padding:5px 10px;cursor:pointer;font-size:11px;">‚ñ∂ Forward</button>
                <button onclick="playRingLoop('backward')" style="background:linear-gradient(135deg,#8b5cf6,#a78bfa);border:none;border-radius:4px;color:white;padding:5px 10px;cursor:pointer;font-size:11px;">‚óÄ Backward</button>
                <button onclick="stopRingLoop()" style="background:#ef4444;border:none;border-radius:4px;color:white;padding:5px 10px;cursor:pointer;font-size:11px;">‚ñ† Stop</button>
                <label style="color:#a5b4fc;font-size:10px;">Speed:
                    <select id="ringLoopSpeed" style="padding:3px 6px;font-size:10px;background:#0f172a;border:1px solid #6366f1;border-radius:3px;color:#e2e8f0;">
                        <option value="500">Slow</option>
                        <option value="250" selected>Medium</option>
                        <option value="100">Fast</option>
                        <option value="50">Very Fast</option>
                    </select>
                </label>
                <span style="color:#a5b4fc;font-size:10px;">Ring: <span id="ringLoopCurrent" style="color:#fbbf24;font-family:monospace;">-</span></span>
            </div>
            
            <!-- Color Legend -->
            <div class="color-legend" id="colorLegend" style="margin-top:12px;justify-content:center;"></div>
            
            <!-- SOLVER PANEL - Collapsible Dropdown -->
            <div style="margin-top:12px;">
                <div onclick="toggleSolverPanel()" style="background:linear-gradient(135deg,#064e3b,#065f46);border:2px solid #10b981;border-radius:8px 8px 0 0;padding:10px 15px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;">
                    <div style="display:flex;align-items:center;gap:10px;">
                        <span style="color:#6ee7b7;font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;">Target Ratio Solver</span>
                        <span id="solverMatchPreview" style="color:#f0fdf4;font-family:monospace;font-size:13px;"></span>
                    </div>
                    <span id="solverArrow" style="color:#6ee7b7;font-size:14px;transition:transform 0.3s;">‚ñº</span>
                </div>
                <div id="solverPanel" style="display:none;background:linear-gradient(135deg,#064e3b,#065f46);border:2px solid #10b981;border-top:none;border-radius:0 0 8px 8px;padding:15px;">
                    <div style="display:flex;align-items:center;gap:15px;flex-wrap:wrap;">
                        <div style="flex:1;min-width:200px;">
                            <div style="display:flex;gap:8px;">
                                <input type="text" id="solverInput" placeholder="Enter decimal (e.g. 0.3183)" 
                                    style="flex:1;padding:10px 14px;font-size:16px;font-family:monospace;background:#0f172a;border:2px solid #10b981;border-radius:6px;color:#f0fdf4;outline:none;"
                                    oninput="solverSearch(this.value)" onkeydown="if(event.key==='Enter')solverSearch(this.value)">
                                <button onclick="solverSearch(document.getElementById('solverInput').value)" 
                                    style="background:linear-gradient(135deg,#10b981,#059669);border:none;border-radius:6px;color:white;padding:10px 20px;cursor:pointer;font-weight:600;">
                                    Find
                                </button>
                            </div>
                        </div>
                        <div style="display:flex;gap:15px;align-items:center;">
                            <div>
                                <label style="color:#6ee7b7;font-size:10px;">Tolerance</label>
                                <select id="solverTolerance" style="display:block;margin-top:4px;padding:6px 10px;background:#0f172a;border:1px solid #10b981;border-radius:4px;color:#e2e8f0;font-size:12px;">
                                    <option value="0.00000001">¬±0.00000001</option>
                                    <option value="0.0000001">¬±0.0000001</option>
                                    <option value="0.000001">¬±0.000001</option>
                                    <option value="0.00001">¬±0.00001</option>
                                    <option value="0.0001">¬±0.0001</option>
                                    <option value="0.001">¬±0.001</option>
                                    <option value="0.01" selected>¬±0.01</option>
                                    <option value="0.05">¬±0.05</option>
                                    <option value="0.1">¬±0.1</option>
                                    <option value="0.2">¬±0.2</option>
                                    <option value="0.5">¬±0.5</option>
                                    <option value="1.0">¬±1.0</option>
                                </select>
                            </div>
                            <div>
                                <label style="color:#6ee7b7;font-size:10px;">Max Denom</label>
                                <select id="solverMaxDenom" style="display:block;margin-top:4px;padding:6px 10px;background:#0f172a;border:1px solid #10b981;border-radius:4px;color:#e2e8f0;font-size:12px;">
                                    <option value="100">100</option>
                                    <option value="500" selected>500</option>
                                    <option value="1000">1,000</option>
                                    <option value="5000">5,000</option>
                                    <option value="10000">10,000</option>
                                    <option value="50000">50,000</option>
                                    <option value="100000">100,000</option>
                                </select>
                            </div>
                            <div>
                                <label style="color:#6ee7b7;font-size:10px;">Point Size</label>
                                <input type="number" id="solverPointSize" min="0.5" max="20" value="5" step="0.5" style="display:block;margin-top:4px;width:60px;padding:6px 10px;background:#0f172a;border:1px solid #10b981;border-radius:4px;color:#e2e8f0;font-size:12px;">
                            </div>
                        </div>
                    </div>
                    <!-- Solver Results -->
                    <div id="solverResults" style="display:none;margin-top:15px;padding:15px;background:#0f172a;border-radius:8px;border:1px solid #10b981;">
                        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;">
                            <div class="solver-result-item">
                                <div style="color:#6ee7b7;font-size:10px;text-transform:uppercase;">Best Match</div>
                                <div id="solverBestFrac" style="font-size:28px;font-weight:bold;color:#f0fdf4;font-family:monospace;">-</div>
                            </div>
                            <div class="solver-result-item">
                                <div style="color:#6ee7b7;font-size:10px;text-transform:uppercase;">Decimal Value</div>
                                <div id="solverBestDecimal" style="font-size:18px;color:#a7f3d0;font-family:monospace;">-</div>
                            </div>
                            <div class="solver-result-item">
                                <div style="color:#6ee7b7;font-size:10px;text-transform:uppercase;">Error</div>
                                <div id="solverError" style="font-size:18px;color:#fbbf24;font-family:monospace;">-</div>
                            </div>
                            <div class="solver-result-item">
                                <div style="color:#6ee7b7;font-size:10px;text-transform:uppercase;">Sector</div>
                                <div id="solverSector" style="font-size:18px;color:#a78bfa;font-family:monospace;">-</div>
                            </div>
                            <div class="solver-result-item">
                                <div style="color:#6ee7b7;font-size:10px;text-transform:uppercase;">Category</div>
                                <div id="solverCategory" style="font-size:18px;font-family:monospace;">-</div>
                            </div>
                            <div class="solver-result-item">
                                <div style="color:#6ee7b7;font-size:10px;text-transform:uppercase;">Denom Type</div>
                                <div id="solverDenomType" style="font-size:18px;font-family:monospace;">-</div>
                            </div>
                            <div class="solver-result-item">
                                <div style="color:#6ee7b7;font-size:10px;text-transform:uppercase;">Continued Fraction</div>
                                <div id="solverCF" style="font-size:14px;color:#94a3b8;font-family:monospace;word-break:break-all;">-</div>
                            </div>
                            <div class="solver-result-item">
                                <div style="color:#6ee7b7;font-size:10px;text-transform:uppercase;">Gear Ratio</div>
                                <div id="solverGear" style="font-size:14px;color:#f472b6;font-family:monospace;">-</div>
                            </div>
                            <div class="solver-result-item">
                                <div style="color:#6ee7b7;font-size:10px;text-transform:uppercase;">Path</div>
                                <div id="solverPath" style="font-size:12px;color:#94a3b8;font-family:monospace;word-break:break-all;">-</div>
                            </div>
                        </div>
                        <div style="margin-top:15px;display:flex;gap:10px;flex-wrap:wrap;">
                            <button onclick="solverHighlightOnRing()" style="background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;padding:8px 16px;cursor:pointer;font-size:12px;">View on Ring</button>
                            <button onclick="solverPlayFraction()" style="background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;padding:8px 16px;cursor:pointer;font-size:12px;">Play Sound</button>
                            <button onclick="solverPlayPath('forward')" style="background:linear-gradient(135deg,#f59e0b,#d97706);border:none;border-radius:4px;color:white;padding:8px 16px;cursor:pointer;font-size:12px;">‚ñ∂ Path</button>
                            <button onclick="solverPlayPath('backward')" style="background:linear-gradient(135deg,#f59e0b,#d97706);border:none;border-radius:4px;color:white;padding:8px 16px;cursor:pointer;font-size:12px;">‚óÄ Path</button>
                            <button onclick="solverCopyReport()" style="background:#475569;border:none;border-radius:4px;color:white;padding:8px 16px;cursor:pointer;font-size:12px;">Copy Report</button>
                            <button onclick="solverSaveToProject()" style="background:linear-gradient(135deg,#f59e0b,#d97706);border:none;border-radius:4px;color:white;padding:8px 16px;cursor:pointer;font-size:12px;">Save to Project</button>
                        </div>
                        <!-- Alternatives Table -->
                        <div id="solverAlternatives" style="margin-top:15px;max-height:450px;overflow-y:auto;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- WORD ART PANEL - Collapsible -->
        <div style="margin-top:12px;">
            <div onclick="toggleWordArtPanel()" style="background:linear-gradient(135deg,#4c1d95,#5b21b6);border:2px solid #8b5cf6;border-radius:8px 8px 0 0;padding:10px 15px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;">
                <div style="display:flex;align-items:center;gap:10px;">
                    <span style="color:#c4b5fd;font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;">Word Art</span>
                    <span id="wordArtPreview" style="color:#f0fdf4;font-family:monospace;font-size:13px;"></span>
                </div>
                <span id="wordArtArrow" style="color:#c4b5fd;font-size:14px;transition:transform 0.3s;">‚ñº</span>
            </div>
            <div id="wordArtPanel" style="display:none;background:linear-gradient(135deg,#4c1d95,#5b21b6);border:2px solid #8b5cf6;border-top:none;border-radius:0 0 8px 8px;padding:12px;">
                <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
                    <label style="color:#c4b5fd;font-size:11px;"><input type="checkbox" id="wordArtEnabled" onchange="drawMainRing()"> Enable</label>
                    <input type="text" id="wordArtText" value="Wessen" placeholder="Enter text" style="width:100px;padding:6px 10px;font-size:12px;background:#1e1b4b;border:1px solid #8b5cf6;border-radius:4px;color:#f0fdf4;text-align:center;">
                    <button onclick="generateWordArt()" style="background:linear-gradient(135deg,#8b5cf6,#7c3aed);border:none;border-radius:4px;color:white;padding:6px 12px;cursor:pointer;font-size:11px;">Generate</button>
                    <button onclick="playWordArt('forward')" style="background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;padding:6px 12px;cursor:pointer;font-size:11px;">‚ñ∂ Loop</button>
                    <button onclick="playWordArt('backward')" style="background:linear-gradient(135deg,#f59e0b,#d97706);border:none;border-radius:4px;color:white;padding:6px 12px;cursor:pointer;font-size:11px;">‚óÄ Loop</button>
                    <button onclick="stopWordArtPlayback()" style="background:#ef4444;border:none;border-radius:4px;color:white;padding:6px 12px;cursor:pointer;font-size:11px;">‚ñ† Stop</button>
                    <button onclick="clearWordArt()" style="background:#475569;border:none;border-radius:4px;color:white;padding:6px 12px;cursor:pointer;font-size:11px;">Clear</button>
                </div>
                <div style="margin-top:8px;display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
                    <label style="color:#c4b5fd;font-size:11px;">Size: <input type="number" id="wordArtSize" value="3" min="1" max="10" step="0.5" style="width:50px;padding:4px;font-size:11px;background:#1e1b4b;border:1px solid #8b5cf6;border-radius:3px;color:#f0fdf4;" onchange="drawMainRing()"></label>
                    <input type="color" id="wordArtColor" value="#ffd700" style="width:30px;height:24px;border:none;cursor:pointer;" onchange="drawMainRing()">
                    <label style="color:#c4b5fd;font-size:11px;">Sector: <select id="wordArtSector" style="padding:4px;font-size:11px;background:#1e1b4b;border:1px solid #8b5cf6;border-radius:3px;color:#f0fdf4;" onchange="generateWordArt()">
                        <option value="1">S1</option>
                        <option value="2" selected>S2</option>
                        <option value="3">S3</option>
                        <option value="4">S4</option>
                        <option value="5">S5</option>
                        <option value="6">S6</option>
                        <option value="7">S7</option>
                        <option value="8">S8</option>
                        <option value="9">S9</option>
                        <option value="10">S10</option>
                        <option value="15">S15</option>
                        <option value="20">S20</option>
                        <option value="25">S25</option>
                        <option value="30">S30</option>
                        <option value="40">S40</option>
                        <option value="50">S50</option>
                        <option value="75">S75</option>
                        <option value="100">S100</option>
                        <option value="150">S150</option>
                        <option value="200">S200</option>
                        <option value="all">All Sectors</option>
                    </select></label>
                    <span style="font-size:10px;color:#a78bfa;">Points: <span id="wordArtPointCount">0</span></span>
                </div>
                <div style="margin-top:8px;">
                    <label style="color:#c4b5fd;font-size:10px;">Points: </label>
                    <select id="wordArtPointsDropdown" onchange="highlightWordArtPoint(this.value)" style="max-width:300px;padding:4px;font-size:10px;background:#1e1b4b;border:1px solid #8b5cf6;border-radius:3px;color:#f0fdf4;">
                        <option value="">-- Select to highlight --</option>
                    </select>
                </div>
                <div style="margin-top:6px;font-size:9px;color:#a78bfa;">Shift+click on ring to add points manually</div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Exact vs Predicted 
                    <button class="secondary" onclick="playErrorBySector('count')" style="font-size:10px;padding:3px 8px;margin-left:10px;">‚ñ∂ Play</button>
                    <button class="secondary" onclick="exportCountChart()" style="font-size:10px;padding:3px 8px;">Export</button>
                    <button class="secondary" onclick="resetCountChartZoom()" style="font-size:10px;padding:3px 8px;" title="Reset zoom">Reset Zoom</button>
                    <button class="secondary" onclick="zoomCountChart('in')" style="font-size:10px;padding:3px 6px;" title="Zoom in">+</button>
                    <button class="secondary" onclick="zoomCountChart('out')" style="font-size:10px;padding:3px 6px;" title="Zoom out">-</button>
                    <span style="font-size:9px;color:#64748b;margin-left:8px;">Scroll to zoom, drag to pan</span>
                </h4>
                <canvas id="mainCountChart"></canvas>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Relative Error % 
                    <button class="secondary" onclick="playErrorBySector('error')" style="font-size:10px;padding:3px 8px;margin-left:10px;">‚ñ∂ Play All</button>
                    <button class="secondary" onclick="exportErrorChart()" style="font-size:10px;padding:3px 8px;">Export</button>
                    <button id="playSelectedRangeBtn" class="secondary" onclick="playSelectedErrorRange()" style="font-size:10px;padding:3px 8px;display:none;">‚ñ∂ Play Selection</button>
                    <button class="secondary" onclick="clearErrorSelection()" style="font-size:10px;padding:3px 8px;">Clear</button>
                    <button class="secondary" onclick="stopAllPlayback()" style="font-size:10px;padding:3px 8px;">‚ñ†</button>
                    <button class="secondary" onclick="resetErrorChartZoom()" style="font-size:10px;padding:3px 8px;" title="Reset zoom">Reset Zoom</button>
                    <button class="secondary" onclick="zoomErrorChart('in')" style="font-size:10px;padding:3px 6px;" title="Zoom in">+</button>
                    <button class="secondary" onclick="zoomErrorChart('out')" style="font-size:10px;padding:3px 6px;" title="Zoom out">-</button>
                    <span id="errorSelectionInfo" style="font-size:10px;color:#64748b;margin-left:10px;"></span>
                    <span style="font-size:9px;color:#64748b;margin-left:5px;">Scroll to zoom, drag to pan</span>
                </h4>
                <div style="margin-bottom:8px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
                    <label style="color:#94a3b8;font-size:11px;">Click/Selection Mode:</label>
                    <select id="errorPlaybackMode" onchange="updateErrorModeHint()" style="font-size:11px;padding:3px 8px;background:#1e293b;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        <option value="error">Error Magnitude (pitch = error%)</option>
                        <option value="fractions">All Fractions in Sector</option>
                        <option value="representative">Representative Fraction</option>
                    </select>
                    <span style="color:#64748b;font-size:10px;" id="errorModeHint">Higher error ‚Üí higher pitch</span>
                </div>
                <canvas id="mainErrorChart"></canvas>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:10px;">
                <h4 style="margin:0;">Sector Data <span style="font-weight:normal; color:#64748b;">(click row to see details)</span></h4>
                <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                    <label style="font-size:11px;color:#94a3b8;">Decimals: <select id="sectorTableDecimals" onchange="updateMainTable()" style="padding:3px 6px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;font-size:11px;">
                        <option value="0">0</option>
                        <option value="1">1</option>
                        <option value="2" selected>2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                    </select></label>
                    <label style="font-size:11px;color:#94a3b8;"><input type="checkbox" id="showCategoryColumns" checked onchange="updateMainTable()"> Show Categories</label>
                    <button id="playAllSectorsBtn" onclick="playAllSectorsSequentially()" style="padding:5px 12px;font-size:11px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ Play All Sectors</button>
                    <button onclick="stopAllPlayback()" style="padding:5px 8px;font-size:11px;background:#ef4444;border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ† Stop</button>
                    <label style="color:#94a3b8;">View Sector:</label>
                    <select id="sectorDataSelect" onchange="showSectorDataDetail(this.value)" style="padding:5px 10px;background:#1e1b4b;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                        <option value="">-- Select Sector --</option>
                    </select>
                    <button onclick="exportSectorCSV(document.getElementById('sectorDataSelect').value)" class="secondary" style="font-size:11px;">Export Sector CSV</button>
                    <button onclick="exportAllSectorsCSV()" class="secondary" style="font-size:11px;">Export All CSV</button>
                    <button onclick="showSectorExportDialog()" style="padding:5px 10px;font-size:11px;background:linear-gradient(135deg,#8b5cf6,#6366f1);border:none;border-radius:4px;color:white;cursor:pointer;">Export 4K PNG</button>
                </div>
            </div>
            <!-- Category legend -->
            <div id="categoryLegend" style="display:none;margin-bottom:10px;padding:8px 12px;background:#1e1b4b;border-radius:6px;font-size:11px;border:1px solid #334155;">
                <div style="margin-bottom:6px;">
                    <span style="color:#94a3b8;margin-right:8px;"><strong>Columns:</strong></span>
                    <span style="color:#f59e0b;margin-right:12px;">P(m) = Prime denominator count</span>
                    <span style="color:#6366f1;margin-right:12px;">C(m) = Composite denominator count</span>
                    <span style="color:#22c55e;margin-right:12px;">P/C = P(m)/C(m) ratio</span>
                    <span style="color:#a5b4fc;margin-right:12px;">P(r) = Prime numerator count</span>
                </div>
                <div style="margin-bottom:6px;">
                    <span style="color:#94a3b8;margin-right:8px;"><strong>Categories:</strong></span>
                    <span style="color:#22c55e;margin-right:12px;">PP = Both prime (r prime, m prime)</span>
                    <span style="color:#f59e0b;margin-right:12px;">PC = Prime num, Composite denom</span>
                    <span style="color:#6366f1;margin-right:12px;">CP = Composite num, Prime denom</span>
                    <span style="color:#94a3b8;">CC = Both composite</span>
                </div>
                <div style="border-top:1px solid #334155;padding-top:6px;">
                    <span style="color:#94a3b8;margin-right:8px;"><strong>Identities:</strong></span>
                    <span style="color:#e2e8f0;margin-right:15px;">PP + PC + CP + CC = Exact</span>
                    <span style="color:#e2e8f0;margin-right:15px;">P(m) + C(m) = Exact</span>
                    <span style="color:#e2e8f0;margin-right:15px;">P(m) = PP + CP</span>
                    <span style="color:#e2e8f0;margin-right:15px;">C(m) = PC + CC</span>
                    <span style="color:#e2e8f0;">P(r) = PP + PC</span>
                </div>
            </div>
            <div class="table-scroll"><table id="mainTable"><thead><tr id="mainTableHeader"><th>n</th><th>Interval</th><th>Exact</th><th>Pred</th><th>Err%</th><th title="P(m) = Prime denominator count (m is prime: 2,3,5,7,...)">P(m)</th><th title="C(m) = Composite denominator count (m is composite: 4,6,8,9,...)">C(m)</th><th title="P/C = P(m)/C(m) ratio">P/C</th></tr></thead><tbody></tbody></table></div>
            
            <!-- Sector Detail Panel -->
            <div id="sectorDetailPanel" style="display:none;margin-top:15px;background:#0f172a;border-radius:8px;padding:15px;border:1px solid #334155;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:8px;">
                    <div>
                        <h5 style="margin:0;color:#a78bfa;" id="sectorDetailTitle">Sector Details</h5>
                        <div style="margin-top:6px;font-size:12px;">
                            <span style="color:#94a3b8;">P/C Ratio (denom): </span>
                            <span id="sectorPCRatio" style="color:#22c55e;font-family:monospace;font-weight:bold;">-</span>
                        </div>
                    </div>
                    <div style="display:flex;gap:8px;flex-wrap:wrap;">
                        <button onclick="playSectorDetailFractions('primes','forward')" style="padding:4px 10px;font-size:11px;background:linear-gradient(135deg,#f59e0b,#d97706);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ P(m)</button>
                        <button onclick="playSectorDetailFractions('composites','forward')" style="padding:4px 10px;font-size:11px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ C(m)</button>
                        <button onclick="playSectorDetailFractions('PP','forward')" style="padding:4px 10px;font-size:11px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ PP</button>
                        <button onclick="playSectorDetailFractions('all','forward')" style="padding:4px 10px;font-size:11px;background:linear-gradient(135deg,#8b5cf6,#7c3aed);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ All</button>
                        <button onclick="closeSectorDetail()" style="padding:4px 10px;font-size:11px;background:#ef4444;border:none;border-radius:4px;color:white;cursor:pointer;">‚úï Close</button>
                    </div>
                </div>
                
                <!-- Category breakdown stats -->
                <div id="sectorCategoryStats" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:8px;margin-bottom:12px;padding:10px;background:#1e293b;border-radius:6px;">
                    <div style="text-align:center;"><div style="color:#f59e0b;font-size:16px;font-weight:bold;" id="statPrimeM">0</div><div style="font-size:10px;color:#94a3b8;">P(m) Prime denom</div></div>
                    <div style="text-align:center;"><div style="color:#6366f1;font-size:16px;font-weight:bold;" id="statCompM">0</div><div style="font-size:10px;color:#94a3b8;">C(m) Comp denom</div></div>
                    <div style="text-align:center;"><div style="color:#a5b4fc;font-size:16px;font-weight:bold;" id="statPrimeR">0</div><div style="font-size:10px;color:#94a3b8;">P(r) Prime num</div></div>
                    <div style="text-align:center;"><div style="color:#22c55e;font-size:16px;font-weight:bold;" id="statPP">0</div><div style="font-size:10px;color:#94a3b8;">PP Both prime</div></div>
                    <div style="text-align:center;"><div style="color:#f59e0b;font-size:16px;font-weight:bold;" id="statPC">0</div><div style="font-size:10px;color:#94a3b8;">PC P-num C-denom</div></div>
                    <div style="text-align:center;"><div style="color:#6366f1;font-size:16px;font-weight:bold;" id="statCP">0</div><div style="font-size:10px;color:#94a3b8;">CP C-num P-denom</div></div>
                    <div style="text-align:center;"><div style="color:#94a3b8;font-size:16px;font-weight:bold;" id="statCC">0</div><div style="font-size:10px;color:#94a3b8;">CC Both comp</div></div>
                </div>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;">
                    <div>
                        <h6 style="color:#f59e0b;margin:0 0 8px 0;">Prime Denominators (<span id="sectorPrimeCount">0</span>)</h6>
                        <div id="sectorPrimesList" style="background:#1e293b;padding:10px;border-radius:6px;max-height:200px;overflow-y:auto;font-family:monospace;font-size:0.85em;"></div>
                    </div>
                    <div>
                        <h6 style="color:#6366f1;margin:0 0 8px 0;">Composite Denominators (<span id="sectorCompositeCount">0</span>)</h6>
                        <div id="sectorCompositesList" style="background:#1e293b;padding:10px;border-radius:6px;max-height:200px;overflow-y:auto;font-family:monospace;font-size:0.85em;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel chart-wrapper">
            <h4>Sector Tree Path <span style="font-weight:normal; color:#64748b;">(Stern-Brocot navigation - click nodes to play)</span></h4>
            <div class="control-row" style="margin-bottom:8px;background:#1e1b4b;padding:8px 12px;border-radius:6px;border:1px solid #6366f1;">
                <label>View Sector: 
                    <select id="treeSectorFilter" onchange="drawSectorTree()" style="width:120px;">
                        <option value="all">All Sectors</option>
                        <option value="1">Sector 1 (1/2, 1]</option>
                        <option value="2">Sector 2 (1/3, 1/2]</option>
                        <option value="3">Sector 3 (1/4, 1/3]</option>
                        <option value="4">Sector 4 (1/5, 1/4]</option>
                        <option value="5">Sector 5 (1/6, 1/5]</option>
                        <option value="6">Sector 6 (1/7, 1/6]</option>
                        <option value="7">Sector 7 (1/8, 1/7]</option>
                        <option value="8">Sector 8 (1/9, 1/8]</option>
                        <option value="9">Sector 9 (1/10, 1/9]</option>
                        <option value="10">Sector 10 (1/11, 1/10]</option>
                    </select>
                </label>
                <label>Color by: 
                    <select id="treeColorMode" onchange="drawSectorTree()">
                        <option value="default">Default</option>
                        <option value="sector" selected>Sector</option>
                        <option value="prime">Prime/Composite</option>
                        <option value="arnold">Arnold Tongue</option>
                    </select>
                </label>
                <label><input type="checkbox" id="treeHighlightOnly" onchange="drawSectorTree()"> Highlight Only</label>
                <button class="secondary" onclick="playTreeSectorFractions()" style="font-size:11px;">‚ñ∂ Play Sector</button>
            </div>
            <div class="control-row" style="margin-bottom:10px;">
                <label>Tree Depth: <input type="number" id="treeDepth" value="200" min="3" max="500" onchange="drawSectorTree()"></label>
                <label>Point Size: <input type="number" id="treePointSize" value="2" min="0.5" max="20" step="0.5" style="width:60px;" onchange="drawSectorTree()"></label>
                <label>Canvas: <select id="treeCanvasSize" onchange="resizeTreeCanvas()" style="padding:3px 6px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;">
                    <option value="900x500">900x500</option>
                    <option value="1920x1080">1K (1920x1080)</option>
                    <option value="2560x1440">2K (2560x1440)</option>
                    <option value="3840x2160" selected>4K (3840x2160)</option>
                </select></label>
                <label><input type="checkbox" id="showTreeLabels" checked onchange="drawSectorTree()"> Labels</label>
                <label><input type="checkbox" id="showTreeGrid" onchange="drawSectorTree()"> Grid</label>
                <label><input type="checkbox" id="animatePath" checked> Animate</label>
                <label><input type="checkbox" id="zoomToPath" checked> Zoom to Path</label>
                <button class="secondary" onclick="clearTreePath()">Clear Path</button>
            </div>
            <div class="control-row" style="margin-bottom:10px;background:#064e3b;padding:8px 12px;border-radius:6px;border:1px solid #10b981;">
                <span style="color:#6ee7b7;font-size:11px;font-weight:600;margin-right:8px;">Go to Fraction:</span>
                <input type="text" id="treeFractionInput" placeholder="a/b" style="width:80px;padding:5px 8px;background:#0f172a;border:1px solid #10b981;border-radius:4px;color:#f0fdf4;font-family:monospace;text-align:center;">
                <button onclick="goToTreeFraction()" style="background:linear-gradient(135deg,#10b981,#059669);border:none;border-radius:4px;color:white;padding:5px 12px;cursor:pointer;font-size:11px;">Go</button>
                <span style="color:#6ee7b7;font-size:10px;margin-left:10px;">or click ring/tree</span>
            </div>
            <div class="control-row" style="margin-bottom:10px;background:#1e293b;padding:8px 12px;border-radius:6px;border:1px solid #475569;">
                <span style="color:#94a3b8;font-size:11px;margin-right:8px;">Zoom:</span>
                <button class="secondary" onclick="zoomTree('out')" style="padding:4px 10px;font-size:14px;" title="Zoom out (-)">-</button>
                <input type="range" id="treeZoomSlider" min="20" max="500" value="100" style="width:100px;vertical-align:middle;" oninput="setTreeZoomFromSlider(this.value)">
                <button class="secondary" onclick="zoomTree('in')" style="padding:4px 10px;font-size:14px;" title="Zoom in (+)">+</button>
                <span style="font-size:11px;color:#8b5cf6;font-weight:600;min-width:45px;margin-left:5px;"><span id="treeZoomDisplay">100</span>%</span>
                <span style="border-left:1px solid #475569;margin:0 10px;height:20px;"></span>
                <span style="color:#94a3b8;font-size:11px;margin-right:5px;">Pan:</span>
                <button class="secondary" onclick="panTree('left')" style="padding:4px 8px;" title="Pan left">&#8592;</button>
                <button class="secondary" onclick="panTree('up')" style="padding:4px 8px;" title="Pan up">&#8593;</button>
                <button class="secondary" onclick="panTree('down')" style="padding:4px 8px;" title="Pan down">&#8595;</button>
                <button class="secondary" onclick="panTree('right')" style="padding:4px 8px;" title="Pan right">&#8594;</button>
                <button class="secondary" onclick="resetTreeZoom()" style="margin-left:8px;" title="Reset view (Home)">Reset</button>
                <button class="secondary" onclick="fitTreeToView()" title="Fit all nodes in view">Fit</button>
                <span style="font-size:9px;color:#64748b;margin-left:10px;">Scroll=zoom, Drag=pan</span>
            </div>
            <div class="control-row" style="margin-bottom:10px;">
                <button style="background:linear-gradient(135deg,#22c55e,#16a34a);" onclick="playTreePathAudio('forward')" id="treePlayBtn" title="Play path forward">‚ñ∂ Forward</button>
                <button style="background:linear-gradient(135deg,#6366f1,#8b5cf6);" onclick="playTreePathAudio('backward')" title="Play path backward">‚óÄ Backward</button>
                <button class="secondary" onclick="playChordFromPath()" title="Play all as chord">‚ô´ Chord</button>
                <button class="secondary" onclick="stopAllPlayback()">‚ñ† Stop</button>
            </div>
            <div style="text-align:center;position:relative;">
                <canvas id="sectorTreeCanvas" class="ring-canvas" width="900" height="500"></canvas>
            </div>
            <div id="treePathInfo" style="margin-top:10px; padding:10px; background:#0f172a; border-radius:5px; font-family:monospace; font-size:0.9em;">
                <span style="color:#64748b;">Click a point on the ring or tree to see its path and play its frequency</span>
            </div>
            <div class="color-legend">
                <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Tree nodes</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Path to target</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Target fraction</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>L (left)</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>R (right)</div>
                <div class="color-legend-item" style="border-left:1px solid #475569; padding-left:10px;"><strong style="color:#a5b4fc;">Sector Colors:</strong></div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,70%,50%)"></div>S1</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(36,70%,50%)"></div>S2</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(72,70%,50%)"></div>S3</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(108,70%,50%)"></div>S4</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(144,70%,50%)"></div>S5</div>
        </div>
        
        <div style="margin-top:15px; padding:15px; background:#1e293b; border-radius:8px; border:1px solid #334155; text-align:center;">
            <button onclick="screenshotFullTab('mainview')" style="padding:12px 24px; font-size:14px;">Screenshot Full Main Tab</button>
            <button class="secondary" onclick="exportMainTabData()" style="margin-left:10px; padding:12px 24px; font-size:14px;">Export Main Tab Data</button>
        </div>
    </div>
    </div>
    
    <!-- ERROR ANALYSIS TAB -->
    <div id="tab-erroranalysis" class="tab-content">
        <div class="panel">
            <h2 style="color:#a78bfa;margin-bottom:5px;">Error Analysis</h2>
            <p style="color:#94a3b8;font-size:0.9em;margin-bottom:20px;">Analyze the deviation between exact Farey counts and the asymptotic formula C(n,N) = 3N¬≤/(œÄ¬≤n(n+1)). Understanding error structure may reveal connections to the Riemann Hypothesis through the Franel-Landau theorem.</p>
            
            <!-- Range Controls -->
            <div style="background:#1e1b4b;border-radius:8px;padding:15px;margin-bottom:20px;border:1px solid #6366f1;">
                <h4 style="color:#a5b4fc;margin:0 0 12px 0;">Analysis Range</h4>
                <div style="display:flex;flex-wrap:wrap;gap:15px;align-items:center;">
                    <label style="color:#94a3b8;font-size:12px;">Sector Start: 
                        <input type="number" id="errorAnalysisStart" value="1" min="1" style="width:80px;padding:6px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;margin-left:5px;">
                    </label>
                    <label style="color:#94a3b8;font-size:12px;">Sector End: 
                        <input type="number" id="errorAnalysisEnd" value="275" min="1" style="width:80px;padding:6px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;margin-left:5px;">
                    </label>
                    <button onclick="runErrorAnalysis()" style="padding:8px 20px;background:linear-gradient(135deg,#8b5cf6,#6366f1);border:none;border-radius:6px;color:white;cursor:pointer;font-weight:600;">Analyze</button>
                    <button onclick="exportErrorAnalysis()" class="secondary" style="padding:8px 15px;">Export CSV</button>
                    <button onclick="screenshotFullTab('erroranalysis')" class="secondary" style="padding:8px 15px;">Screenshot</button>
                </div>
            </div>
            
            <!-- Description Cards -->
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:15px;margin-bottom:20px;">
                <div style="background:#0f172a;border-radius:8px;padding:15px;border-left:4px solid #22c55e;">
                    <h5 style="color:#22c55e;margin:0 0 8px 0;">RH Connection</h5>
                    <p style="color:#94a3b8;font-size:0.85em;margin:0;">The Franel-Landau theorem states that RH is equivalent to: Œ£|F_N - k/N| = O(N^(1/2+Œµ)). Our sector decomposition may reveal which sectors contribute most to this sum.</p>
                </div>
                <div style="background:#0f172a;border-radius:8px;padding:15px;border-left:4px solid #8b5cf6;">
                    <h5 style="color:#8b5cf6;margin:0 0 8px 0;">Spectral Analysis</h5>
                    <p style="color:#94a3b8;font-size:0.85em;margin:0;">FFT of error sequence may show peaks at frequencies related to imaginary parts of zeta zeros (14.13, 21.02, 25.01...). This would indicate explicit formula structure.</p>
                </div>
                <div style="background:#0f172a;border-radius:8px;padding:15px;border-left:4px solid #f59e0b;">
                    <h5 style="color:#f59e0b;margin:0 0 8px 0;">M√∂bius Function</h5>
                    <p style="color:#94a3b8;font-size:0.85em;margin:0;">Correlation between errors and Œº(n) tests for arithmetic structure. Non-zero correlation suggests prime factorization affects error distribution.</p>
                </div>
            </div>
            
            <!-- Statistics & Charts -->
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:15px;">
                <!-- Statistics -->
                <div style="background:#0f172a;border-radius:8px;padding:15px;border:1px solid #334155;">
                    <h5 style="color:#a78bfa;margin:0 0 12px 0;font-size:13px;">Error Statistics</h5>
                    <div id="errorStats" style="font-family:monospace;font-size:12px;color:#94a3b8;">
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                            <div>Mean: <span id="errMean" style="color:#e2e8f0;">-</span></div>
                            <div>Std Dev: <span id="errStd" style="color:#e2e8f0;">-</span></div>
                            <div>Skewness: <span id="errSkew" style="color:#e2e8f0;">-</span></div>
                            <div>Kurtosis: <span id="errKurt" style="color:#e2e8f0;">-</span></div>
                        </div>
                        <div style="margin-top:10px;padding-top:10px;border-top:1px solid #334155;">
                            <div>Prime sectors mean: <span id="errPrimeMean" style="color:#22c55e;">-</span></div>
                            <div>Composite sectors mean: <span id="errCompMean" style="color:#6366f1;">-</span></div>
                            <div style="margin-top:6px;font-weight:600;">M√∂bius correlation: <span id="errMobiusCorr" style="color:#f59e0b;">-</span></div>
                        </div>
                    </div>
                </div>
                
                <!-- Autocorrelation -->
                <div style="background:#0f172a;border-radius:8px;padding:15px;border:1px solid #334155;">
                    <h5 style="color:#a78bfa;margin:0 0 12px 0;font-size:13px;">Autocorrelation (lag 1-20)
                        <span style="font-weight:normal;color:#64748b;font-size:10px;margin-left:5px;">Red = significant</span>
                    </h5>
                    <canvas id="autocorrChart" height="120"></canvas>
                </div>
                
                <!-- Power Spectrum -->
                <div style="background:#0f172a;border-radius:8px;padding:15px;border:1px solid #334155;">
                    <h5 style="color:#a78bfa;margin:0 0 12px 0;font-size:13px;">Power Spectrum (FFT)
                        <span style="font-weight:normal;color:#64748b;font-size:10px;margin-left:5px;">peaks ‚Üí zeta zeros?</span>
                    </h5>
                    <canvas id="fftChart" height="120"></canvas>
                </div>
                
                <!-- Error Distribution -->
                <div style="background:#0f172a;border-radius:8px;padding:15px;border:1px solid #334155;">
                    <h5 style="color:#a78bfa;margin:0 0 12px 0;font-size:13px;">Error Distribution</h5>
                    <canvas id="errorHistChart" height="120"></canvas>
                </div>
                
                <!-- Prime vs Composite Sectors -->
                <div style="background:#0f172a;border-radius:8px;padding:15px;border:1px solid #334155;">
                    <h5 style="color:#a78bfa;margin:0 0 12px 0;font-size:13px;">Prime vs Composite Sector Errors</h5>
                    <canvas id="primeCompErrorChart" height="120"></canvas>
                </div>
                
                <!-- Cumulative Error -->
                <div style="background:#0f172a;border-radius:8px;padding:15px;border:1px solid #334155;">
                    <h5 style="color:#a78bfa;margin:0 0 12px 0;font-size:13px;">Cumulative |Error|
                        <span style="font-weight:normal;color:#64748b;font-size:10px;margin-left:5px;">growth rate ‚Üí RH bound</span>
                    </h5>
                    <canvas id="cumulativeErrorChart" height="120"></canvas>
                </div>
            </div>
            
            <!-- Spectral Peaks Table -->
            <div style="margin-top:15px;background:#0f172a;border-radius:8px;padding:15px;border:1px solid #334155;">
                <h5 style="color:#a78bfa;margin:0 0 12px 0;font-size:13px;">Dominant Spectral Peaks
                    <span style="font-weight:normal;color:#64748b;font-size:11px;margin-left:10px;">Compare with Im(œÅ_k): 14.135, 21.022, 25.011, 30.425, 32.935, 37.586, 40.919, 43.327</span>
                </h5>
                <div id="spectralPeaksTable" style="font-family:monospace;font-size:12px;color:#94a3b8;"></div>
            </div>
        </div>
    </div>
    
    <!-- THEORY TAB -->
    <div id="tab-theory" class="tab-content">
        <div class="panel">
            <h2 style="text-align:center; font-size:1.3em; margin-bottom:8px;">Directional Density of Coprime Lattice Points in Farey Sectors</h2>
            <p style="text-align:center; color:#94a3b8; font-style:italic; margin-bottom:20px;">Wessen Getachew</p>
            
            <div class="theorem-box" style="background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%); border-left-color: #8b5cf6;">
                <h4 style="color:#e0e7ff; margin-top:0;">Abstract</h4>
                <p style="margin:0; font-size:0.95em;">We study the distribution of coprime integer pairs (a,b) with bounded height whose rational slope lies in a fixed Farey sector S_n = (1/(n+1), 1/n]. Using classical summatory totient estimates together with a geometric decomposition of rational directions, we derive an explicit asymptotic formula for the number of primitive lattice points in each sector. This result provides a localized refinement of the global coprime density 1/zeta(2), revealing directional structure in the distribution of visible lattice points.</p>
            </div>
            
            <h3 style="margin-top:20px;">1. Introduction and Motivation</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #f59e0b; margin:10px 0;">
                <p>The probability that two randomly chosen integers are coprime is 1/zeta(2) = 6/pi^2 approximately 0.6079, a classical result with interpretations in analytic number theory and geometry of numbers. Geometrically, this corresponds to the density of visible lattice points in Z^2.</p>
                <p style="margin-top:8px;">Farey sequences organize rational numbers in [0,1] by increasing denominator and naturally partition rational directions into intervals. While global coprime density is well understood, we focus on <strong>directional coprime density</strong> - how primitive lattice points distribute across specific rational slope bands.</p>
            </div>
            
            <h3 style="margin-top:20px;">2. Definitions</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Farey Sector</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        S_n = (1/(n+1), 1/n]
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Intervals partitioning (0,1], bounded by consecutive Farey fractions.</p>
                </div>
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Primitive Lattice Point</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        (a,b) in Z^2 where gcd(a,b) = 1, b >= 1
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Pairs with coprime coordinates representing visible lattice points.</p>
                </div>
            </div>
            
            <h3>3. Main Result</h3>
            <div class="derivation-box" style="background: linear-gradient(135deg, #422006 0%, #5a3a1a 100%); border-left-color: #fbbf24;">
                <strong style="color:#fcd34d; font-size:1.1em;">Farey Sector Density Theorem</strong>
                <p style="margin:12px 0 0 0;">Let n be fixed. As N approaches infinity, the number of coprime integer pairs with slope in the Farey sector S_n satisfies:</p>
                <div style="background:#0f172a; padding:12px; border-radius:5px; font-family:monospace; font-size:1em; margin:10px 0; text-align:center;">
                    <strong>C(n,N) ~ (3/pi^2) * N^2 / (n(n+1))</strong>
                </div>
                <p style="margin:10px 0 0 0; font-size:0.9em;">Where C(n,N) counts pairs (a,b) with 1 <= b <= N, gcd(a,b)=1, and a/b in S_n.</p>
            </div>
            
            <h3 style="margin-top:20px;">4. Proof Sketch</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #22c55e; margin:10px 0;">
                <p><strong>Step 1:</strong> The condition a/b in S_n = (1/(n+1), 1/n] is equivalent to b/(n+1) < a <= b/n.</p>
                <p style="margin:8px 0;"><strong>Step 2:</strong> For each b, the number of integers a in this range is b/(n(n+1)) + O(1).</p>
                <p style="margin:8px 0;"><strong>Step 3:</strong> Restricting to coprime pairs: Sum over b<=N of phi(b)/(n(n+1)) + O(N)</p>
                <p style="margin:8px 0;"><strong>Step 4:</strong> Apply the classical summatory totient estimate:</p>
                <div style="background:#0a0f1a; padding:8px; margin:8px 0; border-radius:4px; font-family:monospace;">
                    Sum of phi(b) = (3/pi^2)N^2 + O(N log N)
                </div>
                <p style="margin:8px 0;"><strong>Conclusion:</strong> C(n,N) = (1/(n(n+1))) * ((3/pi^2)N^2 + O(N log N))</p>
            </div>
            
            <h3 style="margin-top:20px;">5. Computational Verification</h3>
            <table style="width:100%; margin-top:10px; border-collapse:collapse; font-size:0.85em;">
                <thead><tr style="background:#334155;"><th style="padding:8px;">Sector n</th><th>Width 1/(n(n+1))</th><th>Asymptotic Factor</th><th>Global Fraction</th></tr></thead>
                <tbody>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">1</td><td style="padding:8px;">1/2</td><td style="padding:8px;">3/(2pi^2)</td><td style="padding:8px;">approximately 0.1519</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">2</td><td style="padding:8px;">1/6</td><td style="padding:8px;">3/(6pi^2)</td><td style="padding:8px;">approximately 0.0506</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">3</td><td style="padding:8px;">1/12</td><td style="padding:8px;">3/(12pi^2)</td><td style="padding:8px;">approximately 0.0253</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">n</td><td style="padding:8px;">1/(n(n+1))</td><td style="padding:8px;">3/(pi^2 n(n+1))</td><td style="padding:8px;">1/n(n+1) * 6/pi^2</td></tr>
                </tbody>
            </table>
            <p style="margin-top:10px; font-size:0.85em; color:#94a3b8;">Numerical experiments confirm convergence to predicted asymptotics at rates consistent with O(N log N) error decay. Interactive visualizations above display accumulation of primitive lattice points within each Farey sector.</p>
            
            <h3 style="margin-top:20px;">6. Key Theoretical Connections</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Euler and Coprime Density</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Global density 1/zeta(2) = 6/pi^2 emerges as sum of sectoral contributions.</p>
                </div>
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Franel-Landau Connection</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Farey gap distribution relates to RH via: Sum|F_k - k/|F_N|| = O(N^(1/2+epsilon)) iff RH</p>
                </div>
            </div>
            
            <h3 style="margin-top:20px;">7. The Sector Boundary: A Phase Transition in Number Theory</h3>
            <div class="derivation-box" style="background: linear-gradient(135deg, #1e3a5f 0%, #2d4a6f 100%); border-left-color: #38bdf8;">
                <strong style="color:#7dd3fc; font-size:1.1em;">The Nyquist Limit of the Farey Sequence</strong>
                <p style="margin:12px 0 0 0;">For any order N, there exists a critical sector n* where the asymptotic formula transitions from continuous density estimation to discrete arithmetic counting. This boundary represents a fundamental phase transition in number-theoretic behavior.</p>
                <div style="background:#0f172a; padding:12px; border-radius:5px; font-family:monospace; font-size:1em; margin:10px 0; text-align:center;">
                    <strong>n* ‚âà (‚àö3/œÄ) ¬∑ N ‚âà 0.5513 ¬∑ N</strong>
                </div>
                <p style="margin:10px 0 0 0; font-size:0.9em;">Just as the Nyquist frequency in signal processing defines the limit where wave reconstruction fails, this bound marks where the "Farey density wave" can no longer be treated as continuous.</p>
            </div>
            
            <h4 style="margin-top:15px; color:#7dd3fc;">7.1 Derivation of the Boundary Constant</h4>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #0ea5e9; margin:10px 0;">
                <p><strong>Condition:</strong> The predicted count C(n,N) falls below unity when:</p>
                <div style="background:#0a0f1a; padding:8px; margin:8px 0; border-radius:4px; font-family:monospace; text-align:center;">
                    (3/œÄ¬≤) ¬∑ N¬≤ / (n(n+1)) < 1
                </div>
                <p style="margin:8px 0;"><strong>Solving for n:</strong> n¬≤ + n > (3/œÄ¬≤)N¬≤ implies n > (‚àö3/œÄ)N for large n</p>
                <p style="margin:8px 0;"><strong>The Constant:</strong> ‚àö3/œÄ ‚âà 0.5513 emerges naturally from the interaction of:</p>
                <ul style="margin:8px 0 0 15px; font-size:0.9em;">
                    <li>The coprime density constant 3/œÄ¬≤ (from Euler's totient asymptotics)</li>
                    <li>The geometric sector width 1/(n(n+1))</li>
                </ul>
            </div>
            
            <h4 style="margin-top:15px; color:#7dd3fc;">7.2 Behavioral Regimes</h4>
            <table style="width:100%; margin-top:10px; border-collapse:collapse; font-size:0.85em;">
                <thead><tr style="background:#1e3a5f;"><th style="padding:10px; text-align:left;">Property</th><th style="padding:10px;">Dense Regime (n < 0.55N)</th><th style="padding:10px;">Boundary (n ‚âà 0.55N)</th><th style="padding:10px;">Sparse Regime (n > 0.55N)</th></tr></thead>
                <tbody>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:10px;"><strong>Predicted Count</strong></td><td style="padding:10px; text-align:center;">C(n,N) >> 1</td><td style="padding:10px; text-align:center;">C(n,N) ‚âà 1</td><td style="padding:10px; text-align:center;">C(n,N) < 1</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:10px;"><strong>Relative Error</strong></td><td style="padding:10px; text-align:center;">Low, stable (< 5%)</td><td style="padding:10px; text-align:center;">Increasing noise</td><td style="padding:10px; text-align:center;">Oscillatory, unbounded</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:10px;"><strong>Identity Distribution</strong></td><td style="padding:10px; text-align:center;">Spread across PP, PC, CP, CC</td><td style="padding:10px; text-align:center;">Concentrating</td><td style="padding:10px; text-align:center;">Single category dominates</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:10px;"><strong>Mathematical Regime</strong></td><td style="padding:10px; text-align:center; color:#4ade80;">Analytic (Density)</td><td style="padding:10px; text-align:center; color:#fbbf24;">Transitional</td><td style="padding:10px; text-align:center; color:#f472b6;">Discrete (Counting)</td></tr>
                </tbody>
            </table>
            
            <h4 style="margin-top:15px; color:#7dd3fc;">7.3 The Quantum Arithmetic Regime</h4>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #f472b6; margin:10px 0;">
                <p style="margin:0 0 10px 0;">Beyond the boundary, sectors enter a "quantum" regime where:</p>
                <div class="grid-2" style="gap:12px;">
                    <div style="background:#1e1b4b; padding:10px; border-radius:4px;">
                        <strong style="color:#c4b5fd;">Discrete Counting Dominates</strong>
                        <p style="margin:6px 0 0 0; font-size:0.85em;">The formula predicts fractional counts (0.4, 0.7) but actual counts must be integers (0 or 1), causing wild relative error oscillations.</p>
                    </div>
                    <div style="background:#1e1b4b; padding:10px; border-radius:4px;">
                        <strong style="color:#c4b5fd;">Identity Collapse</strong>
                        <p style="margin:6px 0 0 0; font-size:0.85em;">When a sector contains exactly one fraction, that fraction occupies precisely one P/C category, trivially satisfying the identity: 0+0+0+1 = 1.</p>
                    </div>
                </div>
            </div>
            
            <h4 style="margin-top:15px; color:#7dd3fc;">7.4 Physical Interpretation: A Resolution Map of the Primes</h4>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #22c55e; margin:10px 0;">
                <p style="margin:0 0 10px 0;">The boundary constant provides a "resolution limit" for prime distribution analysis:</p>
                <ul style="margin:0 0 0 15px; font-size:0.9em;">
                    <li><strong>Zooming In:</strong> Increasing N allows the asymptotic formula to penetrate deeper into higher-numbered sectors before encountering empty regions.</li>
                    <li><strong>Information Limit:</strong> At n ‚âà 0.55N, we reach the maximum "resolution" where statistical methods remain valid.</li>
                    <li><strong>Prime Chaos:</strong> Beyond this limit, individual prime locations dominate over statistical patterns.</li>
                </ul>
            </div>
            
            <div class="theorem-box" style="background: linear-gradient(135deg, #422006 0%, #5a3a1a 100%); border-left-color: #fbbf24; margin-top:15px;">
                <strong style="color:#fcd34d; font-size:1em;">Key Observation</strong>
                <p style="margin:10px 0 0 0; font-size:0.9em;">The Prime/Composite identities (PP + PC + CP + CC = Total) hold <em>exactly</em> in all regimes, including at and beyond the boundary. This persistence demonstrates that while density estimates fail, the underlying arithmetic structure remains inviolate. The boundary thus separates where we can <em>predict</em> counts from where we can only <em>verify</em> identities.</p>
            </div>
            
            <h3 style="margin-top:20px;">8. Conclusion</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #3b82f6; margin:10px 0;">
                <p style="margin:0;">Farey sectors provide a natural geometric decomposition of rational directions. By combining this structure with classical coprime density results, we obtain an explicit directional refinement of visible lattice point counts. The discovery of the sector boundary at n ‚âà 0.55N reveals a fundamental phase transition between analytic and discrete number-theoretic regimes. This framework enables anisotropic analysis of arithmetic distributions and provides foundation for modular constraints, higher-dimensional generalizations, and computational exploration of the density-discreteness interface.</p>
            </div>
            
            <p style="margin-top:20px; text-align:center; color:#64748b; font-size:0.85em;">See References tab for foundational works and acknowledgments.</p>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('theory')">Screenshot Full Theory Tab</button></div>
        </div>
    </div>
    
    <!-- THEORY VIZ TAB -->
    <div id="tab-theoryviz" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Interactive Theory Visualization</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Visual exploration of the Farey Sector Density Theorem with interactive elements</p>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Max Sectors:</label>
                    <input type="number" id="tvMaxSectors" value="8" min="3" max="20" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Max N:</label>
                    <input type="number" id="tvMaxN" value="150" min="20" max="500" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Lattice Size:</label>
                    <input type="number" id="tvLatticeSize" value="22" min="10" max="40" onchange="drawTheoryViz()">
                </div>
                <div class="control-group">
                    <label>Highlight Sector:</label>
                    <input type="number" id="tvHighlightSector" value="2" min="1" max="10" onchange="drawTheoryViz()">
                </div>
                <button onclick="drawTheoryViz()">Refresh All</button>
                <button class="secondary" onclick="animateTheoryViz()">Animate Growth</button>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Sector Partition of (0,1]</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowSectorValues" checked onchange="drawSectorPartition()"> Values</label>
                    <label><input type="checkbox" id="tvShowSectorWidths" onchange="drawSectorPartition()"> Widths</label>
                    <label>Style: <select id="tvPartitionStyle" onchange="drawSectorPartition()"><option value="bar">Bar</option><option value="arc">Arc</option><option value="number">Number Line</option></select></label>
                </div>
                <canvas id="sectorPartitionCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="sectorPartitionLegend"></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Density Cone: C(n,N) ~ (3/œÄ¬≤)N¬≤/n(n+1)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sectors to show: <input type="number" id="tvConeSectors" value="4" min="1" max="10" onchange="drawDensityCone()"></label>
                    <label><input type="checkbox" id="tvLogScale" onchange="drawDensityCone()"> Log Y</label>
                </div>
                <canvas id="densityConeCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="densityConeLegend"></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Summatory Totient: Œ£œÜ(b) ~ 3N¬≤/œÄ¬≤</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowTotientActual" checked onchange="drawTotientSum()"> Actual</label>
                    <label><input type="checkbox" id="tvShowTotientPredicted" checked onchange="drawTotientSum()"> Predicted</label>
                    <label><input type="checkbox" id="tvShowTotientError" onchange="drawTotientSum()"> Error</label>
                    <label><input type="checkbox" id="tvTotientFill" onchange="drawTotientSum()"> Fill</label>
                </div>
                <canvas id="totientSumCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual Œ£œÜ(b)</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Asymptotic 3N¬≤/œÄ¬≤</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Visible Lattice Points by Direction</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowHidden" checked onchange="drawLatticeViz()"> Hidden pts</label>
                    <label><input type="checkbox" id="tvShowSectorLines" checked onchange="drawLatticeViz()"> Sector lines</label>
                    <label><input type="checkbox" id="tvColorBySector" onchange="drawLatticeViz()"> Color by sector</label>
                    <label>Point size: <input type="range" id="tvPointSize" min="2" max="8" value="4" onchange="drawLatticeViz()"></label>
                </div>
                <canvas id="latticeVizCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Visible (gcd=1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#334155"></div>Hidden (gcd>1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Sector Boundary</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Proof Visualization: Step-by-Step Accumulation</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sector n: <input type="number" id="tvProofSector" value="2" min="1" max="10" onchange="drawProofSteps()"></label>
                    <label><input type="checkbox" id="tvShowContribBars" checked onchange="drawProofSteps()"> Contrib bars</label>
                    <label><input type="checkbox" id="tvShowProofPredicted" checked onchange="drawProofSteps()"> Predicted</label>
                </div>
                <canvas id="proofStepsCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Cumulative count</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Predicted asymptotic</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>œÜ(b)/(n(n+1)) contribution</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Convergence Rate Analysis</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Analysis type: <select id="tvConvergenceType" onchange="drawConvergenceAnalysis()"><option value="relative">Relative Error</option><option value="absolute">Absolute Error</option><option value="ratio">Actual/Predicted</option></select></label>
                    <label><input type="checkbox" id="tvShowConvergenceTrend" checked onchange="drawConvergenceAnalysis()"> Trend line</label>
                </div>
                <canvas id="convergenceCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="convergenceLegend"></div>
            </div>
        </div>
        
        <div class="chart-box chart-wrapper" style="margin-top:15px;">
            <h4>Sector Density Heatmap: C(n,N) across parameters</h4>
            <div class="control-row" style="margin-bottom:8px;">
                <label>N range: <input type="number" id="tvHeatmapNMin" value="20" min="10" max="100"> to <input type="number" id="tvHeatmapNMax" value="150" min="50" max="300"></label>
                <label>Sectors: <input type="number" id="tvHeatmapSectors" value="10" min="3" max="15"></label>
                <label>Color: <select id="tvHeatmapColor" onchange="drawDensityHeatmap()"><option value="viridis">Viridis</option><option value="plasma">Plasma</option><option value="coolwarm">Cool-Warm</option></select></label>
                <button onclick="drawDensityHeatmap()">Generate</button>
            </div>
            <canvas id="densityHeatmapCanvas" width="1100" height="300"></canvas>
            <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#440154"></div>Low density</div><div class="color-legend-item"><div class="color-swatch" style="background:#21918c"></div>Medium</div><div class="color-legend-item"><div class="color-swatch" style="background:#fde725"></div>High density</div></div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Theorem Summary:</strong> For fixed sector n, as N approaches infinity: C(n,N) = (3/œÄ¬≤) √ó N¬≤ / (n(n+1)) + O(N log N). This follows from summing œÜ(b)/(n(n+1)) over denominators b ‚â§ N and applying the classical totient summation formula.
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('theoryviz')">Screenshot Full Theory Viz Tab</button></div>
    </div>
    
    <!-- GAPS TAB -->
    <div id="tab-gaps" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #8b5cf6;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Farey Gap Analysis</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.2em;text-align:center;color:#8b5cf6;">gap(a/b, c/d) = |c/d - a/b| = 1/(b*d)</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">For consecutive Farey fractions a/b and c/d, the gap between them equals exactly 1/(b*d). This elegant formula shows that gaps decrease as denominators grow. The distribution reveals how fractions cluster and spread across the unit interval.</p>
        </div>
        <div class="stat-grid" id="gapStats" style="margin-top:12px;"></div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper"><h4>Gap Distribution (Color = Size)</h4><canvas id="gapDistChart"></canvas></div>
            <div class="chart-box chart-wrapper"><h4>Gap vs Denominator Product</h4><canvas id="gapVsDenomChart"></canvas></div>
        </div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper"><h4>Gap Position in [0,1]</h4><canvas id="gapPositionChart"></canvas></div>
            <div class="chart-box chart-wrapper"><h4>Gap Size vs Position</h4><canvas id="gapSizePositionChart"></canvas></div>
        </div>
        <div class="panel" style="margin-top:15px; background:#0f172a;">
            <h4>Largest Gaps <span style="font-weight:normal;color:#64748b;">(sorted by gap size)</span></h4>
            <div class="table-scroll">
                <table id="gapTable">
                    <thead><tr><th>#</th><th>Left Fraction</th><th>Right Fraction</th><th>Actual Gap</th><th>Theoretical 1/(bd)</th><th>Match</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        <div class="connection-box" style="margin-top:15px;">
            <strong>Key Insight:</strong> Every gap exactly equals 1/(bd) where b and d are the denominators of consecutive Farey fractions. This is a consequence of the mediant property: for neighbors a/b and c/d, we have |ad - bc| = 1.
        </div>
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Ford Circles Connection:</strong> Each Farey fraction a/b corresponds to a Ford circle of radius 1/(2b¬≤) tangent to the real line at x = a/b. Two Ford circles are tangent if and only if their fractions are Farey neighbors. The gap formula 1/(bd) emerges from the geometry of tangent Ford circles, connecting number theory to hyperbolic geometry.
        </div>
        <div style="margin-top:15px; padding:12px; background:#1e293b; border-radius:8px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <span style="color:#94a3b8; font-size:12px;">Hear the gaps as intervals:</span>
            <button onclick="playGapsAsIntervals('forward')" style="padding:8px 14px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ∂ Play Forward</button>
            <button onclick="playGapsAsIntervals('backward')" style="padding:8px 14px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:5px;color:white;cursor:pointer;">‚óÄ Play Backward</button>
            <button onclick="stopAllPlayback()" style="padding:8px 14px;background:#ef4444;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ† Stop</button>
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('gaps')">Screenshot Full Gaps Tab</button></div>
    </div>
    
    <!-- FRANEL-LANDAU TAB -->
    <div id="tab-franel" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #06b6d4;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Franel-Landau Theorem</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#06b6d4;">Œ£|Œ¥_k| = O(N^(1/2+Œµ)) ‚ü∫ Riemann Hypothesis</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Define Œ¥_k = F_k - k/|F_N| as the k-th Farey fraction deviation. The growth rate of Œ£|Œ¥_k| is directly equivalent to the Riemann Hypothesis. If RH is true, the sum grows slower than N^(1/2+Œµ) for any Œµ > 0. This provides a concrete computational test for RH properties through Farey sequence analysis. <strong style="color:#f87171;">Note: These computations illustrate known equivalences but do not constitute a proof or disproof of RH.</strong></p>
        </div>
        <div class="stat-grid" id="franelStats" style="margin-top:12px;"></div>
        <div class="control-panel" style="margin-top:15px;">
            <div class="control-row">
                <label>Test Alpha: <input type="range" id="franelAlphaSlider" min="0.3" max="0.7" step="0.01" value="0.5" onchange="updateFranelAlpha()"><span id="franelAlphaValue" style="margin-left:8px;color:#06b6d4;">0.50</span></label>
                <span id="franelAlphaResult" style="margin-left:15px;padding:4px 10px;border-radius:4px;font-size:12px;"></span>
            </div>
        </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Deviation Œ¥_k vs k</h4><canvas id="franelDeviationChart"></canvas></div>
                <div class="chart-box"><h4>Cumulative |Œ¥| / N^Œ±</h4><canvas id="franelCumulativeChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Œ£|Œ¥| / N^Œ± for various Œ±</h4><canvas id="franelAlphaChart"></canvas></div>
                <div class="chart-box"><h4>Log-Log: log(Œ£|Œ¥|) vs log(N)</h4><canvas id="franelLogLogChart"></canvas></div>
            </div>
            <div class="derivation-box" style="margin-top:15px;"><strong>Interpretation:</strong> If RH is true, the normalized sum Œ£|Œ¥|/N^Œ± should stay bounded for Œ± > 1/2. Divergence for Œ± ‚â§ 1/2 would contradict RH. The log-log plot slope indicates the actual growth exponent.</div>
            <div class="connection-box" style="margin-top:15px;">
                <strong>Mertens Function Connection:</strong> The Mertens function M(n) = Œ£Œº(k) for k‚â§n satisfies M(n) = O(n^(1/2+Œµ)) ‚ü∫ RH. The Franel-Landau sum and Mertens function encode equivalent information about zero distribution of Œ∂(s). Both provide computational windows into the Riemann Hypothesis.
            </div>
            <div style="margin-top:15px; padding:12px; background:#1e293b; border-radius:8px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span style="color:#94a3b8; font-size:12px;">Hear the Farey sequence:</span>
                <button onclick="playFareySequence('forward')" style="padding:8px 14px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ∂ Forward (0‚Üí1)</button>
                <button onclick="playFareySequence('backward')" style="padding:8px 14px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:5px;color:white;cursor:pointer;">‚óÄ Backward (1‚Üí0)</button>
                <button onclick="stopAllPlayback()" style="padding:8px 14px;background:#ef4444;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ† Stop</button>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('franel')">Screenshot Full Franel Tab</button></div>
    </div>
    
    <!-- DEDEKIND TAB -->
    <div id="tab-dedekind" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #f59e0b;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Dedekind Sums</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#f59e0b;">s(h,k) = Œ£_{j=1}^{k-1} ((j/k))((hj/k))</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Dedekind sums are arithmetic functions encoding properties of coprime pairs (h,k). They satisfy reciprocity formulas: s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk)). These sums connect to modular forms and are fundamental in algebraic number theory.</p>
        </div>
        <div class="panel">
            <h3>Dedekind Sums</h3>
            <div class="theorem-box"><strong>Definition:</strong> s(h,k) = Œ£_{j=1}^{k-1} ((j/k))((hj/k)) where ((x)) = x - floor(x) - 1/2 if x is not an integer, else 0</div>
            <div class="control-row" style="margin:12px 0;"><label>Max k: <input type="number" id="dedekindMaxK" value="20" min="2" onchange="computeDedekind()"></label></div>
            <div class="stat-grid" id="dedekindStats" style="margin-top:12px;"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>s(h,k) Heatmap</h4><canvas id="dedekindHeatmap" width="400" height="400"></canvas></div>
                <div class="chart-box"><h4>s(1,k) vs k</h4><canvas id="dedekindChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Distribution of s(h,k) Values</h4><canvas id="dedekindDistChart"></canvas></div>
                <div class="chart-box"><h4>12k*s(h,k) Distribution</h4><canvas id="dedekind12kChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Dedekind Sum Table</h4><div class="table-scroll"><table id="dedekindTable"><thead><tr><th>h</th><th>k</th><th>s(h,k)</th><th>12k*s(h,k)</th><th>gcd</th></tr></thead><tbody></tbody></table></div></div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Reciprocity Verification <span style="font-weight:normal;color:#64748b;">(s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk)))</span></h4><div class="table-scroll"><table id="dedekindReciprocityTable"><thead><tr><th>h</th><th>k</th><th>s(h,k)</th><th>s(k,h)</th><th>Sum</th><th>RHS</th><th>Match</th></tr></thead><tbody></tbody></table></div></div>
            <div class="connection-box" style="margin-top:12px;"><strong>Reciprocity:</strong> s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk))</div>
            <div class="derivation-box" style="margin-top:12px;"><strong>Modular Forms Connection:</strong> Dedekind sums arise in the transformation formula for the Dedekind eta function Œ∑(œÑ) = e^(œÄiœÑ/12) Œ†(1-e^(2œÄinœÑ)). Under modular transformations, the eta function picks up factors involving Dedekind sums, making them essential in the theory of modular forms.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('dedekind')">Screenshot Full Dedekind Tab</button></div>
        </div>
    </div>
    
    <!-- CONTINUED FRACTIONS TAB -->
    <div id="tab-cf" class="tab-content">
        <div class="panel">
            <h3>Continued Fractions</h3>
            <div class="theorem-box"><strong>Stern-Brocot Encoding:</strong> Path L^a R^b L^c... encodes CF [0; a, b, c, ...]. Every rational r/m has a unique finite CF expansion. The convergents p_k/q_k satisfy |r/m - p_k/q_k| < 1/(q_k * q_{k+1}), giving best rational approximations.</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Sector: <input type="number" id="cfSector" value="2" min="1" onchange="updateCFDisplay()"></label>
                <label>Max terms: <input type="number" id="cfMaxTerms" value="50" onchange="updateCFDisplay()"></label>
                <button onclick="updateCFDisplay()">Refresh</button>
                <button style="background:linear-gradient(135deg,#22c55e,#16a34a);" onclick="playCFSelected()" title="Play selected CF fraction">‚ñ∂ Play</button>
                <button class="secondary" onclick="playCFConvergents()" title="Play convergents as scale">‚ô™ Convergents</button>
                <button class="secondary" onclick="playCFAll()" title="Play all fractions in sector">‚ô™ All</button>
            </div>
            
            <div class="stat-grid" id="cfStats" style="margin-top:12px;"></div>
            
            <div class="panel" style="background:#1e1b4b; border:1px solid #6366f1; margin-bottom:15px;">
                <h4 style="color:#a5b4fc; margin-top:0;">Selected Fraction</h4>
                <div id="cfSelectedInfo" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:12px;">
                    <div style="color:#64748b; grid-column:1/-1;">Click a row in the table below to select a fraction</div>
                </div>
            </div>
            
            <div class="panel" style="background:#0f172a;"><h4>Continued Fraction Expansions <span style="font-weight:normal;color:#64748b;">(click row to select & play)</span></h4><div class="table-scroll"><table id="cfTable"><thead><tr><th>r/m</th><th>CF [a0; a1, a2, ...]</th><th>Path</th><th>Length</th><th>Sum(a_i)</th><th>Max(a_i)</th><th>Freq</th><th>Play</th></tr></thead><tbody></tbody></table></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>CF Length Distribution</h4><canvas id="cfLengthChart"></canvas></div>
                <div class="chart-box"><h4>First Partial Quotient a_1</h4><canvas id="cfFirstChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Sum of Partial Quotients</h4><canvas id="cfSumChart"></canvas></div>
                <div class="chart-box"><h4>Max Partial Quotient</h4><canvas id="cfMaxChart"></canvas></div>
            </div>
            <div class="derivation-box" style="margin-top:15px;">
                <strong>Gauss-Kuzmin Distribution:</strong> For almost all real numbers, the probability that a partial quotient a_k equals n approaches log‚ÇÇ(1 - 1/(n+1)¬≤) as k ‚Üí ‚àû. For n=1, this is about 41.5%; for n=2, about 17.0%; for n=3, about 9.3%.
            </div>
            <div class="connection-box" style="margin-top:12px;">
                <strong>Golden Ratio Connection:</strong> The golden ratio œÜ = [1; 1, 1, 1, ...] has all partial quotients equal to 1, making it the "most irrational" number - hardest to approximate by rationals. Fractions with small partial quotients are harmonically simple.
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('cf')">Screenshot Full CF Tab</button></div>
        </div>
    </div>
    
    <!-- PSL(2,Z) TAB -->
    <div id="tab-psl" class="tab-content">
        <div class="panel">
            <h3>PSL(2,‚Ñ§) Matrices & Ford Circles</h3>
            <div class="theorem-box"><strong>Farey Neighbor Property:</strong> For consecutive Farey fractions a/b, c/d: |ad - bc| = 1, giving matrix [a,c; b,d] ‚àà SL(2,‚Ñ§). These matrices generate the modular group PSL(2,‚Ñ§) = SL(2,‚Ñ§)/{¬±I}.</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Max denom: <input type="number" id="pslMaxDenom" value="12" min="3" max="30" onchange="computePSL()"></label>
                <button onclick="computePSL()">Compute</button>
            </div>
            <div class="stat-grid" id="pslStats" style="margin-top:12px;"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Ford Circles</h4><canvas id="fordCanvas" width="600" height="300"></canvas></div>
                <div class="chart-box"><h4>Tangency Graph</h4><canvas id="fordTangencyChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Neighbor Matrices <span style="font-weight:normal;color:#64748b;">(a/b ‚Üí c/d with det = ad-bc)</span></h4><div id="pslMatrices" style="max-height:300px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Determinant Verification</h4><div id="pslVerification"></div></div>
                <div class="chart-box"><h4>Circle Radius Distribution</h4><canvas id="fordRadiusChart"></canvas></div>
            </div>
            <div class="derivation-box" style="margin-top:15px;">
                <strong>Ford Circle Geometry:</strong> Each fraction a/b corresponds to a Ford circle of radius 1/(2b¬≤) tangent to the real line at x=a/b. Two Ford circles are tangent if and only if their fractions are Farey neighbors. The hyperbolic area between tangent circles relates to the Dedekind eta function.
            </div>
            <div class="connection-box" style="margin-top:12px;">
                <strong>Modular Group Action:</strong> PSL(2,‚Ñ§) acts on the upper half-plane by M√∂bius transformations: z ‚Üí (az+b)/(cz+d). The fundamental domain is the "keyhole" region, and Ford circles visualize the orbit structure of this action on ‚Ñö ‚à™ {‚àû}.
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('psl')">Screenshot Full PSL Tab</button></div>
        </div>
    </div>
    
    <!-- EULER PRODUCT TAB -->
    <div id="tab-euler" class="tab-content">
        <div class="panel">
            <h3>Euler Product for Œ∂(2) & Coprime Density</h3>
            <div class="theorem-box"><strong>Euler's Identity:</strong> Œ∂(2) = Œ£ 1/n¬≤ = ‚àè_p 1/(1-1/p¬≤) = œÄ¬≤/6, hence the coprime probability 6/œÄ¬≤ = ‚àè_p (1-1/p¬≤). This connects prime distribution to the geometry of coprime pairs.</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Primes up to: <input type="number" id="eulerMaxP" value="50" min="5" max="500" onchange="computeEulerProduct()"></label>
                <label>Sum terms: <input type="number" id="eulerMaxN" value="100" min="10" max="1000" onchange="computeEulerProduct()"></label>
                <button onclick="computeEulerProduct()">Compute</button>
            </div>
            <div class="stat-grid" id="eulerStats"></div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Product Terms <span style="font-weight:normal;color:#64748b;">(1-1/p¬≤) for each prime p</span></h4><div id="eulerTerms" style="max-height:150px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Partial Product ‚àè(1-1/p¬≤) ‚Üí 6/œÄ¬≤</h4><canvas id="eulerProductChart"></canvas></div>
                <div class="chart-box"><h4>Partial Sum Œ£1/n¬≤ ‚Üí œÄ¬≤/6</h4><canvas id="eulerSumChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Product Error Decay</h4><canvas id="eulerProductErrorChart"></canvas></div>
                <div class="chart-box"><h4>Sum Error Decay</h4><canvas id="eulerSumErrorChart"></canvas></div>
            </div>
            <div class="derivation-box" style="margin-top:15px;">
                <strong>Probabilistic Interpretation:</strong> The probability that a random integer is not divisible by prime p is (1-1/p). For coprimality of two integers, we need both to avoid sharing any prime factor, giving (1-1/p¬≤) per prime. The infinite product over all primes yields 6/œÄ¬≤ ‚âà 0.6079.
            </div>
            <div class="connection-box" style="margin-top:12px;">
                <strong>Basel Problem:</strong> Euler's proof that Œ£1/n¬≤ = œÄ¬≤/6 was a landmark result connecting number theory to analysis. The product formula ‚àè(1-1/p¬≤)‚Åª¬π = Œ∂(2) encodes the fundamental theorem of arithmetic into an analytic identity.
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('euler')">Screenshot Full Euler Tab</button></div>
        </div>
    </div>
    
    <!-- MODULAR TAB -->
    <div id="tab-modular" class="tab-content">
        <div class="panel">
            <h3>Modular Arithmetic Analysis</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Filter mod k: <input type="number" id="modK" value="6" min="2" onchange="updateModularAnalysis()"></label>
                <label>Residue a: <input type="number" id="modA" value="1" min="0" onchange="updateModularAnalysis()"></label>
                <button onclick="updateModularAnalysis()">Apply Filter</button>
            </div>
            <div class="stat-grid" id="modularStats"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Residue Class Distribution</h4><canvas id="residueClassChart"></canvas></div>
                <div class="chart-box"><h4>Prime Channel Ownership</h4><canvas id="primeChannelChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Farey Neighbors & Mediants</h4>
                <p style="color:#64748b;font-size:0.85em;margin-bottom:10px;">For each fraction, showing its left/right Farey neighbors and their mediant (the next fraction to appear between them as N increases).</p>
                <div id="liftingDisplay"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('modular')">Screenshot Full Modular Tab</button></div>
        </div>
    </div>
    
    <!-- 3D VIEW TAB -->
    <div id="tab-3d" class="tab-content">
        <div class="panel">
            <h3>3D Sector Cone</h3>
            
            <!-- 3D Controls with input boxes -->
            <div style="background:#0f172a;padding:12px;border-radius:8px;margin-bottom:12px;">
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;color:#94a3b8;font-size:11px;margin-bottom:4px;">Rotate X (pitch)</label>
                        <div style="display:flex;gap:8px;align-items:center;">
                            <input type="range" id="rot3dX" min="-90" max="90" value="30" oninput="sync3DInput('X')" style="flex:1;">
                            <input type="number" id="rot3dXNum" min="-90" max="90" value="30" oninput="sync3DSlider('X')" style="width:60px;padding:4px;background:#1e293b;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                            <span style="color:#64748b;font-size:11px;">¬∞</span>
                        </div>
                    </div>
                    <div>
                        <label style="display:block;color:#94a3b8;font-size:11px;margin-bottom:4px;">Rotate Y (yaw)</label>
                        <div style="display:flex;gap:8px;align-items:center;">
                            <input type="range" id="rot3dY" min="-180" max="180" value="0" oninput="sync3DInput('Y')" style="flex:1;">
                            <input type="number" id="rot3dYNum" min="-180" max="180" value="0" oninput="sync3DSlider('Y')" style="width:60px;padding:4px;background:#1e293b;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                            <span style="color:#64748b;font-size:11px;">¬∞</span>
                        </div>
                    </div>
                    <div>
                        <label style="display:block;color:#94a3b8;font-size:11px;margin-bottom:4px;">Rotate Z (roll)</label>
                        <div style="display:flex;gap:8px;align-items:center;">
                            <input type="range" id="rot3dZ" min="0" max="360" value="45" oninput="sync3DInput('Z')" style="flex:1;">
                            <input type="number" id="rot3dZNum" min="0" max="360" value="45" oninput="sync3DSlider('Z')" style="width:60px;padding:4px;background:#1e293b;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                            <span style="color:#64748b;font-size:11px;">¬∞</span>
                        </div>
                    </div>
                    <div>
                        <label style="display:block;color:#94a3b8;font-size:11px;margin-bottom:4px;">Perspective (FOV)</label>
                        <div style="display:flex;gap:8px;align-items:center;">
                            <input type="range" id="perspective3d" min="100" max="1000" value="500" oninput="sync3DInput('P')" style="flex:1;">
                            <input type="number" id="perspective3dNum" min="100" max="1000" value="500" oninput="sync3DSlider('P')" style="width:60px;padding:4px;background:#1e293b;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        </div>
                    </div>
                </div>
                
                <!-- Presets -->
                <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
                    <span style="color:#94a3b8;font-size:11px;">Presets:</span>
                    <button onclick="set3DPreset(30,0,45,500)" class="secondary" style="font-size:11px;padding:4px 10px;">Default</button>
                    <button onclick="set3DPreset(0,0,0,500)" class="secondary" style="font-size:11px;padding:4px 10px;">Top</button>
                    <button onclick="set3DPreset(90,0,0,500)" class="secondary" style="font-size:11px;padding:4px 10px;">Side</button>
                    <button onclick="set3DPreset(45,0,45,500)" class="secondary" style="font-size:11px;padding:4px 10px;">Isometric</button>
                    <button onclick="set3DPreset(60,0,30,300)" class="secondary" style="font-size:11px;padding:4px 10px;">Close</button>
                    <button onclick="set3DPreset(20,0,60,800)" class="secondary" style="font-size:11px;padding:4px 10px;">Wide</button>
                    <button onclick="animate3DRotation()" class="secondary" style="font-size:11px;padding:4px 10px;border-color:#22c55e;color:#22c55e;">‚ñ∂ Spin</button>
                    <button onclick="stop3DAnimation()" class="secondary" style="font-size:11px;padding:4px 10px;">‚ñ† Stop</button>
                </div>
            </div>
            
            <div class="stat-grid" id="stats3d" style="margin-bottom:12px;"></div>
            <div style="text-align:center;"><canvas id="canvas3d" class="ring-canvas" width="700" height="600"></canvas></div>
            <div class="derivation-box" style="margin-top:12px;">Third axis represents denominator m. Points at height m have coprime numerators r with r/m in the sector range. The cone structure shows density increasing with m¬≤.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('3d')">Screenshot Full 3D Tab</button></div>
        </div>
    </div>
    
    <!-- HYPERBOLIC TAB -->
    <div id="tab-hyperbolic" class="tab-content">
        <div class="panel">
            <h3>Hyperbolic Plane / Poincar√© Disk</h3>
            <div class="theorem-box"><strong>Farey Tessellation:</strong> The hyperbolic plane is tessellated by ideal triangles with vertices at Farey fractions on ‚àÇH.</div>
            
            <div style="background:#0f172a;padding:12px;border-radius:8px;margin:12px 0;">
                <div style="display:flex;gap:20px;flex-wrap:wrap;align-items:center;margin-bottom:10px;">
                    <label style="display:flex;align-items:center;gap:8px;">
                        <span style="color:#94a3b8;font-size:12px;">Max denom:</span>
                        <input type="number" id="hypMaxDenom" value="15" min="3" max="50" onchange="drawHyperbolic()" style="width:60px;padding:4px;background:#1e293b;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;">
                        <span style="color:#94a3b8;font-size:12px;">Highlight sector:</span>
                        <input type="number" id="hypSector" value="2" min="1" max="20" onchange="drawHyperbolic()" style="width:60px;padding:4px;background:#1e293b;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                    </label>
                </div>
                <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
                    <span style="color:#94a3b8;font-size:11px;">Presets:</span>
                    <button onclick="setHypPreset(10,1)" class="secondary" style="font-size:11px;padding:4px 10px;">Simple (10)</button>
                    <button onclick="setHypPreset(15,2)" class="secondary" style="font-size:11px;padding:4px 10px;">Default</button>
                    <button onclick="setHypPreset(25,2)" class="secondary" style="font-size:11px;padding:4px 10px;">Dense (25)</button>
                    <button onclick="setHypPreset(40,3)" class="secondary" style="font-size:11px;padding:4px 10px;">Very Dense (40)</button>
                    <button onclick="setHypPreset(15,1)" class="secondary" style="font-size:11px;padding:4px 10px;border-color:#ef4444;color:#ef4444;">S1</button>
                    <button onclick="setHypPreset(15,2)" class="secondary" style="font-size:11px;padding:4px 10px;border-color:#f59e0b;color:#f59e0b;">S2</button>
                    <button onclick="setHypPreset(15,3)" class="secondary" style="font-size:11px;padding:4px 10px;border-color:#22c55e;color:#22c55e;">S3</button>
                </div>
            </div>
            
            <div class="stat-grid" id="hypStats" style="margin-bottom:12px;"></div>
            <div style="text-align:center;"><canvas id="hypCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div class="connection-box" style="margin-top:12px;">
                <strong>Hyperbolic Geometry:</strong> Geodesics in the Poincar√© disk model are circular arcs perpendicular to the boundary. The Farey tessellation partitions the hyperbolic plane into ideal triangles of equal hyperbolic area œÄ.
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('hyperbolic')">Screenshot Full Hyperbolic Tab</button></div>
        </div>
    </div>
    
    <!-- ANIMATION TAB -->
    <div id="tab-animation" class="tab-content">
        <div class="panel">
            <h3>Farey Sequence Growth</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Animate to N: <input type="number" id="animMaxN" value="50" min="5"></label>
                <label>Speed (ms): <input type="number" id="animSpeed" value="200" min="50"></label>
                <button onclick="startAnimation()">Start</button>
                <button class="secondary" onclick="stopAnimation()">Stop</button>
                <span id="animStatus" class="info-badge">Ready</span>
            </div>
            <div style="text-align:center;"><canvas id="animCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div class="stat-grid" id="animStats" style="margin-top:12px;"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('animation')">Screenshot Full Animation Tab</button></div>
        </div>
    </div>
    
    <!-- SMITH CHART TAB -->
    <div id="tab-smith" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#00bcd4;margin-top:0;">Smith Chart Transform (Cayley Map)</h3>
            
            <div style="background:#1e293b;padding:15px;border-radius:8px;margin-bottom:15px;">
                <label style="display:flex;align-items:center;gap:10px;padding:10px;background:#334155;border-radius:6px;cursor:pointer;">
                    <input type="checkbox" id="smithEnabled" checked onchange="drawSmithChart()" style="width:20px;height:20px;accent-color:#00bcd4;">
                    <span style="color:#e2e8f0;font-size:1em;">Enable Smith Chart Transform</span>
                </label>
                
                <div style="margin-top:20px;">
                    <div style="color:#e2e8f0;margin-bottom:8px;">Global Phase Shift Œ±: <span id="smithPhaseDisplay">90</span>¬∞</div>
                    <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px;">
                        <input type="range" id="smithPhase" min="0" max="360" value="90" oninput="syncSmithPhase('slider')" style="flex:1;height:6px;cursor:pointer;">
                        <input type="number" id="smithPhaseInput" min="0" max="360" step="0.1" value="90" onchange="syncSmithPhase('input')" style="width:65px;padding:4px 6px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;font-size:12px;">
                    </div>
                    
                    <div style="color:#94a3b8;font-size:11px;margin-bottom:6px;">Phase Presets (a/b ‚Üí primitive roots):</div>
                    <div style="display:flex;flex-wrap:wrap;gap:4px;margin-bottom:10px;">
                        <button onclick="setPhasePreset(0,1)" class="phase-preset-btn" title="0/1 = 0¬∞">0</button>
                        <button onclick="setPhasePreset(1,2)" class="phase-preset-btn" title="1/2 = 180¬∞">1/2</button>
                        <button onclick="setPhasePreset(1,3)" class="phase-preset-btn" title="1/3 = 120¬∞">1/3</button>
                        <button onclick="setPhasePreset(2,3)" class="phase-preset-btn" title="2/3 = 240¬∞">2/3</button>
                        <button onclick="setPhasePreset(1,4)" class="phase-preset-btn" title="1/4 = 90¬∞">1/4</button>
                        <button onclick="setPhasePreset(3,4)" class="phase-preset-btn" title="3/4 = 270¬∞">3/4</button>
                        <button onclick="setPhasePreset(1,5)" class="phase-preset-btn" title="1/5 = 72¬∞">1/5</button>
                        <button onclick="setPhasePreset(1,6)" class="phase-preset-btn" title="1/6 = 60¬∞">1/6</button>
                        <button onclick="setPhasePreset(5,6)" class="phase-preset-btn" title="5/6 = 300¬∞">5/6</button>
                        <button onclick="setPhasePreset(1,8)" class="phase-preset-btn" title="1/8 = 45¬∞">1/8</button>
                        <button onclick="setPhasePreset(1,12)" class="phase-preset-btn" title="1/12 = 30¬∞">1/12</button>
                    </div>
                    
                    <div style="display:flex;gap:6px;align-items:center;">
                        <span style="color:#94a3b8;font-size:11px;">Custom a/b:</span>
                        <input type="number" id="phasePresetA" min="0" max="999" value="1" style="width:45px;padding:3px 5px;background:#0f172a;border:1px solid #475569;border-radius:3px;color:#e2e8f0;font-size:11px;">
                        <span style="color:#64748b;">/</span>
                        <input type="number" id="phasePresetB" min="1" max="999" value="1" style="width:45px;padding:3px 5px;background:#0f172a;border:1px solid #475569;border-radius:3px;color:#e2e8f0;font-size:11px;">
                        <button onclick="applyCustomPhasePreset()" style="padding:4px 10px;background:#00bcd4;border:none;border-radius:4px;color:white;font-size:11px;cursor:pointer;">Apply</button>
                        <span id="phasePresetInfo" style="color:#00bcd4;font-size:10px;margin-left:5px;"></span>
                    </div>
                </div>
                
                <div style="margin-top:20px;">
                    <div style="color:#e2e8f0;margin-bottom:8px;">Radius Scaling Mode:</div>
                    <select id="smithRadiusMode" onchange="drawSmithChart()" style="width:100%;padding:12px;background:#334155;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-size:1em;">
                        <option value="unit">Unit (R=1)</option>
                        <option value="index" selected>Scaled by Index</option>
                        <option value="modulus">Scaled by Modulus</option>
                        <option value="custom">Custom Scale</option>
                    </select>
                </div>
                
                <div style="margin-top:20px;display:flex;flex-direction:column;gap:12px;">
                    <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                        <input type="checkbox" id="smithShowGrid" checked onchange="drawSmithChart()" style="width:18px;height:18px;accent-color:#fbbf24;">
                        <span style="color:#e2e8f0;">Show Smith Grid</span>
                    </label>
                    <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                        <input type="checkbox" id="smithShowConstR" checked onchange="drawSmithChart()" style="width:18px;height:18px;accent-color:#fbbf24;">
                        <span style="color:#e2e8f0;">Show Constant-R Circles</span>
                    </label>
                    <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                        <input type="checkbox" id="smithShowConstX" checked onchange="drawSmithChart()" style="width:18px;height:18px;accent-color:#fbbf24;">
                        <span style="color:#e2e8f0;">Show Constant-X Arcs</span>
                    </label>
                </div>
                
                <div style="margin-top:20px;padding:15px;background:#0f4c5c;border-left:4px solid #00bcd4;border-radius:0 8px 8px 0;">
                    <div style="color:#00bcd4;font-weight:bold;margin-bottom:10px;">Cayley/Smith Transform:</div>
                    <div style="color:#e2e8f0;font-family:monospace;font-size:1.1em;margin-bottom:15px;">Œì = (z - 1)/(z + 1)</div>
                    
                    <div style="color:#94a3b8;font-size:0.9em;line-height:1.8;">
                        <div>‚Ä¢ Maps z = R¬∑e^(iŒ∏) ‚Üí unit disk</div>
                        <div>‚Ä¢ Œ∏ = 2œÄr/M + Œ± (residue angle)</div>
                        <div>‚Ä¢ R=1: pure imaginary axis</div>
                        <div>‚Ä¢ R>1: Smith chart arcs</div>
                        <div>‚Ä¢ Conformal mapping preserves angles</div>
                    </div>
                    
                    <div style="color:#00bcd4;font-weight:bold;margin-top:15px;">Real part:</div>
                    <div style="color:#e2e8f0;font-family:monospace;font-size:0.95em;">
                        Re(Œì) = (AC + B¬≤)/(C¬≤ + B¬≤)<br>
                        A = R¬∑cos(Œ∏) - 1, B = R¬∑sin(Œ∏)<br>
                        C = R¬∑cos(Œ∏) + 1
                    </div>
                    
                    <div style="color:#00bcd4;font-weight:bold;margin-top:15px;">Imaginary part:</div>
                    <div style="color:#e2e8f0;font-family:monospace;font-size:0.95em;">
                        Im(Œì) = B(C - A)/(C¬≤ + B¬≤)
                    </div>
                    
                    <div style="color:#00bcd4;font-weight:bold;margin-top:15px;">Special case (R=1):</div>
                    <div style="color:#e2e8f0;font-family:monospace;font-size:0.95em;">
                        Œì(Œ∏) = i¬∑tan(Œ∏/2)
                    </div>
                </div>
            </div>
        </div>
            
        <div class="control-panel" style="margin-bottom:15px;">
                <div class="control-row">
                    <div class="control-group highlight">
                        <label>Sector:</label>
                        <input type="number" id="smithSector" value="2" min="1" max="15" onchange="drawSmithChart()">
                    </div>
                    <div class="control-group">
                        <label>Custom Scale:</label>
                        <input type="number" id="smithCustomScale" value="1.0" min="0.1" max="5" step="0.1" onchange="drawSmithChart()">
                    </div>
                    <label><input type="checkbox" id="smithShowLabels" onchange="drawSmithChart()"> Point Labels</label>
                    <label><input type="checkbox" id="smithColorByPrime" onchange="drawSmithChart()"> Color by Prime</label>
                    <label><input type="checkbox" id="smithShowAllSectors" onchange="drawSmithChart()"> All Sectors</label>
                </div>
                <div class="control-row" style="margin-top:8px;">
                    <span style="color:#94a3b8;font-size:11px;">Presets:</span>
                    <button onclick="setSmithPreset(2,90,'index',1)" class="secondary" style="font-size:11px;padding:4px 10px;">Default</button>
                    <button onclick="setSmithPreset(1,0,'unit',1)" class="secondary" style="font-size:11px;padding:4px 10px;">Unit Circle</button>
                    <button onclick="setSmithPreset(2,0,'modulus',1)" class="secondary" style="font-size:11px;padding:4px 10px;">Phase 0¬∞</button>
                    <button onclick="setSmithPreset(2,180,'modulus',1)" class="secondary" style="font-size:11px;padding:4px 10px;">Phase 180¬∞</button>
                    <button onclick="animateSmithPhase()" class="secondary" style="font-size:11px;padding:4px 10px;border-color:#22c55e;color:#22c55e;">‚ñ∂ Rotate</button>
                    <button onclick="stopSmithAnimation()" class="secondary" style="font-size:11px;padding:4px 10px;">‚ñ† Stop</button>
                </div>
            </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Smith Chart (Cayley Transform)</h4>
                <div style="text-align:center;position:relative;">
                    <canvas id="smithCanvas" class="ring-canvas" width="550" height="550"></canvas>
                </div>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Transformed points</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime moduli</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#334155"></div>Constant-R</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#475569"></div>Constant-X</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Original z-plane (Pre-transform)</h4>
                <div style="text-align:center;position:relative;">
                    <canvas id="smithOriginalCanvas" class="ring-canvas" width="550" height="550"></canvas>
                </div>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>z = R¬∑e^(iŒ∏)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Unit circle</div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Transform Data</h4>
            <div class="table-scroll" style="max-height:250px;">
                <table id="smithDataTable">
                    <thead><tr><th>r/m</th><th>Œ∏ (rad)</th><th>R</th><th>z = Re^iŒ∏</th><th>Œì = (z-1)/(z+1)</th><th>|Œì|</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('smith')">Screenshot Full Smith Tab</button></div>
    </div>
    
    <!-- STATISTICS TAB -->
    <div id="tab-stats" class="tab-content">
        <div class="panel">
            <h3>Statistical Analysis</h3>
            <div class="stat-grid" id="statisticalStats" style="margin-bottom:15px;"></div>
            <div class="grid-2">
                <div class="chart-box"><h4>Random vs Actual Distribution</h4><canvas id="randomCompareChart"></canvas></div>
                <div class="chart-box"><h4>Cross-Sector Correlation</h4><canvas id="correlationChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Error Term O(N log N)</h4><canvas id="errorTermChart"></canvas></div>
                <div class="chart-box"><h4>Local Density Analysis</h4><canvas id="localDensityChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Correlation Matrix</h4>
                <div id="correlationMatrix"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('stats')">Screenshot Full Statistics Tab</button></div>
        </div>
    </div>
    
    <!-- PRIMES TAB -->
    <div id="tab-primes" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #f59e0b;margin-bottom:20px;">
            <h3 style="color:#fcd34d;margin-top:0;">Prime Analysis</h3>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;"><strong>Overview:</strong> This tab explores how prime numbers manifest within the Farey sequence structure. Primes play a special role: for prime p, we have œÜ(p) = p-1 coprime residues, giving primes maximal density. The distribution of prime denominators across sectors reveals deep connections to the Prime Number Theorem and twin prime conjectures.</p>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">Prime Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">œÄ(x) ~ x/ln(x)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Twin Prime Gap</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">p, p+2 both prime</div>
                </div>
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Euler's œÜ for prime p</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">œÜ(p) = p - 1</div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <div class="stat-grid" id="primeStats"></div>
            
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box chart-wrapper">
                    <h4>Twin Prime Gap Markers</h4>
                    <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Scatter plot showing Farey gaps where both neighboring denominators are twin primes (p, p+2). The x-axis shows the position in [0,1], y-axis shows gap size. Clusters indicate regions rich in twin prime structure.</p>
                    <canvas id="twinPrimeChart"></canvas>
                </div>
                <div class="chart-box chart-wrapper">
                    <h4>Prime vs Composite Moduli</h4>
                    <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Compares count of fractions with prime denominators (orange) vs composite denominators (purple) in each sector. Prime moduli contribute more fractions per unit since œÜ(p)/p = 1-1/p is larger for primes.</p>
                    <canvas id="primeVsCompositeChart"></canvas>
                </div>
            </div>
            
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box chart-wrapper">
                    <h4>Prime k-tuple Correlations</h4>
                    <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Counts prime constellations appearing in Farey denominators: <strong>Twin</strong> (p, p+2), <strong>Cousin</strong> (p, p+4), <strong>Sexy</strong> (p, p+6), and prime triplets. These patterns connect to the Hardy-Littlewood conjectures on prime gaps.</p>
                    <canvas id="ktupleChart"></canvas>
                </div>
                <div class="chart-box chart-wrapper">
                    <h4>Prime Denominator Density</h4>
                    <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Shows œÜ(p) = p-1 for each prime denominator p. This linear growth demonstrates why primes contribute heavily to Farey sequences. The PNT reference line shows expected prime density œÄ(x) ~ x/ln(x).</p>
                    <canvas id="primeDenomDensityChart"></canvas>
                </div>
            </div>
            
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Twin Prime Gaps in Farey Sequence 
                    <button class="secondary" onclick="playTwinPrimeGaps()" style="font-size:10px;padding:4px 8px;margin-left:10px;">‚ñ∂ Play All</button>
                    <button class="secondary" onclick="stopAllPlayback()" style="font-size:10px;padding:4px 8px;">‚ñ† Stop</button>
                </h4>
                <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Lists Farey neighbors where both denominators form a twin prime pair. Click any pair to hear the interval between them as frequencies. Twin primes create distinctive harmonic relationships due to their close denominators.</p>
                <div id="twinPrimeList" class="residue-list"></div>
            </div>
            
            <div class="derivation-box" style="margin-top:15px;">
                <strong>Mathematical Background:</strong> The distribution of primes among Farey denominators reflects the Prime Number Theorem: œÄ(N) ~ N/ln(N). Twin primes (p, p+2) are conjectured to be infinite (unproven), with density governed by the twin prime constant C‚ÇÇ ‚âà 0.66. The Hardy-Littlewood conjecture predicts ~2C‚ÇÇN/(ln N)¬≤ twin primes up to N. In harmonic terms, prime denominators produce "pure" frequency ratios with fewer overtone conflicts.
            </div>
            
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('primes')">Screenshot Full Primes Tab</button></div>
        </div>
    </div>
    
    <!-- HARMONIC ANALYSIS TAB -->
    <div id="tab-harmonic" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #8b5cf6;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Harmonic Analysis & Arnold Tongues</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Map Farey fractions to musical frequencies, explore consonance/dissonance, and visualize Arnold tongues</p>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Frequency Ratio</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">f = f‚ÇÄ √ó (p/q)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Consonance Principle</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">Small q = Pure intervals</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">Arnold Tongue Width</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">‚àù K/q (coupling/denom)</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel" style="background:#0f172a;border:1px solid #334155;">
            <!-- Main Controls Row -->
            <div class="control-row" style="margin-bottom:10px;">
                <div class="control-group highlight">
                    <label>Base Freq:</label>
                    <div style="display:flex;gap:6px;align-items:center;">
                        <input type="range" id="harmonicBaseFreqSlider" min="20" max="880" value="220" oninput="syncHarmonicFreq('slider')" style="width:80px;">
                        <input type="number" id="harmonicBaseFreq" value="220" min="20" max="2000" oninput="syncHarmonicFreq('num')" style="width:60px;">
                        <span style="color:#64748b;">Hz</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Sector:</label>
                    <input type="number" id="harmonicSector" value="2" min="1" max="15" onchange="updateHarmonicTab()" style="width:50px;">
                </div>
                <div class="control-group">
                    <label>Max q:</label>
                    <div style="display:flex;gap:6px;align-items:center;">
                        <input type="range" id="harmonicMaxDenomSlider" min="4" max="64" value="32" oninput="syncHarmonicDenom('slider')" style="width:60px;">
                        <input type="number" id="harmonicMaxDenom" value="32" min="4" max="100" oninput="syncHarmonicDenom('num')" style="width:50px;">
                    </div>
                </div>
                <button onclick="updateHarmonicTab()">Refresh</button>
            </div>
            
            <!-- Presets Row -->
            <div class="control-row" style="margin-bottom:10px;">
                <span style="color:#94a3b8;font-size:11px;margin-right:8px;">Base Note:</span>
                <button onclick="setHarmonicBase(220)" class="secondary" style="font-size:10px;padding:4px 8px;">A3 (220)</button>
                <button onclick="setHarmonicBase(261.63)" class="secondary" style="font-size:10px;padding:4px 8px;">C4 (262)</button>
                <button onclick="setHarmonicBase(440)" class="secondary" style="font-size:10px;padding:4px 8px;border-color:#f59e0b;color:#f59e0b;">A4 (440)</button>
                <button onclick="setHarmonicBase(523.25)" class="secondary" style="font-size:10px;padding:4px 8px;">C5 (523)</button>
                <span style="color:#475569;margin:0 8px;">|</span>
                <span style="color:#94a3b8;font-size:11px;margin-right:8px;">Tuning:</span>
                <button onclick="setHarmonicPreset(2,16)" class="secondary" style="font-size:10px;padding:4px 8px;">Simple</button>
                <button onclick="setHarmonicPreset(2,32)" class="secondary" style="font-size:10px;padding:4px 8px;">Standard</button>
                <button onclick="setHarmonicPreset(2,64)" class="secondary" style="font-size:10px;padding:4px 8px;">Extended</button>
            </div>
            
            <!-- Playback Row -->
            <div class="control-row" style="background:rgba(34,197,94,0.1);padding:8px 12px;border-radius:6px;border:1px solid rgba(34,197,94,0.3);">
                <span style="color:#22c55e;font-size:11px;font-weight:600;margin-right:12px;">PLAYBACK</span>
                <button style="background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;padding:5px 12px;cursor:pointer;font-size:11px;" onclick="playHarmonicScale()">‚ñ∂ Scale Up</button>
                <button class="secondary" onclick="playHarmonicScale('down')" style="font-size:11px;padding:5px 12px;">‚ñº Scale Down</button>
                <button class="secondary" onclick="playHarmonicChord()" style="font-size:11px;padding:5px 12px;">‚ô´ Chord</button>
                <button class="secondary" onclick="playConsonantOnly()" style="font-size:11px;padding:5px 12px;border-color:#3b82f6;color:#3b82f6;">Pure Only</button>
                <button class="secondary" onclick="stopAllPlayback()" style="font-size:11px;padding:5px 12px;">‚ñ† Stop</button>
                <span style="color:#475569;margin:0 8px;">|</span>
                <label style="font-size:11px;">Speed: <input type="range" id="harmonicPlaySpeed" min="50" max="500" value="200" style="width:60px;"><span id="harmonicSpeedVal" style="color:#64748b;margin-left:4px;">200ms</span></label>
            </div>
        </div>
        
        <!-- Organized Stats Panels -->
        <div id="harmonicStats" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px;margin:15px 0;"></div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Arnold Tongues (Stern-Brocot)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Coupling K: <input type="range" id="arnoldCoupling" min="0" max="100" value="60" oninput="drawArnoldTongues()"></label>
                    <span id="arnoldCouplingVal" style="color:#8b5cf6;">0.60</span>
                    <label><input type="checkbox" id="arnoldShowLabels" checked onchange="drawArnoldTongues()"> Labels</label>
                </div>
                <canvas id="arnoldTongueCanvas" width="550" height="400"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Unison (q=1)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>Consonant (q‚â§4)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Complex (q‚â§16)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>Dissonant (q>16)</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Frequency Spectrum</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="freqLogScale" onchange="drawFrequencySpectrum()"> Log scale</label>
                    <label><input type="checkbox" id="freqShowOctaves" checked onchange="drawFrequencySpectrum()"> Octaves</label>
                    <label>Sort: <select id="freqSortMode" onchange="drawFrequencySpectrum()"><option value="freq">Frequency</option><option value="consonance">Consonance</option><option value="denom">Denominator</option></select></label>
                </div>
                <canvas id="freqSpectrumCanvas" width="550" height="400"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Frequency bars</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Octave lines</div>
                </div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Consonance Map</h4>
                <canvas id="consonanceMapCanvas" width="550" height="350"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>High consonance</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>Low consonance</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Interval Circle (Pitch Class)</h4>
                <canvas id="intervalCircleCanvas" width="550" height="350"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Fraction position</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>12-TET reference</div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Musical Intervals in Sector</h4>
            <div class="table-scroll" style="max-height:300px;">
                <table id="intervalTable">
                    <thead><tr><th>Fraction</th><th>Ratio</th><th>Frequency</th><th>Cents</th><th>Closest Note</th><th>Interval Name</th><th>Mode</th><th>Play</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Harmonic Theory:</strong> Fractions p/q with small denominators q produce consonant intervals. The ancient Greeks discovered that simple ratios like 2:1 (octave), 3:2 (fifth), and 4:3 (fourth) sound harmonious. Arnold tongues show how these ratios create stable "locking" regions in coupled oscillator systems - wider tongues indicate more robust synchronization.
        </div>
        
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('harmonic')">Screenshot Full Harmonic Tab</button></div>
    </div>
    
    <!-- PRIMORIAL SIEVE TAB -->
    <div id="tab-primorial" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Primorial Sieve & Farey Sector Connection</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Exploring how primorial residue classes connect to Farey sector distribution</p>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Primorial Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">œÜ(P_k)/P_k = ‚àè(1-1/p)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Unified Formula</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">C(n,N,a,k) = 3N¬≤/(œÄ¬≤n(n+1)œÜ(k))</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">30√ó2‚Åø Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">œÜ(30√ó2‚Åø)/(30√ó2‚Åø) = 4/15</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Primorial Base:</label>
                    <select id="primorialBase" onchange="updatePrimorialSieve()">
                        <option value="6">P‚ÇÇ = 6 (2√ó3)</option>
                        <option value="30" selected>P‚ÇÉ = 30 (2√ó3√ó5)</option>
                        <option value="210">P‚ÇÑ = 210 (2√ó3√ó5√ó7)</option>
                        <option value="2310">P‚ÇÖ = 2310 (2√ó3√ó5√ó7√ó11)</option>
                    </select>
                </div>
                <div class="control-group highlight">
                    <label>Power 2‚Åø:</label>
                    <input type="number" id="primorialPower" value="0" min="0" max="6" onchange="updatePrimorialSieve()">
                </div>
                <div class="control-group">
                    <label>Max N:</label>
                    <input type="number" id="primorialN" value="200" min="50" max="1000" onchange="updatePrimorialSieve()">
                </div>
                <div class="control-group">
                    <label>Sectors:</label>
                    <input type="number" id="primorialSectors" value="8" min="3" max="15" onchange="updatePrimorialSieve()">
                </div>
                <button onclick="updatePrimorialSieve()">Compute</button>
                <button class="secondary" onclick="animateLiftingTree()">Animate Lifting</button>
            </div>
        </div>
        
        <div class="stat-grid" id="primorialStats"></div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Sector √ó Residue Heatmap</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="heatmapNormalize" checked onchange="drawSectorResidueHeatmap()"> Normalize rows</label>
                    <label><input type="checkbox" id="heatmapShowValues" onchange="drawSectorResidueHeatmap()"> Show values</label>
                    <label>Color: <select id="heatmapColorScheme" onchange="drawSectorResidueHeatmap()"><option value="purple">Purple</option><option value="heat">Heat</option><option value="viridis">Viridis</option></select></label>
                </div>
                <canvas id="sectorResidueHeatmap" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#1e1b4b"></div>Low</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Medium</div><div class="color-legend-item"><div class="color-swatch" style="background:#c4b5fd"></div>High</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Density Constant Verification: œÜ(k√ó2‚Åø)/(k√ó2‚Åø)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Show up to 2^<input type="number" id="densityMaxPower" value="8" min="1" max="12" onchange="drawDensityConstant()"></label>
                    <label><input type="checkbox" id="densityShowTheory" checked onchange="drawDensityConstant()"> Theory line</label>
                </div>
                <canvas id="densityConstantCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual œÜ(m)/m</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Constant = œÜ(P_k)/P_k</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Lifting Tree: Residue Class Splitting</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Levels: <input type="number" id="liftingLevels" value="4" min="2" max="6" onchange="drawLiftingTree()"></label>
                    <label>Highlight sector: <input type="number" id="liftingSector" value="2" min="1" max="10" onchange="drawLiftingTree()"></label>
                    <label><input type="checkbox" id="liftingShowCounts" checked onchange="drawLiftingTree()"> Counts</label>
                </div>
                <canvas id="liftingTreeCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Residue class</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>In sector</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Split children</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Unified Formula Verification</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Residue class a: <select id="unifiedResidueClass" onchange="drawUnifiedFormulaChart()"></select></label>
                    <label><input type="checkbox" id="unifiedShowAll" onchange="drawUnifiedFormulaChart()"> All classes</label>
                </div>
                <canvas id="unifiedFormulaCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual C(n,N,a,k)</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Predicted 3N¬≤/(œÄ¬≤n(n+1)œÜ(k))</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Prime Distribution Across Residue Classes</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="primeDistShowExpected" checked onchange="drawPrimeDistribution()"> Expected line</label>
                    <label><input type="checkbox" id="primeDistBySector" onchange="drawPrimeDistribution()"> Split by sector</label>
                </div>
                <canvas id="primeDistributionCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime count</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Expected (uniform)</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Sector Uniformity Test</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Test sector: <input type="number" id="uniformitySector" value="2" min="1" max="10" onchange="drawUniformityTest()"></label>
                    <label><input type="checkbox" id="uniformityShowChiSq" checked onchange="drawUniformityTest()"> œá¬≤ stat</label>
                </div>
                <canvas id="uniformityTestCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Actual per class</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Expected C(n,N)/œÜ(k)</div></div>
            </div>
        </div>
        
        <div class="chart-box chart-wrapper" style="margin-top:15px;">
            <h4>Primorial Comparison: œÜ(P_k)/P_k ‚Üí 6/œÄ¬≤ Convergence</h4>
            <div class="control-row" style="margin-bottom:8px;">
                <label>Show primorials up to P_<input type="number" id="primorialCompareMax" value="8" min="3" max="12" onchange="drawPrimorialComparison()"></label>
                <label><input type="checkbox" id="primorialShowProduct" checked onchange="drawPrimorialComparison()"> Show ‚àè(1-1/p¬≤)</label>
                <label><input type="checkbox" id="primorialShowRatio" onchange="drawPrimorialComparison()"> Show ratio</label>
            </div>
            <canvas id="primorialComparisonCanvas" width="1100" height="350"></canvas>
            <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>œÜ(P_k)/P_k</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>‚àè(1-1/p¬≤) partial</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>6/œÄ¬≤</div></div>
        </div>
        
        <div class="panel" style="margin-top:15px;background:#0f172a;">
            <h4>Coprime Residue Classes for Current Modulus</h4>
            <div id="residueClassList" class="residue-list" style="max-height:150px;"></div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Sector √ó Residue Data Table</h4>
            <div class="table-scroll" style="max-height:300px;">
                <table id="sectorResidueTable">
                    <thead><tr><th>Sector</th><th>Total</th><th>Per Class Avg</th><th>œá¬≤ Stat</th><th>Uniform?</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Key Insight:</strong> The unified formula C(n,N,a,k) = 3N¬≤/(œÄ¬≤n(n+1)œÜ(k)) combines Farey sector distribution with primorial residue filtering. This shows that coprimes distribute uniformly across residue classes within each sector, and the density œÜ(30√ó2‚Åø)/(30√ó2‚Åø) = 4/15 remains constant under power-of-2 scaling.
        </div>
        
        <div style="margin-top:15px; padding:15px; background:#1e293b; border-radius:8px; border:1px solid #334155; text-align:center;">
            <button onclick="screenshotFullTab('primorial')" style="padding:12px 24px; font-size:14px;">Screenshot Full Primorial Tab</button>
            <button class="secondary" onclick="exportPrimorialData()" style="margin-left:10px; padding:12px 24px; font-size:14px;">Export Primorial Data</button>
        </div>
    </div>
    
    <!-- NUMBER THEORY TAB - Meissel-Lehmer Optimized Functions -->
    <div id="tab-numtheory" class="tab-content">
        <div class="panel">
            <h3 style="color:#8b5cf6;">Meissel-Lehmer Number Theory Engine</h3>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">
                <strong>Overview:</strong> This module implements sublinear algorithms for prime counting and totient summation. 
                The Meissel-Lehmer algorithm computes pi(x) in O(x^(2/3)) time instead of O(x), enabling analysis of much larger ranges.
                All primality tests use a precomputed sieve for O(1) lookup.
            </p>
            
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:15px;margin-bottom:20px;">
                <!-- Prime Counting pi(x) -->
                <div style="background:#1e293b;padding:15px;border-radius:8px;border:1px solid #334155;">
                    <h4 style="color:#22c55e;margin:0 0 12px 0;">Prime Counting Function pi(x)</h4>
                    <p style="color:#64748b;font-size:11px;margin-bottom:10px;">Count of primes less than or equal to x using Lucy_Hedgehog/Meissel-Lehmer</p>
                    <div style="display:flex;gap:8px;margin-bottom:10px;">
                        <input type="number" id="piInputX" value="1000000" min="2" style="flex:1;padding:8px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        <button onclick="computePiX()" style="padding:8px 16px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;">Compute pi(x)</button>
                    </div>
                    <div id="piResult" style="background:#0f172a;padding:12px;border-radius:6px;font-family:monospace;">
                        <div style="color:#64748b;font-size:11px;">Result:</div>
                        <div style="color:#22c55e;font-size:18px;font-weight:bold;">-</div>
                        <div id="piTime" style="color:#64748b;font-size:10px;margin-top:4px;"></div>
                    </div>
                </div>
                
                <!-- Summatory Totient -->
                <div style="background:#1e293b;padding:15px;border-radius:8px;border:1px solid #334155;">
                    <h4 style="color:#f59e0b;margin:0 0 12px 0;">Summatory Totient Sum(phi)</h4>
                    <p style="color:#64748b;font-size:11px;margin-bottom:10px;">Sum of phi(k) for k=1 to n. Asymptotically 3n^2/pi^2</p>
                    <div style="display:flex;gap:8px;margin-bottom:10px;">
                        <input type="number" id="sumPhiInputN" value="100000" min="1" style="flex:1;padding:8px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        <button onclick="computeSumPhi()" style="padding:8px 16px;background:linear-gradient(135deg,#f59e0b,#d97706);border:none;border-radius:4px;color:white;cursor:pointer;">Compute</button>
                    </div>
                    <div id="sumPhiResult" style="background:#0f172a;padding:12px;border-radius:6px;font-family:monospace;">
                        <div style="color:#64748b;font-size:11px;">Sum of phi(1) + phi(2) + ... + phi(n):</div>
                        <div style="color:#f59e0b;font-size:18px;font-weight:bold;">-</div>
                        <div id="sumPhiAsymptotic" style="color:#64748b;font-size:10px;margin-top:4px;"></div>
                    </div>
                </div>
                
                <!-- Single Number Analysis -->
                <div style="background:#1e293b;padding:15px;border-radius:8px;border:1px solid #334155;">
                    <h4 style="color:#6366f1;margin:0 0 12px 0;">Number Analysis</h4>
                    <p style="color:#64748b;font-size:11px;margin-bottom:10px;">Analyze a single number: primality, totient, factorization</p>
                    <div style="display:flex;gap:8px;margin-bottom:10px;">
                        <input type="number" id="numAnalysisInput" value="12345678" min="1" style="flex:1;padding:8px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        <button onclick="analyzeNumber()" style="padding:8px 16px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;">Analyze</button>
                    </div>
                    <div id="numAnalysisResult" style="background:#0f172a;padding:12px;border-radius:6px;font-family:monospace;font-size:11px;max-height:150px;overflow-y:auto;">
                        <div style="color:#64748b;">Enter a number to analyze</div>
                    </div>
                </div>
            </div>
            
            <!-- Nth Prime & Prime Range -->
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:15px;margin-bottom:20px;">
                <div style="background:#1e293b;padding:15px;border-radius:8px;border:1px solid #334155;">
                    <h4 style="color:#ec4899;margin:0 0 12px 0;">Nth Prime</h4>
                    <div style="display:flex;gap:8px;margin-bottom:10px;">
                        <input type="number" id="nthPrimeInput" value="10000" min="1" style="flex:1;padding:8px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        <button onclick="computeNthPrime()" style="padding:8px 16px;background:linear-gradient(135deg,#ec4899,#be185d);border:none;border-radius:4px;color:white;cursor:pointer;">Find</button>
                    </div>
                    <div id="nthPrimeResult" style="background:#0f172a;padding:10px;border-radius:6px;font-family:monospace;">
                        <span style="color:#64748b;">p<sub id="nthPrimeK">n</sub> = </span><span id="nthPrimeVal" style="color:#ec4899;font-size:16px;font-weight:bold;">-</span>
                    </div>
                </div>
                
                <div style="background:#1e293b;padding:15px;border-radius:8px;border:1px solid #334155;">
                    <h4 style="color:#14b8a6;margin:0 0 12px 0;">Primes in Range</h4>
                    <div style="display:flex;gap:8px;margin-bottom:10px;">
                        <input type="number" id="primeRangeLo" value="1000" min="2" placeholder="From" style="width:80px;padding:8px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        <input type="number" id="primeRangeHi" value="1100" min="2" placeholder="To" style="width:80px;padding:8px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        <button onclick="computePrimesInRange()" style="padding:8px 16px;background:linear-gradient(135deg,#14b8a6,#0d9488);border:none;border-radius:4px;color:white;cursor:pointer;">List</button>
                    </div>
                    <div id="primeRangeResult" style="background:#0f172a;padding:10px;border-radius:6px;font-family:monospace;font-size:10px;max-height:100px;overflow-y:auto;word-wrap:break-word;">
                        <span style="color:#64748b;">Enter range to list primes</span>
                    </div>
                </div>
            </div>
            
            <!-- Sieve Statistics -->
            <div style="background:#0f172a;padding:15px;border-radius:8px;border:1px solid #334155;margin-bottom:20px;">
                <h4 style="color:#a5b4fc;margin:0 0 12px 0;">Sieve Statistics & Performance</h4>
                <div id="sieveStats" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;">
                    <div style="text-align:center;padding:10px;background:#1e293b;border-radius:6px;">
                        <div style="color:#64748b;font-size:10px;">Sieve Limit</div>
                        <div id="statSieveLimit" style="color:#22c55e;font-size:16px;font-weight:bold;font-family:monospace;">0</div>
                    </div>
                    <div style="text-align:center;padding:10px;background:#1e293b;border-radius:6px;">
                        <div style="color:#64748b;font-size:10px;">Primes Cached</div>
                        <div id="statPrimeCount" style="color:#f59e0b;font-size:16px;font-weight:bold;font-family:monospace;">0</div>
                    </div>
                    <div style="text-align:center;padding:10px;background:#1e293b;border-radius:6px;">
                        <div style="color:#64748b;font-size:10px;">Phi Cache</div>
                        <div id="statPhiCache" style="color:#6366f1;font-size:16px;font-weight:bold;font-family:monospace;">0</div>
                    </div>
                    <div style="text-align:center;padding:10px;background:#1e293b;border-radius:6px;">
                        <div style="color:#64748b;font-size:10px;">Pi Cache</div>
                        <div id="statPiCache" style="color:#ec4899;font-size:16px;font-weight:bold;font-family:monospace;">0</div>
                    </div>
                </div>
                <div style="margin-top:12px;display:flex;gap:8px;">
                    <button onclick="updateSieveStats()" style="padding:6px 12px;font-size:11px;background:#334155;border:1px solid #475569;border-radius:4px;color:#e2e8f0;cursor:pointer;">Refresh Stats</button>
                    <button onclick="NumberTheory.clearCaches();updateSieveStats();" style="padding:6px 12px;font-size:11px;background:#dc2626;border:none;border-radius:4px;color:white;cursor:pointer;">Clear Caches</button>
                    <button onclick="benchmarkSieve()" style="padding:6px 12px;font-size:11px;background:#2563eb;border:none;border-radius:4px;color:white;cursor:pointer;">Run Benchmark</button>
                </div>
                <div id="benchmarkResult" style="margin-top:10px;padding:10px;background:#1e293b;border-radius:6px;font-family:monospace;font-size:11px;display:none;"></div>
            </div>
            
            <!-- Algorithm Info -->
            <div class="derivation-box" style="margin-top:15px;">
                <strong style="color:#8b5cf6;">Meissel-Lehmer Algorithm</strong><br><br>
                The classic prime counting function pi(x) counts primes up to x. While naive sieving takes O(x) time and space, 
                the Meissel-Lehmer algorithm achieves O(x^(2/3)) time complexity using the identity:<br><br>
                <div style="text-align:center;font-family:monospace;color:#22c55e;font-size:1.1em;margin:10px 0;">
                    pi(x) = phi(x, a) + a - 1 - P2(x,a) - P3(x,a) - ...
                </div>
                where phi(x,a) counts numbers up to x not divisible by the first a primes, and P_k counts contributions from products of exactly k primes.
                <br><br>
                <strong style="color:#f59e0b;">This implementation uses Lucy_Hedgehog</strong> - a simpler O(x^(2/3)) approach that maintains running counts V[i] and V[n/i] during a modified sieve process.
            </div>
        </div>
    </div>
    
    <!-- RESEARCH TAB -->
    <!-- HORIZON TAB -->
    <div id="tab-horizon" class="tab-content">
        <div class="panel">
            <h3 style="color:#00ff88;">Farey Horizon & Mediant Generation</h3>
            
            <div style="background:#1a1a2e;padding:20px;border-radius:8px;border-left:4px solid #00ff88;margin-bottom:20px;">
                <h4 style="color:#00ff88;margin-top:0;">The Mediant Operation</h4>
                <p>Given two Farey neighbors <span style="font-family:monospace;">a/b</span> and <span style="font-family:monospace;">c/d</span>, their <span style="color:#ff9f43;font-weight:bold;">mediant</span> is:</p>
                <div style="background:#0f172a;padding:15px;border-radius:6px;text-align:center;font-size:1.3em;font-family:monospace;color:#00ff88;margin:15px 0;">med(a/b, c/d) = (a+c)/(b+d)</div>
                <p style="color:#94a3b8;font-size:0.9em;">The mediant always lies strictly between its parents and is in lowest terms when the parents are Farey neighbors (|ad - bc| = 1).</p>
            </div>
            
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;">
                <div style="background:#1a1a2e;padding:20px;border-radius:8px;border-left:4px solid #5588ff;">
                    <h4 style="color:#5588ff;margin-top:0;">Sector Boundaries</h4>
                    <p>Sector S<sub>n</sub> = (1/(n+1), 1/n] is bounded by:</p>
                    <ul style="color:#94a3b8;">
                        <li><strong style="color:#e2e8f0;">Left boundary:</strong> 1/(n+1)</li>
                        <li><strong style="color:#e2e8f0;">Right boundary:</strong> 1/n</li>
                    </ul>
                    <p>The <span style="color:#ff6b6b;font-weight:bold;">Gatekeeper</span> 2/(2n+1) is the mediant of these boundaries.</p>
                </div>
                <div style="background:#1a1a2e;padding:20px;border-radius:8px;border-left:4px solid #a855f7;">
                    <h4 style="color:#a855f7;margin-top:0;">Tree Confinement</h4>
                    <p><strong style="color:#e2e8f0;">Key insight:</strong> Mediants generated within a sector stay confined to that sector.</p>
                    <p style="color:#94a3b8;font-size:0.9em;">If a/b ‚àà S<sub>n</sub> and we take mediants with the sector boundaries, all descendants remain in S<sub>n</sub>.</p>
                    <p style="color:#94a3b8;font-size:0.9em;">The Stern-Brocot subtree rooted at the Gatekeeper generates exactly the fractions in S<sub>n</sub> ‚à© F<sub>N</sub>.</p>
                </div>
            </div>
            
            <div style="background:#1e2d3d;padding:20px;border-radius:8px;margin-bottom:20px;">
                <h4 style="margin-top:0;">Explorer Controls</h4>
                <div class="control-row">
                    <label>Sector n:</label>
                    <input type="number" id="horizonSectorN" value="5" min="1" max="500">
                    <label>Max Denom N:</label>
                    <input type="number" id="horizonMaxN" value="50" min="3" max="1000">
                    <button onclick="generateHorizon()">Generate</button>
                    <button style="background:linear-gradient(135deg,#22c55e,#16a34a);" onclick="playHorizonSequence()">‚ñ∂ Play</button>
                    <button style="background:linear-gradient(135deg,#6366f1,#8b5cf6);" onclick="playHorizonSequenceBackward()">‚óÄ Backward</button>
                    <button style="background:#ef4444;" onclick="stopAllPlayback()">‚ñ† Stop</button>
                </div>
            </div>
            
            <div id="horizonHarmonicInfo" style="background:linear-gradient(135deg,#1e1b4b,#312e81);padding:15px;border-radius:8px;margin-bottom:20px;display:none;">
                <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap;">
                    <div>
                        <span style="color:#94a3b8;font-size:11px;">Selected:</span>
                        <span id="horizonSelectedFrac" style="color:#8b5cf6;font-size:1.3em;font-weight:bold;margin-left:8px;">-</span>
                    </div>
                    <div>
                        <span style="color:#94a3b8;font-size:11px;">Frequency:</span>
                        <span id="horizonFreq" style="color:#22c55e;font-size:1.1em;margin-left:8px;">- Hz</span>
                    </div>
                    <div>
                        <span style="color:#94a3b8;font-size:11px;">Note:</span>
                        <span id="horizonNote" style="color:#f59e0b;font-size:1.1em;margin-left:8px;">-</span>
                    </div>
                    <div>
                        <span style="color:#94a3b8;font-size:11px;">Mode:</span>
                        <span id="horizonMode" style="margin-left:8px;">-</span>
                    </div>
                </div>
            </div>
            
            <div style="background:#111;border-radius:10px;padding:15px;margin-bottom:20px;">
                <canvas id="horizonCanvas" width="1100" height="200"></canvas>
                <div style="display:flex;gap:20px;justify-content:center;margin-top:15px;flex-wrap:wrap;">
                    <div style="display:flex;align-items:center;gap:5px;font-size:0.85em;"><div style="width:16px;height:16px;border-radius:3px;background:#5588ff;"></div> Boundary</div>
                    <div style="display:flex;align-items:center;gap:5px;font-size:0.85em;"><div style="width:16px;height:16px;border-radius:3px;background:#ff6b6b;"></div> Gatekeeper</div>
                    <div style="display:flex;align-items:center;gap:5px;font-size:0.85em;"><div style="width:16px;height:16px;border-radius:3px;background:#00ff88;"></div> Mediant Children</div>
                </div>
            </div>
            
            <div id="horizonStats" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:20px;"></div>
            
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
                <div style="background:#1a1a2e;padding:20px;border-radius:8px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:8px;">
                        <h4 style="color:#a78bfa;margin:0;">Mediant Generation Tree</h4>
                        <div style="display:flex;gap:6px;align-items:center;">
                            <select id="horizonTreeFormat" onchange="updateHorizonTree(horizonData, parseInt(document.getElementById('horizonSectorN').value))" style="padding:4px 8px;font-size:11px;background:#1e1b4b;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                                <option value="fraction">Use Global</option>
                                <option value="decimal2">Decimal (2)</option>
                                <option value="decimal4">Decimal (4)</option>
                                <option value="decimal6">Decimal (6)</option>
                                <option value="decimal8">Decimal (8)</option>
                            </select>
                            <button onclick="playHorizonByGeneration('forward')" style="padding:5px 10px;font-size:11px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;" title="Play generations forward">‚ñ∂ Gen‚Üí</button>
                            <button onclick="playHorizonByGeneration('backward')" style="padding:5px 10px;font-size:11px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;" title="Play generations backward">‚ÜêGen ‚óÄ</button>
                        </div>
                    </div>
                    <div id="horizonTreeDisplay" style="background:#0f172a;padding:15px;border-radius:6px;font-family:monospace;font-size:0.85em;max-height:300px;overflow-y:auto;">Select parameters and click Generate</div>
                </div>
                <div style="background:#1a1a2e;padding:20px;border-radius:8px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:8px;">
                        <h4 style="color:#a78bfa;margin:0;">Fractions in Sector (by value)</h4>
                        <div style="display:flex;gap:6px;align-items:center;">
                            <select id="horizonListFormat" onchange="updateHorizonFractionList(horizonData)" style="padding:4px 8px;font-size:11px;background:#1e1b4b;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                                <option value="fraction">Use Global</option>
                                <option value="decimal2">Decimal (2)</option>
                                <option value="decimal4">Decimal (4)</option>
                                <option value="decimal6">Decimal (6)</option>
                                <option value="decimal8">Decimal (8)</option>
                            </select>
                            <button onclick="playHorizonByValue('forward')" style="padding:5px 10px;font-size:11px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;" title="Play by value ascending">‚ñ∂ 0‚Üí1</button>
                            <button onclick="playHorizonByValue('backward')" style="padding:5px 10px;font-size:11px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;" title="Play by value descending">1‚Üí0 ‚óÄ</button>
                        </div>
                    </div>
                    <div id="horizonFractionList" style="background:#0f172a;padding:15px;border-radius:6px;font-family:monospace;font-size:0.85em;max-height:300px;overflow-y:auto;">-</div>
                </div>
            </div>
            
            <div style="margin-top:20px;display:flex;gap:10px;flex-wrap:wrap;">
                <button onclick="screenshotFullTab('horizon')">Screenshot Full Horizon Tab</button>
                <button onclick="exportHorizonCanvas()" class="secondary">Export Number Line (4K)</button>
                <button onclick="exportHorizonData()" class="secondary">Export Data (CSV)</button>
            </div>
        </div>
    </div>

    <div id="tab-research" class="tab-content">
        <div class="panel">
            <h3>Research Tools</h3>
            
            <h4>Custom Formula Tester</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>Formula C(n,N) = </label>
                <input type="text" id="customFormula" value="3*N*N/(Math.PI*Math.PI*n*(n+1))" style="width:300px;">
                <button onclick="testCustomFormula()">Test</button>
            </div>
            <div class="chart-box" style="margin-top:12px;"><h4>Custom vs Standard</h4><canvas id="customFormulaChart"></canvas></div>
            
            <h4 style="margin-top:20px;">Batch Parameter Sweep</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>N range: <input type="number" id="batchNMin" value="50"> to <input type="number" id="batchNMax" value="200"> step <input type="number" id="batchNStep" value="10"></label>
                <button onclick="runBatchSweep()">Run Sweep</button>
            </div>
            <div class="table-scroll" style="margin-top:12px;"><table id="batchTable"><thead><tr><th>N</th><th>|F_N|</th><th>Œ£|Œ¥|</th><th>Œ£|Œ¥|/‚àöN</th><th>Max Gap</th><th>Mean Gap</th></tr></thead><tbody></tbody></table></div>
            
            <h4 style="margin-top:20px;">Publication Export</h4>
            <div class="control-row" style="margin:12px 0;">
                <button onclick="exportLatexFigures()">LaTeX Figures</button>
                <button onclick="exportCSVAll()">Full CSV</button>
                <button onclick="exportJSON()">JSON Data</button>
            </div>
            <div class="latex-output" id="latexFigures"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('research')">Screenshot Full Research Tab</button></div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="pointModal"><div class="modal-content" style="max-width:450px;"><div class="modal-header"><h3 id="pointModalTitle">Point</h3><button class="modal-close" onclick="closePointModal()">x</button></div><div class="modal-body" id="pointModalBody"></div></div></div>

<div class="modal-overlay" id="sectorModal"><div class="modal-content" style="max-width:700px;"><div class="modal-header"><h3 id="sectorModalTitle">Sector Details</h3><button class="modal-close" onclick="closeSectorModal()">x</button></div><div class="modal-body" id="sectorModalBody"></div></div></div>

    <!-- REFERENCES TAB -->
    <div id="tab-references" class="tab-content">
        <div class="panel">
            <h2 style="text-align:center; font-size:1.4em; margin-bottom:8px;">References & Acknowledgments</h2>
            <p style="text-align:center; color:#94a3b8; font-style:italic; margin-bottom:25px;">Foundational works and resources underlying this exploration</p>
            
            <h3 style="color:#6366f1; border-bottom:2px solid #6366f1; padding-bottom:8px;">Classical Number Theory</h3>
            
            <div class="theorem-box" style="background:#1e1b4b; margin:15px 0;">
                <strong style="color:#c4b5fd;">Euler, Leonhard (1737)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">"Variae observationes circa series infinitas" - Introduction of the totient function œÜ(n) and the product formula for Œ∂(s). Established the fundamental result that the density of coprime pairs is 6/œÄ¬≤.</p>
            </div>
            
            <div class="theorem-box" style="background:#1e1b4b; margin:15px 0;">
                <strong style="color:#c4b5fd;">Mertens, Franz (1874)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">"Ein Beitrag zur analytischen Zahlentheorie" - Asymptotic formula for the summatory totient function: Œ£œÜ(n) = (3/œÄ¬≤)N¬≤ + O(N log N). This result is central to our sector density theorem.</p>
            </div>
            
            <div class="theorem-box" style="background:#1e1b4b; margin:15px 0;">
                <strong style="color:#c4b5fd;">Farey, John (1816)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">Letter to Philosophical Magazine describing the mediant property of Farey sequences. The sequence F_N of fractions p/q with 0 ‚â§ p ‚â§ q ‚â§ N and gcd(p,q) = 1 forms the basis of our sector decomposition.</p>
            </div>
            
            <div class="theorem-box" style="background:#1e1b4b; margin:15px 0;">
                <strong style="color:#c4b5fd;">Cauchy, Augustin-Louis (1816)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">First rigorous proof of the Farey sequence mediant property, establishing that between any two adjacent Farey fractions a/b and c/d, we have |ad - bc| = 1.</p>
            </div>
            
            <h3 style="color:#22c55e; border-bottom:2px solid #22c55e; padding-bottom:8px; margin-top:25px;">Connections to the Riemann Hypothesis</h3>
            
            <div class="theorem-box" style="background:#064e3b; margin:15px 0;">
                <strong style="color:#6ee7b7;">Franel, J√©r√¥me (1924)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">"Les suites de Farey et le probl√®me des nombres premiers" - Demonstrated that RH is equivalent to: Œ£|F_k - k/|F_N|| = O(N^(1/2+Œµ)) for any Œµ > 0.</p>
            </div>
            
            <div class="theorem-box" style="background:#064e3b; margin:15px 0;">
                <strong style="color:#6ee7b7;">Landau, Edmund (1924)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">Independent proof of the Franel connection, establishing Farey sequences as a geometric lens for viewing prime distribution and the Riemann Hypothesis.</p>
            </div>
            
            <h3 style="color:#f59e0b; border-bottom:2px solid #f59e0b; padding-bottom:8px; margin-top:25px;">Computational Number Theory</h3>
            
            <div class="theorem-box" style="background:#422006; margin:15px 0;">
                <strong style="color:#fcd34d;">Meissel, Ernst (1870) & Lehmer, Derrick Henry (1959)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">Development of the Meissel-Lehmer algorithm for computing œÄ(x), the prime counting function, in sublinear time. This work enables efficient computation of prime distributions used in our P/C analysis.</p>
            </div>
            
            <div class="theorem-box" style="background:#422006; margin:15px 0;">
                <strong style="color:#fcd34d;">Stern, Moritz (1858) & Brocot, Achille (1861)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">Independent discovery of the Stern-Brocot tree, a binary tree structure that generates all positive rationals exactly once in lowest terms. Our tree path visualization and audio playback use this structure.</p>
            </div>
            
            <h3 style="color:#ec4899; border-bottom:2px solid #ec4899; padding-bottom:8px; margin-top:25px;">Harmonic Analysis & Music Theory</h3>
            
            <div class="theorem-box" style="background:#4c1d4c; margin:15px 0;">
                <strong style="color:#f9a8d4;">Pythagoras (c. 500 BCE)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">Discovery that consonant musical intervals correspond to simple rational frequency ratios. The audio features in this tool map Farey fractions to harmonic intervals, connecting number theory to acoustic perception.</p>
            </div>
            
            <div class="theorem-box" style="background:#4c1d4c; margin:15px 0;">
                <strong style="color:#f9a8d4;">Dedekind, Richard (1877)</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;">"Schreiben an Herrn Borchardt √ºber die Theorie der elliptischen Modulfunktionen" - Introduction of the Dedekind eta function and Dedekind sums, connecting modular forms to number theory.</p>
            </div>
            
            <h3 style="color:#06b6d4; border-bottom:2px solid #06b6d4; padding-bottom:8px; margin-top:25px;">Modern References</h3>
            
            <div class="theorem-box" style="background:#164e63; margin:15px 0;">
                <strong style="color:#67e8f9;">Hardy, G.H. & Wright, E.M.</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;"><em>An Introduction to the Theory of Numbers</em> (Oxford University Press) - Comprehensive treatment of Farey sequences, totient function, and continued fractions. Essential reference for theoretical foundations.</p>
            </div>
            
            <div class="theorem-box" style="background:#164e63; margin:15px 0;">
                <strong style="color:#67e8f9;">Graham, Knuth & Patashnik</strong>
                <p style="margin:8px 0 0 0; font-size:0.9em; color:#e2e8f0;"><em>Concrete Mathematics</em> (Addison-Wesley) - Detailed treatment of the Stern-Brocot tree and its algorithmic applications.</p>
            </div>
            
            <h3 style="color:#a78bfa; border-bottom:2px solid #a78bfa; padding-bottom:8px; margin-top:25px;">Original Contributions</h3>
            
            <div class="derivation-box" style="background: linear-gradient(135deg, #312e81 0%, #4c1d95 100%); border-left-color: #a78bfa; margin:15px 0;">
                <strong style="color:#e0e7ff; font-size:1.1em;">Getachew, Wessen (2024-2025)</strong>
                <p style="margin:12px 0 0 0; font-size:0.95em; color:#e2e8f0;"><strong>Novel contributions presented in this work:</strong></p>
                <ul style="margin:10px 0 0 15px; font-size:0.9em; color:#c7d2fe;">
                    <li><strong>Farey Sector Density Theorem:</strong> Explicit asymptotic formula C(n,N) ~ (3/œÄ¬≤)N¬≤/(n(n+1)) for coprime pairs in directional sectors.</li>
                    <li><strong>Sector Boundary Constant:</strong> Identification of n* ‚âà (‚àö3/œÄ)N ‚âà 0.5513N as the phase transition between analytic and discrete regimes.</li>
                    <li><strong>Prime/Composite Identity System:</strong> Four-way decomposition (PP, PC, CP, CC) with exact sector-level counting identities.</li>
                    <li><strong>Interactive Visualization Framework:</strong> Comprehensive tools for exploring sector structure, including ring visualization, tree paths, and harmonic sonification.</li>
                    <li><strong>Boundary Phase Transition Analysis:</strong> Documentation of the transition from density-based prediction to discrete counting at the sector boundary.</li>
                </ul>
            </div>
            
            <h3 style="color:#64748b; border-bottom:2px solid #475569; padding-bottom:8px; margin-top:25px;">Software & Tools</h3>
            
            <div style="background:#1e293b; padding:15px; border-radius:8px; margin:15px 0;">
                <p style="margin:0; font-size:0.9em; color:#94a3b8;">This interactive explorer was developed using:</p>
                <ul style="margin:10px 0 0 15px; font-size:0.85em; color:#cbd5e1;">
                    <li>Pure JavaScript for computation and visualization</li>
                    <li>HTML5 Canvas for ring, tree, and chart rendering</li>
                    <li>Web Audio API for harmonic sonification</li>
                    <li>Chart.js for statistical visualizations</li>
                    <li>Custom implementations of Meissel-Lehmer algorithm, Stern-Brocot tree traversal, and Farey sequence generation</li>
                </ul>
            </div>
            
            <div style="margin-top:25px; padding:15px; background:linear-gradient(135deg, #1e1b4b, #312e81); border-radius:8px; text-align:center;">
                <p style="margin:0; color:#c7d2fe; font-size:0.95em;">"Mathematics is the music of reason." ‚Äî James Joseph Sylvester</p>
                <p style="margin:10px 0 0 0; color:#94a3b8; font-size:0.85em;">This work bridges the visual, auditory, and analytical dimensions of number theory.</p>
            </div>
            
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('references')">Screenshot Full References Tab</button></div>
        </div>
    </div>

<div class="screenshot-overlay" id="screenshotOverlay">
    <h3 style="color:#f1f5f9; margin-bottom:20px;">Screenshot Preview (with Legend)</h3>
    <img id="screenshotPreview" class="screenshot-preview">
    <div class="screenshot-actions">
        <button onclick="downloadScreenshot()">Download PNG</button>
        <button onclick="copyScreenshot()">Copy to Clipboard</button>
        <button class="secondary" onclick="closeScreenshotOverlay()">Close</button>
    </div>
</div>

<script>
const state = {
    mode: 'exact', nMin: 1, nMax: 500, sectorMin: 1, sectorMax: 275,
    sectors: [], residuesBySector: {}, allResidues: [], gaps: [], farey: [],
    computing: false, charts: {}, ringPoints: [], animationId: null,
    sectorBoundConstant: Math.sqrt(3) / Math.PI, // Default ‚àö3/œÄ
    // Bounded window data for P/C analysis in large N mode
    boundedResiduesBySector: {},
    boundedN: 2000,
    useBoundedPC: true,
    // Highlight specific sector when showing all (dim others)
    highlightSectorOnly: null
};

// Tree view state for Stern-Brocot visualization
let treeViewState = { zoom: 100, offsetX: 0, offsetY: 0 };

const sectorColors = ['#6366f1','#8b5cf6','#a855f7','#d946ef','#ec4899','#f43f5e','#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#22c55e','#10b981','#14b8a6','#06b6d4','#0ea5e9','#3b82f6'];
function getSectorColor(n) { return sectorColors[(n) % sectorColors.length]; }

// Ring loop playback state
let highlightedRingM = null;

// Safe array max/min that won't overflow stack with large arrays
function safeMax(arr, defaultVal = -Infinity) {
    if (!arr || arr.length === 0) return defaultVal;
    return arr.reduce((max, v) => v > max ? v : max, arr[0]);
}
function safeMin(arr, defaultVal = Infinity) {
    if (!arr || arr.length === 0) return defaultVal;
    return arr.reduce((min, v) => v < min ? v : min, arr[0]);
}

// Canvas state
let currentScreenshotData = null;

function downloadScreenshot() {
    if (!currentScreenshotData) return;
    const a = document.createElement('a');
    a.href = currentScreenshotData;
    a.download = 'farey_chart_' + Date.now() + '.png';
    a.click();
}

async function copyScreenshot() {
    if (!currentScreenshotData) return;
    try {
        const blob = await (await fetch(currentScreenshotData)).blob();
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
        alert('Copied to clipboard!');
    } catch (e) {
        alert('Copy failed: ' + e.message);
    }
}

function closeScreenshotOverlay() {
    document.getElementById('screenshotOverlay').classList.remove('active');
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = 'Sector ' + n + ': (1/' + (n+1) + ', 1/' + n + ']';
    
    let primesHtml = primes.length > 0 
        ? primes.map(p => '<span class="residue-item prime" title="m=' + p.m + ' is prime">' + p.r + '/' + p.m + '</span>').join('') 
        : '<span style="color:#64748b">No prime moduli in this sector</span>';
    
    let compositesHtml = composites.length > 0 
        ? composites.slice(0,100).map(c => '<span class="residue-item">' + c.r + '/' + c.m + '</span>').join('') 
        : '<span style="color:#64748b">No composite moduli in this sector</span>';
    
    if (composites.length > 100) {
        compositesHtml += '<span style="color:#64748b; display:block; margin-top:8px;">... and ' + (composites.length - 100) + ' more</span>';
    }
    
    let html = '<div class="stat-grid" style="margin-bottom:15px;">' +
        '<div class="stat-card"><div class="stat-value">' + res.length + '</div><div class="stat-label">Total Pairs</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#f59e0b">' + primes.length + '</div><div class="stat-label">Prime Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#6366f1">' + composites.length + '</div><div class="stat-label">Composite Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector ? fmt(sector.predicted) : '-') + '</div><div class="stat-label">Predicted</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-') + '</div><div class="stat-label">Error</div></div>' +
        '</div>' +
        '<h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (' + primes.length + ')</h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(245,158,11,0.3);">' + primesHtml + '</div>' +
        '<h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (' + composites.length + ') <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(99,102,241,0.3);">' + compositesHtml + '</div>' +
        '<div style="margin-top:15px; display:flex; gap:10px; flex-wrap:wrap;">' +
        '<button onclick="playSectorAudio(' + n + ',\'forward\')" style="background:linear-gradient(135deg,#22c55e,#16a34a);padding:8px 16px;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ∂ Play All Forward</button>' +
        '<button onclick="playSectorAudio(' + n + ',\'backward\')" style="background:linear-gradient(135deg,#6366f1,#8b5cf6);padding:8px 16px;border:none;border-radius:5px;color:white;cursor:pointer;">‚óÄ Play Backward</button>' +
        '<button onclick="playSectorPrimes(' + n + ')" style="background:linear-gradient(135deg,#f59e0b,#d97706);padding:8px 16px;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ∂ Primes Only</button>' +
        '<button onclick="stopAllPlayback()" style="background:#ef4444;padding:8px 16px;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ† Stop</button>' +
        '<button onclick="exportSectorData(' + n + ')">Export CSV</button>' +
        '<button class="secondary" onclick="viewSectorOnRing(' + n + ')">View on Ring</button>' +
        '</div>';
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += r.r + ',' + r.m + ',' + r.value + ',' + r.isPrime + '\n';
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'sector_' + n + '_data.csv';
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

// Simple canvas-only screenshot
function screenshotCanvas(canvasId) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) { alert('Canvas not found'); return; }
    
    const link = document.createElement('a');
    link.download = `${canvasId}_${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

function screenshotMainCanvas() {
    const canvas = document.getElementById('mainRing');
    if (!canvas) { alert('Canvas not found'); return; }
    
    const padding = 20;
    const solverResultsEl = document.getElementById('solverResults');
    const hasSolver = solverResultsEl && solverResultsEl.style.display !== 'none' && solverCurrentMatch !== null;
    
    // Get error chart
    const errorChart = document.getElementById('mainErrorChart');
    const hasErrorChart = errorChart && state.sectors.some(s => s.relError !== null);
    
    // Get alternatives data directly from DOM table
    const altEl = document.getElementById('solverAlternatives');
    let alternativesData = [];
    if (altEl) {
        const table = altEl.querySelector('table');
        if (table) {
            const rows = table.querySelectorAll('tr');
            for (let i = 1; i < rows.length; i++) { // skip header
                const cells = rows[i].querySelectorAll('td');
                if (cells.length >= 5) {
                    alternativesData.push({
                        frac: cells[0]?.textContent?.trim() || '',
                        dec: cells[1]?.textContent?.trim() || '',
                        err: cells[2]?.textContent?.trim() || '',
                        sec: cells[3]?.textContent?.trim() || '',
                        typ: cells[4]?.textContent?.trim() || '',
                        typColor: cells[4]?.style?.color || '#94a3b8',
                        isBest: (rows[i].getAttribute('style') || '').includes('background')
                    });
                }
            }
        }
    }
    
    // Layout dimensions
    const legendHeight = 100;
    const errorChartHeight = hasErrorChart ? 200 : 0;
    const leftContentWidth = canvas.width;
    const leftContentHeight = canvas.height + legendHeight + errorChartHeight + 40;
    
    // Calculate solver panel dimensions
    const solverPanelWidth = hasSolver ? 480 : 0;
    const baseFieldsHeight = 380;
    const altHeaderHeight = alternativesData.length > 0 ? 50 : 0;
    const altRowsHeight = Math.min(alternativesData.length, 25) * 18;
    const solverPanelHeight = hasSolver ? Math.max(leftContentHeight, baseFieldsHeight + altHeaderHeight + altRowsHeight + 50) : 0;
    
    // Create a temporary canvas with dark background
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = leftContentWidth + padding * 2 + solverPanelWidth;
    tempCanvas.height = Math.max(leftContentHeight + padding * 2, solverPanelHeight + padding * 2);
    const ctx = tempCanvas.getContext('2d');
    
    // Dark background matching the app theme
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
    
    // Draw the main ring canvas
    ctx.drawImage(canvas, padding, padding);
    
    // Draw Legend below ring
    let legendY = padding + canvas.height + 15;
    
    // Legend panel background
    ctx.fillStyle = '#1e1b4b';
    ctx.fillRect(padding, legendY, leftContentWidth, legendHeight - 10);
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 1;
    ctx.strokeRect(padding, legendY, leftContentWidth, legendHeight - 10);
    
    // Sector colors legend (S1-S10)
    ctx.fillStyle = '#a5b4fc';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('SECTORS', padding + 10, legendY + 18);
    
    const sectorStartX = padding + 70;
    for (let i = 1; i <= 10; i++) {
        const hue = ((i - 1) * 36) % 360;
        const color = `hsl(${hue}, 70%, 50%)`;
        const x = sectorStartX + (i - 1) * 55;
        
        // Color swatch
        ctx.fillStyle = color;
        ctx.fillRect(x, legendY + 8, 14, 14);
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, legendY + 8, 14, 14);
        
        // Label
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '10px monospace';
        ctx.fillText(`S${i}`, x + 18, legendY + 18);
    }
    
    // Categories legend
    ctx.fillStyle = '#a5b4fc';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('CATEGORIES', padding + 10, legendY + 45);
    
    const categories = [
        { code: 'PP', label: 'Both Prime', color: '#22c55e' },
        { code: 'PC', label: 'Prime/Comp', color: '#f59e0b' },
        { code: 'CP', label: 'Comp/Prime', color: '#6366f1' },
        { code: 'CC', label: 'Both Comp', color: '#94a3b8' }
    ];
    
    const catStartX = padding + 90;
    categories.forEach((cat, i) => {
        const x = catStartX + i * 130;
        
        // Color swatch
        ctx.fillStyle = cat.color;
        ctx.fillRect(x, legendY + 35, 14, 14);
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, legendY + 35, 14, 14);
        
        // Label
        ctx.fillStyle = '#e2e8f0';
        ctx.font = 'bold 10px monospace';
        ctx.fillText(cat.code, x + 18, legendY + 45);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '9px system-ui';
        ctx.fillText(cat.label, x + 38, legendY + 45);
    });
    
    // Denom type legend
    ctx.fillStyle = '#a5b4fc';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('DENOM', padding + 10, legendY + 72);
    
    const denomTypes = [
        { label: 'Prime (m)', color: '#f59e0b' },
        { label: 'Composite (m)', color: '#6366f1' }
    ];
    
    const denomStartX = padding + 70;
    denomTypes.forEach((dt, i) => {
        const x = denomStartX + i * 130;
        
        ctx.fillStyle = dt.color;
        ctx.fillRect(x, legendY + 62, 14, 14);
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, legendY + 62, 14, 14);
        
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '10px system-ui';
        ctx.fillText(dt.label, x + 18, legendY + 72);
    });
    
    // Draw Error Chart below legend
    if (hasErrorChart) {
        const chartY = legendY + legendHeight + 5;
        
        // Chart title
        ctx.fillStyle = '#a78bfa';
        ctx.font = 'bold 12px system-ui';
        ctx.fillText('RELATIVE ERROR %', padding + 10, chartY + 15);
        
        // Draw the error chart
        ctx.drawImage(errorChart, padding, chartY + 20, leftContentWidth, errorChartHeight - 30);
    }
    
    // Add solver data on the right if visible
    if (hasSolver) {
        const solverX = leftContentWidth + padding * 2;
        const solverY = padding;
        const panelWidth = solverPanelWidth - padding;
        const panelHeight = solverPanelHeight;
        
        // Read all values from DOM
        const bestFrac = document.getElementById('solverBestFrac')?.textContent || '-';
        const decimal = document.getElementById('solverBestDecimal')?.textContent || '-';
        const error = document.getElementById('solverError')?.textContent || '-';
        const sector = document.getElementById('solverSector')?.textContent || '-';
        const category = document.getElementById('solverCategory')?.textContent || '-';
        const categoryColor = document.getElementById('solverCategory')?.style.color || '#94a3b8';
        const denomType = document.getElementById('solverDenomType')?.textContent || '-';
        const denomTypeColor = document.getElementById('solverDenomType')?.style.color || '#94a3b8';
        const cf = document.getElementById('solverCF')?.textContent || '-';
        const gear = document.getElementById('solverGear')?.textContent || '-';
        const path = document.getElementById('solverPath')?.textContent || '-';
        
        // Solver panel background
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(solverX, solverY, panelWidth, panelHeight);
        ctx.strokeStyle = '#10b981';
        ctx.lineWidth = 2;
        ctx.strokeRect(solverX, solverY, panelWidth, panelHeight);
        
        // Header bar
        ctx.fillStyle = '#064e3b';
        ctx.fillRect(solverX + 2, solverY + 2, panelWidth - 4, 32);
        
        // Title
        ctx.fillStyle = '#6ee7b7';
        ctx.font = 'bold 13px system-ui';
        ctx.fillText('TARGET RATIO SOLVER', solverX + 12, solverY + 22);
        
        let y = solverY + 50;
        const x = solverX + 12;
        const lineHeight = 22;
        
        // Helper to draw a labeled value
        const drawField = (label, value, valueColor = '#e2e8f0', fontSize = 14) => {
            ctx.fillStyle = '#6ee7b7';
            ctx.font = '10px system-ui';
            ctx.fillText(label, x, y);
            ctx.fillStyle = valueColor;
            ctx.font = `${fontSize}px monospace`;
            const maxLen = Math.floor((panelWidth - 24) / (fontSize * 0.6));
            const displayVal = value.length > maxLen ? value.substring(0, maxLen - 3) + '...' : value;
            ctx.fillText(displayVal, x, y + 14);
            y += lineHeight + 10;
        };
        
        // Best Match (large)
        ctx.fillStyle = '#6ee7b7';
        ctx.font = '10px system-ui';
        ctx.fillText('BEST MATCH', x, y);
        ctx.fillStyle = '#f0fdf4';
        ctx.font = 'bold 28px monospace';
        ctx.fillText(bestFrac, x, y + 28);
        y += 42;
        
        // Decimal Value
        drawField('DECIMAL VALUE', decimal, '#a7f3d0', 15);
        
        // Error
        drawField('ERROR', error, '#fbbf24', 14);
        
        // Sector
        drawField('SECTOR', sector, '#a78bfa', 14);
        
        // Category
        drawField('CATEGORY', category, categoryColor, 14);
        
        // Denom Type
        drawField('DENOM TYPE', denomType, denomTypeColor, 14);
        
        // Gear Ratio
        drawField('GEAR RATIO', gear, '#f472b6', 14);
        
        // Continued Fraction (compact)
        ctx.fillStyle = '#6ee7b7';
        ctx.font = '10px system-ui';
        ctx.fillText('CONTINUED FRACTION', x, y);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '11px monospace';
        const cfDisplay = cf.length > 55 ? cf.substring(0, 52) + '...' : cf;
        ctx.fillText(cfDisplay, x, y + 12);
        y += 26;
        
        // Path (compact)
        ctx.fillStyle = '#6ee7b7';
        ctx.font = '10px system-ui';
        ctx.fillText('STERN-BROCOT PATH', x, y);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '10px monospace';
        const pathDisplay = path.length > 65 ? path.substring(0, 62) + '...' : path;
        ctx.fillText(pathDisplay, x, y + 12);
        y += 30;
        
        // Alternatives Table - using pre-extracted data
        if (alternativesData.length > 0) {
            // Header bar for alternatives
            ctx.fillStyle = '#064e3b';
            ctx.fillRect(solverX + 2, y - 2, panelWidth - 4, 22);
            ctx.fillStyle = '#6ee7b7';
            ctx.font = 'bold 11px system-ui';
            ctx.fillText(`ALTERNATIVES WITHIN TOLERANCE (${alternativesData.length})`, x, y + 12);
            y += 28;
            
            // Table header
            ctx.fillStyle = '#6ee7b7';
            ctx.font = 'bold 9px system-ui';
            ctx.fillText('Fraction', x, y);
            ctx.fillText('Decimal', x + 70, y);
            ctx.fillText('Error', x + 150, y);
            ctx.fillText('Sector', x + 220, y);
            ctx.fillText('Type', x + 290, y);
            y += 12;
            
            // Draw separator line
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(solverX + panelWidth - 12, y);
            ctx.stroke();
            y += 8;
            
            // Table rows
            const maxRowsToShow = 25;
            const rowsToShow = Math.min(alternativesData.length, maxRowsToShow);
            
            for (let i = 0; i < rowsToShow; i++) {
                const alt = alternativesData[i];
                
                // Highlight best match row
                if (alt.isBest) {
                    ctx.fillStyle = 'rgba(16,185,129,0.25)';
                    ctx.fillRect(x - 4, y - 10, panelWidth - 16, 16);
                }
                
                ctx.font = '10px monospace';
                ctx.fillStyle = alt.isBest ? '#f0fdf4' : '#e2e8f0';
                ctx.fillText(alt.frac, x, y);
                ctx.fillStyle = '#a7f3d0';
                ctx.fillText(alt.dec, x + 70, y);
                ctx.fillStyle = '#fbbf24';
                ctx.fillText(alt.err, x + 150, y);
                ctx.fillStyle = '#a78bfa';
                ctx.fillText(alt.sec, x + 220, y);
                ctx.fillStyle = alt.typColor;
                ctx.fillText(alt.typ, x + 290, y);
                
                y += 18;
            }
            
            // Show "and X more" if truncated
            if (alternativesData.length > maxRowsToShow) {
                ctx.fillStyle = '#64748b';
                ctx.font = 'italic 9px system-ui';
                ctx.fillText(`... and ${alternativesData.length - maxRowsToShow} more alternatives`, x, y + 5);
            }
        }
    }
    
    // Add metadata text at bottom
    ctx.fillStyle = '#64748b';
    ctx.font = '12px monospace';
    const info = `N=${state.nMax} | Sectors ${state.sectorMin}-${state.sectorMax} | ${new Date().toISOString().slice(0,10)} | @7dview`;
    ctx.fillText(info, padding, tempCanvas.height - 8);
    
    // Show in overlay for preview/download
    currentScreenshotData = tempCanvas.toDataURL('image/png');
    const preview = document.getElementById('screenshotPreview');
    if (preview) {
        preview.src = currentScreenshotData;
        document.getElementById('screenshotOverlay').classList.add('active');
    } else {
        // Direct download if overlay not available
        const link = document.createElement('a');
        link.download = `farey_ring_N${state.nMax}_${Date.now()}.png`;
        link.href = currentScreenshotData;
        link.click();
    }
}

function screenshotFullTab(tabName) {
    const tabElement = document.getElementById('tab-' + tabName);
    if (!tabElement) { alert('Tab not found'); return; }
    
    // For horizon tab, use html2canvas for better capture of all elements
    if (tabName === 'horizon') {
        screenshotHorizonTab();
        return;
    }
    
    const canvases = tabElement.querySelectorAll('canvas');
    const statGrids = tabElement.querySelectorAll('.stat-grid');
    // Also capture individual stat cards and panels
    const statCards = tabElement.querySelectorAll('.stat-card');
    const panels = tabElement.querySelectorAll('.panel');
    
    const padding = 40;
    const titleHeight = 120;
    
    // Calculate stats section height - capture ALL stat grids
    let statsHeight = 0;
    if (statGrids.length > 0) {
        statsHeight = statGrids.length * 100; // 100px per stat grid row
    }
    
    // Calculate canvas section - 2 per row
    const canvasCount = canvases.length;
    const canvasRows = Math.ceil(canvasCount / 2);
    const canvasSectionHeight = canvasRows * 340;
    
    // Check if we have odd number of canvases (will have empty space)
    const hasEmptySpace = canvasCount % 2 === 1;
    
    // Calculate table height - compact rows
    let tableHeight = 0;
    const mainTable = tabElement.querySelector('#mainTable') || tabElement.querySelector('table');
    if (mainTable) {
        const tableRows = mainTable.querySelectorAll('tbody tr');
        const rowCount = Math.min(tableRows.length, 12);
        if (rowCount > 0) {
            tableHeight = rowCount * 16 + 52;
        }
    }
    tableHeight = Math.min(tableHeight, 280);
    
    // Formula panel height (for empty space or bottom)
    const formulaPanelHeight = 220;
    
    // Solver section height (if active)
    const solverHeight = solverCurrentMatch && tabName === 'mainview' ? 90 : 0;
    
    const totalWidth = 1000;
    const totalHeight = titleHeight + statsHeight + canvasSectionHeight + solverHeight + tableHeight + formulaPanelHeight + padding * 2;
    
    const composite = document.createElement('canvas');
    composite.width = totalWidth * 2;
    composite.height = totalHeight * 2;
    const ctx = composite.getContext('2d');
    ctx.scale(2, 2);
    
    // Background
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, totalWidth, totalHeight);
    
    let currentY = padding;
    
    // Tab info for formulas
    const tabInfo = {
        'mainview': {
            title: 'Main Sector Analysis',
            formula: 'C(n, N) = 3N¬≤ / (œÄ¬≤ n(n+1))',
            description: 'Asymptotic count of coprime pairs (r, m) with r/m in sector Sn',
            params: [
                'Coprime density: 6/œÄ¬≤ ‚âà 0.6079',
                'P(m) = Prime denominator count',
                'C(m) = Composite denominator count',
                'P/C = P(m)/C(m) ratio',
                'P(r) = Prime numerator count',
                'PP = Both prime (r,m prime)',
                'PC = Prime num, Composite denom',
                'CP = Composite num, Prime denom',
                'CC = Both composite'
            ]
        },
        'erroranalysis': {
            title: 'Error Analysis',
            formula: 'Œ£|Exact - Predicted| growth rate',
            description: 'Statistical analysis of formula deviation - connection to RH',
            params: [
                'Franel-Landau: RH ‚ü∫ O(N^(1/2+Œµ))',
                'FFT ‚Üí zeta zero frequencies',
                'M√∂bius correlation',
                'Prime vs composite sector behavior'
            ]
        },
        'theory': {
            title: 'Farey Sector Density Theory',
            formula: 'C(n, N) ~ (3/œÄ¬≤) ¬∑ N¬≤ / n(n+1)',
            description: 'Distribution of coprime integer pairs with bounded height',
            params: ['Summatory totient ~ 3N¬≤/œÄ¬≤', 'Global density: 1/Œ∂(2) = 6/œÄ¬≤', 'Visible lattice points']
        },
        'theoryviz': {
            title: 'Theory Visualization',
            formula: 'C(n, N) = 3N¬≤ / (œÄ¬≤ n(n+1))',
            description: 'Visual exploration of the Farey Sector Density Theorem',
            params: ['Summatory totient: Œ£œÜ(b) ~ 3N¬≤/œÄ¬≤', 'Sector partition of (0,1]', 'Convergence analysis']
        },
        'gaps': {
            title: 'Farey Gap Analysis',
            formula: 'gap(a/b, c/d) = 1/(b¬∑d)',
            description: 'For consecutive Farey fractions, gap = 1/(b¬∑d)',
            params: ['Mediant property: |ad - bc| = 1', 'Gap decreases with denominator', 'Uniform distribution']
        },
        'franel': {
            title: 'Franel-Landau Theorem',
            formula: 'Œ£|Œ¥k| = O(N^(1/2+Œµ)) ‚ü∫ RH',
            description: 'Equivalence with Riemann Hypothesis',
            params: ['Œ¥k = Fk - k/|Fn|', 'RH implies bounded Œ£|Œ¥|/‚àöN', 'Computational verification']
        },
        'dedekind': {
            title: 'Dedekind Sums',
            formula: 's(h,k) = Œ£ ((j/k))((hj/k))',
            description: 'Arithmetic functions with reciprocity laws',
            params: ['Reciprocity law', 'Sawtooth function ((x))', 'Modular forms connection']
        },
        'cf': {
            title: 'Continued Fractions',
            formula: 'r/m = [a0; a1, a2, ...]',
            description: 'Stern-Brocot tree encoding',
            params: ['Path encoding', 'Convergents', 'Best rational approximations']
        },
        'euler': {
            title: 'Euler Product for Œ∂(2)',
            formula: 'Œ∂(2) = Œ†p 1/(1-1/p¬≤) = œÄ¬≤/6',
            description: 'Coprime density from prime exclusion',
            params: ['6/œÄ¬≤ = Œ†p(1-1/p¬≤)', 'Prime sieve interpretation', 'Basel problem']
        },
        'stats': {
            title: 'Statistical Analysis',
            formula: 'Expected: 6N¬≤/œÄ¬≤',
            description: 'Statistical distribution of Farey fractions',
            params: ['Chi-squared tests', 'Uniformity measures', 'Prime distribution']
        },
        'primes': {
            title: 'Prime Analysis',
            formula: 'œÄ(N) ~ N/ln(N)',
            description: 'Prime denominator distribution',
            params: ['Prime counting', 'P/C ratios', 'Density analysis']
        },
        'smith': {
            title: 'Smith Chart Transform',
            formula: 'Œì = (Z-1)/(Z+1)',
            description: 'Map Farey fractions to Smith chart',
            params: ['Impedance transformation', 'Reflection coefficient', 'Complex plane mapping']
        }
    };
    
    const info = tabInfo[tabName] || { title: tabName, formula: '', description: '', params: [] };
    
    // Header with gradient
    const gradient = ctx.createLinearGradient(0, 0, totalWidth, titleHeight);
    gradient.addColorStop(0, '#1e1b4b');
    gradient.addColorStop(1, '#312e81');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, totalWidth, titleHeight);
    
    // Title
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 24px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Farey Sector Formula - ' + info.title, padding, currentY + 30);
    
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#a5b4fc';
    ctx.fillText('N = ' + state.nMax + ' | Sectors ' + state.sectorMin + '-' + state.sectorMax + ' | ' + new Date().toLocaleString(), padding, currentY + 55);
    
    // Formula badge
    ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
    const formulaWidth = ctx.measureText(info.formula).width + 30;
    ctx.fillRect(totalWidth - padding - formulaWidth - 10, currentY + 15, formulaWidth + 20, 35);
    ctx.strokeStyle = '#6366f1';
    ctx.strokeRect(totalWidth - padding - formulaWidth - 10, currentY + 15, formulaWidth + 20, 35);
    ctx.fillStyle = '#e0e7ff';
    ctx.font = 'bold 14px "Cambria Math", serif';
    ctx.textAlign = 'right';
    ctx.fillText(info.formula, totalWidth - padding - 5, currentY + 38);
    
    currentY = titleHeight;
    
    // Stats section - capture ALL stat grids
    if (statGrids.length > 0) {
        statGrids.forEach((statGrid, gridIdx) => {
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(padding, currentY + 10, totalWidth - padding * 2, 80);
            ctx.strokeStyle = '#334155';
            ctx.strokeRect(padding, currentY + 10, totalWidth - padding * 2, 80);
            
            const statCardsInGrid = statGrid.querySelectorAll('.stat-card');
            const statWidth = (totalWidth - padding * 2) / Math.min(statCardsInGrid.length, 8);
            
            statCardsInGrid.forEach((card, i) => {
                if (i >= 8) return; // Max 8 stats per row
                const x = padding + i * statWidth + statWidth / 2;
                const label = card.querySelector('.stat-label');
                const value = card.querySelector('.stat-value');
                
                ctx.fillStyle = '#94a3b8';
                ctx.font = '10px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(label ? label.textContent : '', x, currentY + 35);
                
                const valueEl = card.querySelector('.stat-value');
                ctx.fillStyle = valueEl && valueEl.style.color ? valueEl.style.color : '#6366f1';
                ctx.font = 'bold 16px system-ui';
                ctx.fillText(value ? value.textContent : '', x, currentY + 58);
            });
            currentY += 100;
        });
    }
    
    // Solver section (if active on main tab)
    if (solverCurrentMatch && tabName === 'mainview') {
        ctx.fillStyle = '#064e3b';
        ctx.fillRect(padding, currentY + 10, totalWidth - padding * 2, 70);
        ctx.strokeStyle = '#10b981';
        ctx.lineWidth = 2;
        ctx.strokeRect(padding, currentY + 10, totalWidth - padding * 2, 70);
        
        ctx.fillStyle = '#6ee7b7';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('TARGET RATIO SOLVER', padding + 15, currentY + 30);
        
        ctx.fillStyle = '#f0fdf4';
        ctx.font = 'bold 24px monospace';
        ctx.fillText(solverCurrentMatch.r + '/' + solverCurrentMatch.m, padding + 15, currentY + 60);
        
        ctx.font = '12px monospace';
        ctx.fillStyle = '#a7f3d0';
        ctx.fillText('= ' + solverCurrentMatch.value.toFixed(8), padding + 120, currentY + 60);
        
        ctx.fillStyle = '#fbbf24';
        ctx.fillText('Error: ' + solverCurrentMatch.error.toExponential(2), padding + 280, currentY + 60);
        
        ctx.fillStyle = '#a78bfa';
        ctx.fillText('Sector: S' + solverCurrentMatch.sector, padding + 420, currentY + 60);
        
        ctx.fillStyle = '#94a3b8';
        ctx.fillText('CF: [' + solverCurrentMatch.cf.join('; ') + ']', padding + 520, currentY + 60);
        
        ctx.fillStyle = '#f472b6';
        ctx.fillText('Gear: ' + solverCurrentMatch.m + ':' + solverCurrentMatch.r, padding + 750, currentY + 60);
        
        currentY += 90;
    }
    
    // Canvases - 2 per row
    const canvasWidth = (totalWidth - padding * 3) / 2;
    const canvasHeight = 300;
    
    canvases.forEach((canvas, i) => {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = padding + col * (canvasWidth + padding);
        const y = currentY + row * (canvasHeight + 40);
        
        // Get title from parent chart-box
        const chartBox = canvas.closest('.chart-box');
        const title = chartBox ? (chartBox.querySelector('h4') ? chartBox.querySelector('h4').textContent : 'Chart') : 'Chart';
        
        // Background
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(x, y, canvasWidth, canvasHeight);
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, canvasWidth, canvasHeight);
        
        // Title bar
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x, y, canvasWidth, 25);
        ctx.fillStyle = '#e2e8f0';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(title.substring(0, 50), x + 10, y + 17);
        
        // Draw canvas scaled
        const scale = Math.min((canvasWidth - 20) / canvas.width, (canvasHeight - 45) / canvas.height);
        const drawWidth = canvas.width * scale;
        const drawHeight = canvas.height * scale;
        const drawX = x + (canvasWidth - drawWidth) / 2;
        const drawY = y + 30 + (canvasHeight - 40 - drawHeight) / 2;
        
        try {
            ctx.drawImage(canvas, drawX, drawY, drawWidth, drawHeight);
        } catch (e) {
            ctx.fillStyle = '#64748b';
            ctx.fillText('Canvas render error', drawX + 20, drawY + 50);
        }
    });
    
    // Fill empty space if odd number of canvases with formula panel
    if (hasEmptySpace && canvasCount > 0) {
        const col = canvasCount % 2;
        const row = Math.floor(canvasCount / 2);
        const x = padding + col * (canvasWidth + padding);
        const y = currentY + row * (canvasHeight + 40);
        
        ctx.fillStyle = '#1e1b4b';
        ctx.fillRect(x, y, canvasWidth, canvasHeight);
        ctx.strokeStyle = '#6366f1';
        ctx.strokeRect(x, y, canvasWidth, canvasHeight);
        
        ctx.fillStyle = '#c7d2fe';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(info.title, x + canvasWidth/2, y + 30);
        
        ctx.fillStyle = '#f1f5f9';
        ctx.font = 'bold 20px "Cambria Math", serif';
        ctx.fillText(info.formula, x + canvasWidth/2, y + 70);
        
        ctx.fillStyle = '#94a3b8';
        ctx.font = '11px system-ui';
        const descLines = wrapText(ctx, info.description, canvasWidth - 40);
        descLines.forEach((line, i) => {
            ctx.fillText(line, x + canvasWidth/2, y + 100 + i * 16);
        });
        
        ctx.fillStyle = '#a5b4fc';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'left';
        info.params.forEach((param, i) => {
            ctx.fillText('‚Ä¢ ' + param, x + 20, y + 150 + i * 18);
        });
    }
    
    currentY += canvasSectionHeight;
    
    // Tables section
    if (mainTable && tableHeight > 52) {
        const headers = mainTable.querySelectorAll('thead th');
        const rows = mainTable.querySelectorAll('tbody tr');
        
        if (rows.length > 0) {
            // Find the scroll container and determine visible rows
            const tableScroll = mainTable.closest('.table-scroll');
            let startRowIndex = 0;
            
            if (tableScroll) {
                const scrollRect = tableScroll.getBoundingClientRect();
                // Find first row that's visible in the scroll container
                for (let i = 0; i < rows.length; i++) {
                    const rowRect = rows[i].getBoundingClientRect();
                    // Row is visible if its bottom is below the scroll top and its top is above scroll bottom
                    if (rowRect.bottom > scrollRect.top && rowRect.top < scrollRect.bottom) {
                        startRowIndex = i;
                        break;
                    }
                }
            }
            
            const endRowIndex = Math.min(startRowIndex + 12, rows.length);
            const showingFrom = startRowIndex + 1;
            const showingTo = endRowIndex;
            
            ctx.fillStyle = '#cbd5e1';
            ctx.font = 'bold 12px system-ui';
            ctx.textAlign = 'left';
            ctx.fillText('Sector Data' + (startRowIndex > 0 ? ' (rows ' + showingFrom + '-' + showingTo + ' of ' + rows.length + ')' : ''), padding, currentY + 20);
            currentY += 30;
            
            // Full width table
            const tableWidth = totalWidth - padding * 2;
            const numCols = headers.length;
            const colWidth = tableWidth / numCols;
            const tableStartX = padding;
            
            // Header
            ctx.fillStyle = '#334155';
            ctx.fillRect(tableStartX, currentY, tableWidth, 22);
            
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 9px system-ui';
            headers.forEach((h, i) => {
                ctx.fillText(h.textContent.substring(0, 12), tableStartX + 4 + i * colWidth, currentY + 15);
            });
            currentY += 22;
            
            // Rows
            ctx.font = '9px system-ui';
            const maxRows = 12;
            for (let r = startRowIndex; r < Math.min(startRowIndex + maxRows, rows.length); r++) {
                const row = rows[r];
                const cells = row.querySelectorAll('td');
                const displayIdx = r - startRowIndex;
                
                if (displayIdx % 2 === 0) {
                    ctx.fillStyle = '#1e293b';
                    ctx.fillRect(tableStartX, currentY, tableWidth, 16);
                }
                
                cells.forEach((cell, i) => {
                    ctx.fillStyle = cell.style.color || '#e2e8f0';
                    ctx.fillText(cell.textContent.substring(0, 14), tableStartX + 4 + i * colWidth, currentY + 12);
                });
                currentY += 16;
            }
            
            const remainingRows = rows.length - endRowIndex;
            const rowsAbove = startRowIndex;
            if (rowsAbove > 0 || remainingRows > 0) {
                ctx.fillStyle = '#64748b';
                let rangeText = '';
                if (rowsAbove > 0 && remainingRows > 0) {
                    rangeText = '(' + rowsAbove + ' rows above, ' + remainingRows + ' below)';
                } else if (rowsAbove > 0) {
                    rangeText = '(' + rowsAbove + ' rows above)';
                } else {
                    rangeText = '... and ' + remainingRows + ' more rows below';
                }
                ctx.fillText(rangeText, tableStartX + 4, currentY + 12);
                currentY += 16;
            }
        }
    }
    
    // Bottom formula panel
    currentY = totalHeight - formulaPanelHeight - padding;
    
    ctx.fillStyle = '#1e293b';
    ctx.fillRect(padding, currentY, totalWidth - padding * 2, formulaPanelHeight);
    ctx.strokeStyle = '#475569';
    ctx.strokeRect(padding, currentY, totalWidth - padding * 2, formulaPanelHeight);
    
    // Left side - Main formula
    ctx.fillStyle = '#c7d2fe';
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Core Formula', padding + 20, currentY + 25);
    
    ctx.fillStyle = 'rgba(99, 102, 241, 0.15)';
    ctx.fillRect(padding + 20, currentY + 35, (totalWidth - padding * 2) / 2 - 40, 45);
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 18px "Cambria Math", serif';
    ctx.textAlign = 'center';
    ctx.fillText(info.formula, padding + 20 + ((totalWidth - padding * 2) / 2 - 40) / 2, currentY + 65);
    
    // Computed example
    const bottomViewSector = parseInt(document.getElementById('viewSector')?.value || 1);
    const bottomN = state.nMax;
    const bottomPi2 = Math.PI * Math.PI;
    const bottomResult = (3 * bottomN * bottomN) / (bottomPi2 * bottomViewSector * (bottomViewSector + 1));
    ctx.fillStyle = '#22c55e';
    ctx.font = '11px system-ui';
    ctx.fillText('C(' + bottomViewSector + ', ' + bottomN.toLocaleString() + ') = ' + bottomResult.toFixed(4), padding + 20 + ((totalWidth - padding * 2) / 2 - 40) / 2, currentY + 90);
    
    // Description (asymptotic count) - centered below example
    const formulaCenterX = padding + 20 + ((totalWidth - padding * 2) / 2 - 40) / 2;
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(info.description, formulaCenterX, currentY + 110);
    
    // Identities below description - centered with formula
    ctx.fillStyle = '#fbbf24';
    ctx.font = 'bold 10px system-ui';
    ctx.fillText('Identities:', formulaCenterX, currentY + 130);
    ctx.fillStyle = '#e2e8f0';
    ctx.font = '10px monospace';
    ctx.fillText('PP + PC + CP + CC = Exact', formulaCenterX, currentY + 146);
    ctx.fillText('P(m) + C(m) = Exact', formulaCenterX, currentY + 160);
    ctx.fillText('P(m) = PP + CP,  C(m) = PC + CC,  P(r) = PP + PC', formulaCenterX, currentY + 174);
    
    // Right side - Parameters and constants side by side
    const rightX = padding + (totalWidth - padding * 2) / 2 + 20;
    const constBoxX = rightX + 220; // Constants box beside definitions
    
    // Definitions column
    ctx.textAlign = 'left';
    ctx.fillStyle = '#c7d2fe';
    ctx.font = 'bold 13px system-ui';
    ctx.fillText('Definitions', rightX, currentY + 25);
    
    ctx.fillStyle = '#a5b4fc';
    ctx.font = '10px system-ui';
    info.params.forEach((param, i) => {
        ctx.fillText('‚Ä¢ ' + param, rightX + 5, currentY + 45 + i * 14);
    });
    
    // Constants box - beside definitions
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(constBoxX, currentY + 10, 210, 120);
    ctx.strokeStyle = '#334155';
    ctx.strokeRect(constBoxX, currentY + 10, 210, 120);
    ctx.fillStyle = '#c7d2fe';
    ctx.font = 'bold 13px system-ui';
    ctx.fillText('Universal Constants', constBoxX + 10, currentY + 30);
    ctx.fillStyle = '#6366f1';
    ctx.font = '11px monospace';
    ctx.fillText('6/œÄ¬≤ = ' + (6/Math.PI/Math.PI).toFixed(8), constBoxX + 10, currentY + 50);
    ctx.fillText('œÄ¬≤/6 = ' + (Math.PI*Math.PI/6).toFixed(8), constBoxX + 10, currentY + 66);
    ctx.fillText('‚àö3/œÄ = ' + (Math.sqrt(3)/Math.PI).toFixed(8), constBoxX + 10, currentY + 82);
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.fillText('Current Bounds:', constBoxX + 10, currentY + 100);
    ctx.fillStyle = '#22c55e';
    ctx.font = '10px monospace';
    ctx.fillText('N = ' + state.nMax.toLocaleString() + ', S = [' + state.sectorMin + ',' + state.sectorMax + ']', constBoxX + 10, currentY + 115);
    
    // Footer
    ctx.fillStyle = '#475569';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io', totalWidth / 2, totalHeight - 15);
    
    currentScreenshotData = composite.toDataURL('image/png');
    document.getElementById('screenshotPreview').src = currentScreenshotData;
    document.getElementById('screenshotOverlay').classList.add('active');
}

function wrapText(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';
    
    words.forEach(word => {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
        } else {
            currentLine = testLine;
        }
    });
    if (currentLine) lines.push(currentLine);
    return lines;
}

// Special screenshot function for Horizon tab using html2canvas
async function screenshotHorizonTab() {
    const tabElement = document.getElementById('tab-horizon');
    if (!tabElement) { alert('Tab not found'); return; }
    
    // Show loading
    const loadingDiv = document.createElement('div');
    loadingDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#1e1b4b;padding:30px 50px;border-radius:10px;z-index:10000;color:#fff;font-size:16px;border:2px solid #8b5cf6;';
    loadingDiv.textContent = 'Capturing screenshot...';
    document.body.appendChild(loadingDiv);
    
    try {
        // Use html2canvas to capture the entire tab
        const canvas = await html2canvas(tabElement, {
            backgroundColor: '#0a0f1a',
            scale: 2,
            logging: false,
            useCORS: true,
            allowTaint: true
        });
        
        // Add header and footer
        const finalCanvas = document.createElement('canvas');
        const headerHeight = 80;
        const footerHeight = 40;
        finalCanvas.width = canvas.width;
        finalCanvas.height = canvas.height + headerHeight + footerHeight;
        const ctx = finalCanvas.getContext('2d');
        
        // Background
        ctx.fillStyle = '#0a0f1a';
        ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
        
        // Header gradient
        const gradient = ctx.createLinearGradient(0, 0, finalCanvas.width, headerHeight);
        gradient.addColorStop(0, '#1e1b4b');
        gradient.addColorStop(1, '#312e81');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, finalCanvas.width, headerHeight);
        
        // Header text
        ctx.fillStyle = '#f8fafc';
        ctx.font = 'bold 32px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Farey Horizon & Mediant Generation', 40, 45);
        
        const n = document.getElementById('horizonSectorN')?.value || 5;
        const maxN = document.getElementById('horizonMaxN')?.value || 50;
        ctx.font = '18px system-ui';
        ctx.fillStyle = '#a5b4fc';
        ctx.fillText('Sector ' + n + ' | N = ' + maxN + ' | Fractions: ' + (horizonData.fractions?.length || 0) + ' | ' + new Date().toLocaleString(), 40, 70);
        
        // Formula badge
        ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
        const formula = 'med(a/b, c/d) = (a+c)/(b+d)';
        ctx.font = 'bold 20px serif';
        const formulaWidth = ctx.measureText(formula).width + 40;
        ctx.fillRect(finalCanvas.width - formulaWidth - 40, 20, formulaWidth, 40);
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.strokeRect(finalCanvas.width - formulaWidth - 40, 20, formulaWidth, 40);
        ctx.fillStyle = '#e0e7ff';
        ctx.textAlign = 'right';
        ctx.fillText(formula, finalCanvas.width - 60, 48);
        
        // Main content
        ctx.drawImage(canvas, 0, headerHeight);
        
        // Footer
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(0, finalCanvas.height - footerHeight, finalCanvas.width, footerHeight);
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io', finalCanvas.width / 2, finalCanvas.height - 15);
        
        currentScreenshotData = finalCanvas.toDataURL('image/png');
        document.getElementById('screenshotPreview').src = currentScreenshotData;
        document.getElementById('screenshotOverlay').classList.add('active');
        
    } catch (e) {
        alert('Screenshot failed: ' + e.message);
    } finally {
        document.body.removeChild(loadingDiv);
    }
}

// =============================================
// MEISSEL-LEHMER OPTIMIZED NUMBER THEORY MODULE
// =============================================

const NumberTheory = (function() {
    // Cache structures
    let sieveLimit = 0;
    let primeFlags = null;      // Uint8Array: 1 = prime
    let spf = null;             // Int32Array: smallest prime factor
    let primeList = [];         // Array of primes
    let phiCache = new Map();   // Totient cache
    let piCache = new Map();    // Prime counting cache
    
    // Initialize sieve up to n (Sieve of Eratosthenes with SPF)
    function initSieve(n) {
        if (n <= sieveLimit) return;
        
        const limit = Math.max(n, 10000);
        sieveLimit = limit;
        primeFlags = new Uint8Array(limit + 1);
        spf = new Int32Array(limit + 1);
        primeList = [];
        
        // Initialize
        primeFlags.fill(1);
        primeFlags[0] = primeFlags[1] = 0;
        
        for (let i = 2; i <= limit; i++) {
            if (primeFlags[i]) {
                primeList.push(i);
                spf[i] = i;
            }
            for (let j = 0; j < primeList.length && primeList[j] <= spf[i] && i * primeList[j] <= limit; j++) {
                const composite = i * primeList[j];
                primeFlags[composite] = 0;
                spf[composite] = primeList[j];
            }
        }
        
        // Clear caches on re-sieve
        phiCache.clear();
        piCache.clear();
    }
    
    // O(1) primality test (uses sieve)
    function isPrimeFast(n) {
        if (n <= 1) return false;
        if (n <= sieveLimit) return primeFlags[n] === 1;
        // Fallback for values beyond sieve (Miller-Rabin for large n)
        return isPrimeMillerRabin(n);
    }
    
    // Miller-Rabin primality test for large numbers
    function isPrimeMillerRabin(n) {
        if (n < 2) return false;
        if (n === 2 || n === 3) return true;
        if (n % 2 === 0) return false;
        
        // Write n-1 as 2^r * d
        let d = n - 1, r = 0;
        while ((d & 1) === 0) { d >>= 1; r++; }
        
        // Witnesses sufficient for n < 3,317,044,064,679,887,385,961,981
        const witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
        
        for (const a of witnesses) {
            if (a >= n) continue;
            let x = modPow(BigInt(a), BigInt(d), BigInt(n));
            if (x === 1n || x === BigInt(n - 1)) continue;
            
            let composite = true;
            for (let i = 0; i < r - 1; i++) {
                x = (x * x) % BigInt(n);
                if (x === BigInt(n - 1)) { composite = false; break; }
            }
            if (composite) return false;
        }
        return true;
    }
    
    function modPow(base, exp, mod) {
        let result = 1n;
        base = base % mod;
        while (exp > 0n) {
            if (exp & 1n) result = (result * base) % mod;
            exp >>= 1n;
            base = (base * base) % mod;
        }
        return result;
    }
    
    // Fast totient using SPF factorization - O(log n)
    function phiFast(n) {
        if (n <= 1) return n === 1 ? 1 : 0;
        if (phiCache.has(n)) return phiCache.get(n);
        
        if (n <= sieveLimit && spf) {
            // Use SPF for fast factorization
            let result = n, temp = n;
            while (temp > 1) {
                const p = spf[temp];
                result -= result / p;
                while (temp % p === 0) temp /= p;
            }
            phiCache.set(n, result);
            return result;
        }
        
        // Fallback: trial division
        let result = n, temp = n;
        for (let p = 2; p * p <= temp; p++) {
            if (temp % p === 0) {
                result -= result / p;
                while (temp % p === 0) temp /= p;
            }
        }
        if (temp > 1) result -= result / temp;
        phiCache.set(n, result);
        return result;
    }
    
    // Meissel-Lehmer prime counting: pi(x)
    // Returns count of primes <= x in sublinear time O(x^(2/3))
    function piMeisselLehmer(x) {
        if (x < 2) return 0;
        if (x <= sieveLimit) {
            // Use sieve for small values
            let count = 0;
            for (let i = 2; i <= x; i++) if (primeFlags[i]) count++;
            return count;
        }
        
        if (piCache.has(x)) return piCache.get(x);
        
        // Lucy_Hedgehog algorithm for pi(x) - O(x^(2/3))
        const result = lucyPi(x);
        piCache.set(x, result);
        return result;
    }
    
    // Lucy_Hedgehog algorithm for pi(x)
    function lucyPi(n) {
        if (n < 2) return 0;
        
        const sqrtn = Math.floor(Math.sqrt(n));
        const small = new Map();  // V[i] for i <= sqrt(n)
        const large = new Map();  // V[n/i] for i <= sqrt(n)
        
        // Initialize: V[i] = i - 1 (count of candidates 2..i)
        for (let i = 1; i <= sqrtn; i++) {
            small.set(i, i - 1);
            large.set(i, Math.floor(n / i) - 1);
        }
        
        // Sieve
        for (let p = 2; p <= sqrtn; p++) {
            if (small.get(p) <= small.get(p - 1)) continue; // p is not prime
            
            const pcnt = small.get(p - 1);
            const p2 = p * p;
            
            // Update large values
            for (let i = 1; i <= Math.min(sqrtn, Math.floor(n / p2)); i++) {
                const d = i * p;
                const toSubtract = d <= sqrtn ? large.get(d) : small.get(Math.floor(n / d));
                large.set(i, large.get(i) - (toSubtract - pcnt));
            }
            
            // Update small values
            for (let i = sqrtn; i >= p2; i--) {
                small.set(i, small.get(i) - (small.get(Math.floor(i / p)) - pcnt));
            }
        }
        
        return large.get(1);
    }
    
    // Summatory totient: sum of phi(k) for k = 1 to n
    // Uses Dirichlet hyperbola method - O(n^(2/3))
    function sumPhi(n) {
        if (n <= 0) return 0;
        if (n === 1) return 1;
        
        const sqrtn = Math.floor(Math.sqrt(n));
        const small = new Int32Array(sqrtn + 1);
        const large = new Map();
        
        // Compute phi(k) for k <= sqrt(n) using sieve
        initSieve(sqrtn);
        for (let i = 1; i <= sqrtn; i++) {
            small[i] = small[i - 1] + phiFast(i);
        }
        
        // Recursive with memoization
        function S(m) {
            if (m <= sqrtn) return small[m];
            if (large.has(m)) return large.get(m);
            
            // S(n) = n(n+1)/2 - sum_{d=2}^{n} S(floor(n/d))
            let result = m * (m + 1) / 2;
            
            // Use hyperbola method
            let prev = m;
            for (let d = 2; d <= m; d++) {
                const q = Math.floor(m / d);
                if (q === prev) continue;
                result -= (d - Math.floor(m / prev) - (prev === q ? 0 : 1)) * S(prev);
                prev = q;
            }
            if (prev >= 1) result -= (Math.floor(m / prev)) * S(prev);
            
            // Simpler version for correctness
            result = m * (m + 1) / 2;
            let i = 2;
            while (i <= m) {
                const q = Math.floor(m / i);
                const j = Math.floor(m / q);
                result -= (j - i + 1) * S(q);
                i = j + 1;
            }
            
            large.set(m, result);
            return result;
        }
        
        return S(n);
    }
    
    // Batch compute primality for range [lo, hi]
    function batchPrimality(lo, hi) {
        initSieve(hi);
        const result = new Uint8Array(hi - lo + 1);
        for (let i = lo; i <= hi; i++) {
            result[i - lo] = primeFlags[i];
        }
        return result;
    }
    
    // Get primes in range [lo, hi]
    function primesInRange(lo, hi) {
        initSieve(hi);
        const result = [];
        for (let i = Math.max(2, lo); i <= hi; i++) {
            if (primeFlags[i]) result.push(i);
        }
        return result;
    }
    
    // Get the k-th prime (1-indexed)
    function nthPrime(k) {
        if (k <= 0) return 0;
        // Upper bound: p_k < k(ln k + ln ln k) for k >= 6
        const upperBound = k < 6 ? 15 : Math.ceil(k * (Math.log(k) + Math.log(Math.log(k)) + 2));
        initSieve(upperBound);
        return primeList[k - 1] || 0;
    }
    
    // Mobius function using SPF
    function mobiusFast(n) {
        if (n === 1) return 1;
        initSieve(n);
        
        let count = 0, temp = n;
        while (temp > 1) {
            const p = spf[temp];
            if (temp / p % p === 0) return 0; // p^2 divides n
            count++;
            temp /= p;
            while (temp % p === 0) temp /= p;
        }
        return count % 2 === 0 ? 1 : -1;
    }
    
    // Prime factorization using SPF
    function factorize(n) {
        if (n <= 1) return [];
        initSieve(n);
        
        const factors = [];
        while (n > 1) {
            const p = spf[n];
            let exp = 0;
            while (n % p === 0) { n /= p; exp++; }
            factors.push({ p, exp });
        }
        return factors;
    }
    
    // Divisor count using factorization
    function divisorCount(n) {
        const factors = factorize(n);
        let count = 1;
        for (const { exp } of factors) count *= (exp + 1);
        return count;
    }
    
    // Divisor sum using factorization
    function divisorSum(n) {
        const factors = factorize(n);
        let sum = 1;
        for (const { p, exp } of factors) {
            sum *= (Math.pow(p, exp + 1) - 1) / (p - 1);
        }
        return Math.round(sum);
    }
    
    // Get statistics
    function getStats() {
        return {
            sieveLimit,
            primeCount: primeList.length,
            phiCacheSize: phiCache.size,
            piCacheSize: piCache.size
        };
    }
    
    // Clear all caches
    function clearCaches() {
        phiCache.clear();
        piCache.clear();
    }
    
    // Public API
    return {
        initSieve,
        isPrime: isPrimeFast,
        phi: phiFast,
        pi: piMeisselLehmer,
        sumPhi,
        mobius: mobiusFast,
        factorize,
        divisorCount,
        divisorSum,
        nthPrime,
        primesInRange,
        batchPrimality,
        getStats,
        clearCaches,
        getPrimeList: () => primeList.slice()
    };
})();

// Legacy wrappers for compatibility
function gcd(a, b) { while(b) { [a,b] = [b, a%b]; } return a; }
function isPrime(n) { return NumberTheory.isPrime(n); }
function mobius(n) { return NumberTheory.mobius(n); }
function getSector(r,m) { const f=r/m; if(f<=0||f>1) return null; return Math.floor(1/f); }
function formula(n,N) { return (3*N*N)/(Math.PI*Math.PI*n*(n+1)); }
function fmt(x) { if(x>=1e9) return (x/1e9).toFixed(1)+'B'; if(x>=1e6) return (x/1e6).toFixed(1)+'M'; if(x>=1e3) return (x/1e3).toFixed(1)+'K'; return x.toFixed(x<10?2:0); }

// Continued fraction
function toCF(r, m) {
    const cf = [];
    while(m !== 0) { const q = Math.floor(r/m); cf.push(q); [r,m] = [m, r - q*m]; }
    return cf;
}
function cfPath(cf) {
    let path = '';
    for(let i=0; i<cf.length; i++) { path += (i%2===0?'R':'L').repeat(cf[i]); }
    return path;
}

// Dedekind sum
function sawtoothSum(h, k) {
    let s = 0;
    for(let j=1; j<k; j++) {
        const jk = j/k, hjk = (h*j/k) % 1;
        const s1 = jk - Math.floor(jk) - 0.5;
        const s2 = hjk - Math.floor(hjk) - 0.5;
        s += s1 * s2;
    }
    return s;
}

function setMode(mode) {
    state.mode = mode;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('mode-'+mode).classList.add('active');
    const descriptions = {
        exact: 'Full enumeration (N‚â§3000)',
        hybrid: 'Smart hybrid mode',
        formula: 'Instant formula only (any N)'
    };
    document.getElementById('modeDescription').textContent = descriptions[mode];
}

// =============================================
// SECTOR BOUND FUNCTIONS
// =============================================

function parseMathExpression(expr) {
    // Parse mathematical expressions like sqrt(3)/pi, sqrt(6)/pi, etc.
    try {
        let parsed = expr.toLowerCase()
            .replace(/sqrt\s*\(\s*(\d+)\s*\)/g, 'Math.sqrt($1)')
            .replace(/pi/g, 'Math.PI')
            .replace(/e(?![a-z])/g, 'Math.E')
            .replace(/ln\s*\(\s*([^)]+)\s*\)/g, 'Math.log($1)')
            .replace(/log\s*\(\s*([^)]+)\s*\)/g, 'Math.log10($1)');
        return eval(parsed);
    } catch (e) {
        console.warn('Failed to parse:', expr, e);
        return null;
    }
}

function updateSectorBound() {
    const useBound = document.getElementById('useSectorBound').checked;
    if (useBound) {
        const N = +document.getElementById('nMax').value || 500;
        const maxSector = Math.floor(N * state.sectorBoundConstant);
        document.getElementById('sectorMax').value = maxSector;
        document.getElementById('sectorBoundResult').textContent = `‚Üí Max sector: ${maxSector}`;
    }
}

function applySectorBoundPreset() {
    const preset = document.getElementById('sectorBoundPreset').value;
    let constant, displayExpr;
    
    switch(preset) {
        case 'sqrt3pi':
            constant = Math.sqrt(3) / Math.PI;
            displayExpr = 'sqrt(3)/pi';
            break;
        case 'sqrt6pi':
            constant = Math.sqrt(6) / Math.PI;
            displayExpr = 'sqrt(6)/pi';
            break;
        case '1pi':
            constant = 1 / Math.PI;
            displayExpr = '1/pi';
            break;
        case '2pi':
            constant = 2 / Math.PI;
            displayExpr = '2/pi';
            break;
        case 'sqrt2pi':
            constant = Math.sqrt(2) / Math.PI;
            displayExpr = 'sqrt(2)/pi';
            break;
        case '1':
            constant = 1;
            displayExpr = '1';
            break;
        case 'custom':
            // Don't change anything, let user enter custom
            return;
        default:
            constant = Math.sqrt(3) / Math.PI;
            displayExpr = 'sqrt(3)/pi';
    }
    
    state.sectorBoundConstant = constant;
    document.getElementById('customSectorBound').value = displayExpr;
    document.getElementById('sectorBoundValue').textContent = `= ${constant.toFixed(4)}`;
    updateSectorBound();
}

function applyCustomSectorBound() {
    const expr = document.getElementById('customSectorBound').value;
    const constant = parseMathExpression(expr);
    
    if (constant !== null && isFinite(constant) && constant > 0) {
        state.sectorBoundConstant = constant;
        document.getElementById('sectorBoundValue').textContent = `= ${constant.toFixed(4)}`;
        document.getElementById('sectorBoundPreset').value = 'custom';
        updateSectorBound();
    } else {
        document.getElementById('sectorBoundValue').textContent = '= invalid';
    }
}

// Update sector bound when N changes
document.addEventListener('DOMContentLoaded', function() {
    const nMaxInput = document.getElementById('nMax');
    if (nMaxInput) {
        nMaxInput.addEventListener('change', function() {
            if (document.getElementById('useSectorBound')?.checked) {
                updateSectorBound();
            }
        });
        nMaxInput.addEventListener('input', function() {
            if (document.getElementById('useSectorBound')?.checked) {
                updateSectorBound();
            }
        });
    }
    
    // Initialize sector bound display
    setTimeout(() => {
        applySectorBoundPreset();
    }, 100);
});

async function computeAll() {
    if(state.computing) return;
    state.computing = true;
    
    try {
        state.nMin = +document.getElementById('nMin').value;
        state.nMax = +document.getElementById('nMax').value;
        state.sectorMin = +document.getElementById('sectorMin').value;
        state.sectorMax = +document.getElementById('sectorMax').value;
        
        // Validate inputs
        if(state.nMax < 2) state.nMax = 2;
        if(state.nMin < 1) state.nMin = 1;
        if(state.nMin > state.nMax) state.nMin = 1;
        
        // Get bounded P/C settings
        state.useBoundedPC = document.getElementById('computeBoundedPC')?.checked ?? false;
        state.boundedN = +(document.getElementById('boundedWindowN')?.value || 2000);
        
        document.getElementById('progressBar').style.display = 'block';
        document.getElementById('statusArea').innerHTML = '<span class="info-badge">Computing...</span>';
        
        state.sectors = []; state.residuesBySector = {}; state.allResidues = []; state.gaps = []; state.farey = [];
        state.boundedResiduesBySector = {};
        
        const N = state.nMax;
    
    // Formula mode: fast path - no enumeration needed
    if(state.mode === 'formula') {
        // First compute bounded window for P/C ratios if enabled
        if (state.useBoundedPC) {
            document.getElementById('statusArea').innerHTML = '<span class="info-badge">Computing bounded P/C window...</span>';
            await computeBoundedWindow();
        }
        computeFormulaOnly();
        updateFormulaOnlyDisplays();
        document.getElementById('progressBar').style.display = 'none';
        document.getElementById('statusArea').innerHTML = '<span class="info-badge success">Done (Formula' + (state.useBoundedPC ? ' + Bounded P/C' : '') + ')</span>';
        state.computing = false;
        return;
    }
    
    // Exact/Hybrid modes with reasonable N
    if(N <= 3000) {
        await computeExact(N);
    } else {
        // Large N in non-formula mode: compute bounded window first for P/C
        if (state.useBoundedPC) {
            document.getElementById('statusArea').innerHTML = '<span class="info-badge">Computing bounded P/C window...</span>';
            await computeBoundedWindow();
        }
        // Then compute formula
        computeFormulaOnly();
        document.getElementById('statusArea').innerHTML = '<span class="info-badge" style="background:#f59e0b;">N > 3000 - using formula' + (state.useBoundedPC ? ' + bounded P/C' : '') + '</span>';
    }
    
    computeGaps();
    updateAllDisplays();
    
    document.getElementById('progressBar').style.display = 'none';
    if(N <= 3000) {
        document.getElementById('statusArea').innerHTML = '<span class="info-badge success">Done</span>';
    }
    } catch(err) {
        console.error('Computation error:', err);
        document.getElementById('statusArea').innerHTML = '<span class="info-badge" style="background:#ef4444;">Error: ' + err.message + '</span>';
    } finally {
        state.computing = false;
        document.getElementById('progressBar').style.display = 'none';
    }
}

async function computeExact(N) {
    let ops = 0;
    const startM = Math.max(2, state.nMin);  // Respect nMin
    
    // MEISSEL-LEHMER OPTIMIZATION: Pre-initialize sieve for O(1) primality
    NumberTheory.initSieve(N);
    
    for(let m=startM; m<=N; m++) {
        const isPrimeM = NumberTheory.isPrime(m);  // O(1) lookup
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const s = getSector(r,m);
                const isPrimeR = NumberTheory.isPrime(r);  // O(1) lookup
                const res = {
                    r, m, sector:s, 
                    isPrime: isPrimeM,      // Denominator is prime
                    isPrimeNum: isPrimeR,   // Numerator is prime
                    category: isPrimeR && isPrimeM ? 'PP' :
                              isPrimeR && !isPrimeM ? 'PC' :
                              !isPrimeR && isPrimeM ? 'CP' : 'CC',
                    value: r/m
                };
                state.allResidues.push(res);
                if(s && s>=state.sectorMin && s<=state.sectorMax) {
                    if(!state.residuesBySector[s]) state.residuesBySector[s] = [];
                    state.residuesBySector[s].push(res);
                }
            }
        }
        ops += m;
        if(m%50===0) { document.getElementById('progressFill').style.width = ((m-startM)/(N-startM)*100)+'%'; await new Promise(r=>setTimeout(r,0)); }
        if(!state.computing) return;
    }
    state.allResidues.sort((a,b) => a.value - b.value);
    state.farey = state.allResidues.map(r => ({r:r.r, m:r.m, value:r.value}));
    
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        const res = state.residuesBySector[n] || [];
        const exact = res.length, pred = formula(n,N);
        const primeCount = res.filter(x=>x.isPrime).length;  // Prime denominator
        const primeNumCount = res.filter(x=>x.isPrimeNum).length;  // Prime numerator
        // Category counts
        const ppCount = res.filter(x=>x.category==='PP').length;  // Both prime
        const pcCount = res.filter(x=>x.category==='PC').length;  // Prime num, Composite denom
        const cpCount = res.filter(x=>x.category==='CP').length;  // Composite num, Prime denom
        const ccCount = res.filter(x=>x.category==='CC').length;  // Both composite
        
        state.sectors.push({
            n, exact, predicted:pred, error:exact-pred, 
            relError:exact>0?((exact-pred)/exact)*100:0, 
            width:1/(n*(n+1)), 
            primeCount,      // Prime denominators
            primeNumCount,   // Prime numerators
            ppCount, pcCount, cpCount, ccCount
        });
    }
}

function computeFormulaOnly() {
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        // Get bounded P/C data if available
        const boundedRes = state.boundedResiduesBySector[n] || [];
        const boundedPrimeCount = boundedRes.filter(x => x.isPrime).length;  // Prime denom
        const boundedPrimeNumCount = boundedRes.filter(x => x.isPrimeNum).length;  // Prime num
        const boundedCompositeCount = boundedRes.length - boundedPrimeCount;
        const boundedPCRatio = boundedCompositeCount > 0 ? boundedPrimeCount / boundedCompositeCount : null;
        
        // Category counts from bounded data
        const boundedPP = boundedRes.filter(x => x.category === 'PP').length;
        const boundedPC = boundedRes.filter(x => x.category === 'PC').length;
        const boundedCP = boundedRes.filter(x => x.category === 'CP').length;
        const boundedCC = boundedRes.filter(x => x.category === 'CC').length;
        
        state.sectors.push({
            n, 
            exact: null, 
            predicted: formula(n, state.nMax), 
            error: null, 
            relError: null, 
            width: 1/(n*(n+1)), 
            primeCount: null,
            primeNumCount: null,
            ppCount: null, pcCount: null, cpCount: null, ccCount: null,
            // Bounded window data
            boundedPrimeCount: boundedRes.length > 0 ? boundedPrimeCount : null,
            boundedPrimeNumCount: boundedRes.length > 0 ? boundedPrimeNumCount : null,
            boundedCompositeCount: boundedRes.length > 0 ? boundedCompositeCount : null,
            boundedPCRatio: boundedPCRatio,
            boundedTotal: boundedRes.length > 0 ? boundedRes.length : null,
            boundedExact: boundedRes.length > 0 ? boundedRes.length : null,
            boundedPredicted: formula(n, state.boundedN),
            boundedError: boundedRes.length > 0 ? boundedRes.length - formula(n, state.boundedN) : null,
            boundedRelError: boundedRes.length > 0 ? ((boundedRes.length - formula(n, state.boundedN)) / boundedRes.length) * 100 : null,
            // Bounded category counts
            boundedPP: boundedRes.length > 0 ? boundedPP : null,
            boundedPC: boundedRes.length > 0 ? boundedPC : null,
            boundedCP: boundedRes.length > 0 ? boundedCP : null,
            boundedCC: boundedRes.length > 0 ? boundedCC : null
        });
    }
}

// Compute bounded window for P/C ratios (async to not block UI)
async function computeBoundedWindow() {
    const boundedN = state.boundedN;
    state.boundedResiduesBySector = {};
    
    // MEISSEL-LEHMER OPTIMIZATION: Pre-initialize sieve for O(1) primality
    NumberTheory.initSieve(boundedN);
    
    let ops = 0;
    for(let m = 2; m <= boundedN; m++) {
        const isPrimeM = NumberTheory.isPrime(m);  // O(1) lookup - moved outside inner loop
        for(let r = 1; r < m; r++) {
            if(gcd(r, m) === 1) {
                const s = getSector(r, m);
                if(s !== null && s >= state.sectorMin && s <= state.sectorMax) {
                    if(!state.boundedResiduesBySector[s]) state.boundedResiduesBySector[s] = [];
                    const isPrimeR = NumberTheory.isPrime(r);  // O(1) lookup
                    state.boundedResiduesBySector[s].push({
                        r, m, 
                        sector: s, 
                        isPrime: isPrimeM,      // Denominator is prime
                        isPrimeNum: isPrimeR,   // Numerator is prime
                        // Classification
                        category: isPrimeR && isPrimeM ? 'PP' :    // Both prime
                                  isPrimeR && !isPrimeM ? 'PC' :   // Prime num, Composite denom
                                  !isPrimeR && isPrimeM ? 'CP' :   // Composite num, Prime denom
                                  'CC',                             // Both composite
                        value: r/m
                    });
                }
            }
        }
        ops += m;
        if(m % 100 === 0) {
            document.getElementById('progressFill').style.width = (m / boundedN * 100) + '%';
            await new Promise(r => setTimeout(r, 0));
        }
        if(!state.computing) return;
    }
}

// Convergence analysis - show how error and P/C converge as N increases
function showConvergenceAnalysis() {
    // Compute data at multiple N values
    const nValues = [100, 200, 500, 1000, 1500, 2000, 5000, 10000, 50000, 100000, 1000000, 10000000];
    const sectorN = +(document.getElementById('viewSector')?.value || 2);
    
    let html = '<div style="max-height:500px;overflow-y:auto;">';
    html += '<h4 style="color:#a5b4fc;margin-bottom:12px;">Convergence Analysis for Sector ' + sectorN + '</h4>';
    html += '<p style="color:#94a3b8;font-size:12px;margin-bottom:12px;">Shows how error and P/C ratio converge as N increases</p>';
    
    html += '<table style="width:100%;font-size:11px;border-collapse:collapse;">';
    html += '<thead><tr style="background:#1e293b;">';
    html += '<th style="padding:8px;text-align:left;border-bottom:1px solid #475569;">N</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Formula Pred</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Exact Count</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Rel Error %</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Primes</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Composites</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">P/C Ratio</th>';
    html += '</tr></thead><tbody>';
    
    // Compute actual data for manageable N values (up to 5000)
    const maxComputeN = 5000;
    
    // Keep track of last computed P/C for extrapolation
    let lastPCRatio = null;
    let lastN = null;
    
    nValues.forEach(N => {
        const pred = formula(sectorN, N);
        
        let exact = null, primes = null, composites = null, pcRatio = null, relError = null;
        
        if (N <= maxComputeN) {
            // Compute exact count for this N
            exact = 0;
            primes = 0;
            composites = 0;
            
            for (let m = 2; m <= N; m++) {
                for (let r = 1; r < m; r++) {
                    if (gcd(r, m) === 1) {
                        const s = getSector(r, m);
                        if (s === sectorN) {
                            exact++;
                            if (isPrime(m)) {
                                primes++;
                            } else {
                                composites++;
                            }
                        }
                    }
                }
            }
            
            pcRatio = composites > 0 ? primes / composites : null;
            relError = exact > 0 ? ((exact - pred) / exact) * 100 : 0;
            
            // Store for extrapolation
            if (pcRatio !== null) {
                lastPCRatio = pcRatio;
                lastN = N;
            }
        } else {
            // Extrapolate P/C ratio based on last computed value
            // P/C ratio scales roughly as 1/ln(N) based on prime density
            if (lastPCRatio !== null && lastN !== null) {
                const scaleFactor = Math.log(lastN) / Math.log(N);
                pcRatio = lastPCRatio * scaleFactor;
            }
        }
        
        const errColor = relError !== null ? (Math.abs(relError) < 1 ? '#22c55e' : Math.abs(relError) < 5 ? '#f59e0b' : '#ef4444') : '#64748b';
        const pcColor = pcRatio !== null ? (pcRatio > 1 ? '#f59e0b' : '#6366f1') : '#64748b';
        
        html += '<tr style="border-bottom:1px solid #334155;">';
        html += '<td style="padding:6px 8px;font-family:monospace;">' + N.toLocaleString() + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;font-family:monospace;">' + pred.toFixed(2) + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;font-family:monospace;">' + (exact !== null ? exact.toLocaleString() : '<span style="color:#64748b;font-style:italic;">-</span>') + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;font-family:monospace;color:' + errColor + '">' + (relError !== null ? relError.toFixed(4) + '%' : '-') + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;color:#f59e0b;">' + (primes !== null ? primes.toLocaleString() : '-') + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;color:#6366f1;">' + (composites !== null ? composites.toLocaleString() : '-') + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;font-family:monospace;color:' + pcColor + '">' + (pcRatio !== null ? pcRatio.toFixed(6) + (N > maxComputeN ? '*' : '') : '-') + '</td>';
        html += '</tr>';
    });
    
    html += '</tbody></table>';
    
    // Add theoretical notes
    html += '<div style="margin-top:15px;padding:12px;background:#1e293b;border-radius:6px;font-size:11px;">';
    html += '<p style="color:#64748b;margin:0 0 8px 0;font-style:italic;">* Extrapolated from N=' + maxComputeN + ' using prime density scaling</p>';
    html += '<h5 style="color:#a5b4fc;margin:0 0 8px 0;">Theoretical Notes</h5>';
    html += '<p style="color:#94a3b8;margin:4px 0;"><strong>Error Convergence:</strong> Relative error goes to 0 as N approaches infinity (formula becomes exact asymptotically)</p>';
    html += '<p style="color:#94a3b8;margin:4px 0;"><strong>P/C Ratio Convergence:</strong> P/C goes to 0 as N approaches infinity (primes become sparse, density is approximately 1/ln(N))</p>';
    html += '<p style="color:#94a3b8;margin:4px 0;"><strong>Rate:</strong> Error is proportional to O(N^epsilon) for small epsilon; P/C is proportional to O(1/ln(N))</p>';
    html += '</div>';
    html += '</div>';
    
    // Show in modal
    showModal('Convergence Analysis', html);
}

function showModal(title, content) {
    let modal = document.getElementById('convergenceModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'convergenceModal';
        modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
        modal.innerHTML = `
            <div style="background:#0f172a;border:1px solid #6366f1;border-radius:12px;padding:20px;max-width:900px;width:90%;max-height:90vh;overflow:auto;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
                    <h3 id="modalTitle" style="margin:0;color:#e2e8f0;"></h3>
                    <button onclick="document.getElementById('convergenceModal').style.display='none'" style="background:#ef4444;border:none;border-radius:4px;color:white;padding:6px 12px;cursor:pointer;">Close</button>
                </div>
                <div id="modalContent"></div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    document.getElementById('modalTitle').textContent = title;
    document.getElementById('modalContent').innerHTML = content;
    modal.style.display = 'flex';
}

function computeGaps() {
    state.gaps = [];
    for(let i=0; i<state.allResidues.length-1; i++) {
        const l = state.allResidues[i], r = state.allResidues[i+1];
        const gap = r.value - l.value;
        state.gaps.push({left:l, right:r, gap, theoretical:1/(l.m*r.m), denomProduct:l.m*r.m, sector:l.sector});
        state.allResidues[i].gapRight = gap;
    }
    state.gaps.sort((a,b) => b.gap - a.gap);
}

function cancelComputation() { state.computing = false; }

// Fast update for formula-only mode - skip heavy computations
function updateFormulaOnlyDisplays() {
    updateMainStats();
    updateMainChartsFormulaOnly();
    updateMainTable();
    // Skip: drawMainRing, drawSectorTree, drawTheoryViz, updateGapAnalysis, 
    // computeFranel, computeDedekind, updateCFDisplay, computePSL, 
    // computeEulerProduct, updateModularAnalysis, draw3D, drawHyperbolic, 
    // drawSmithChart, updateStatistics, updatePrimeAnalysis
    // These require actual residue data which formula mode doesn't compute
}

function updateMainChartsFormulaOnly() {
    const labels = state.sectors.map(s=>s.n);
    const hasBoundedData = state.sectors.some(s => s.boundedExact !== null);
    
    if(state.charts.mainCount) state.charts.mainCount.destroy();
    
    const datasets = [{
        label:'Predicted (Formula N=' + state.nMax + ')',
        data:state.sectors.map(s=>s.predicted),
        borderColor:'#22c55e',
        backgroundColor:'rgba(34,197,94,0.1)',
        fill:true
    }];
    
    // Add bounded data if available
    if (hasBoundedData) {
        datasets.unshift({
            label: 'Bounded Exact (N‚â§' + state.boundedN + ')',
            data: state.sectors.map(s => s.boundedExact),
            borderColor: '#6366f1',
            backgroundColor: 'rgba(99,102,241,0.1)',
            fill: false,
            borderDash: [5, 5]
        });
        datasets.push({
            label: 'Bounded Predicted (N=' + state.boundedN + ')',
            data: state.sectors.map(s => s.boundedPredicted),
            borderColor: '#f59e0b',
            backgroundColor: 'transparent',
            fill: false,
            borderDash: [2, 2]
        });
    }
    
    state.charts.mainCount = new Chart(document.getElementById('mainCountChart'),{
        type:'line',
        data:{
            labels,
            datasets
        },
        options:{
            responsive:true,
            plugins:{
                legend:{labels:{color:'#94a3b8'}},
                title:{display:true, text: hasBoundedData ? 'Formula + Bounded Window Data' : 'Formula Predictions Only (No Exact Data)', color: hasBoundedData ? '#22c55e' : '#f59e0b'}
            },
            scales:{
                x:{ticks:{color:'#94a3b8'}},
                y:{ticks:{color:'#94a3b8'}}
            }
        }
    });
    
    // Show bounded error chart if available
    if(state.charts.mainError) state.charts.mainError.destroy();
    
    if (hasBoundedData) {
        state.charts.mainError = new Chart(document.getElementById('mainErrorChart'),{
            type:'bar',
            data:{
                labels,
                datasets:[{
                    label:'Bounded Rel Err% (N‚â§' + state.boundedN + ')',
                    data:state.sectors.map(s=>s.boundedRelError),
                    backgroundColor: state.sectors.map((s, i) => 
                        errorChartSelection.start !== null && i >= errorChartSelection.start && i <= errorChartSelection.end 
                            ? 'rgba(34,197,94,0.9)' 
                            : 'rgba(245,158,11,0.7)'
                    )
                }]
            },
            options:{
                responsive:true,
                plugins:{
                    legend:{display:false},
                    title:{display:true, text:'Bounded Window Error (N‚â§' + state.boundedN + ')', color:'#a5b4fc'}
                },
                scales:{
                    x:{
                        ticks:{
                            color:'#94a3b8',
                            maxRotation: 45,
                            autoSkip: true,
                            maxTicksLimit: 30
                        },
                        title: {display: true, text: 'Sector n', color: '#64748b'}
                    },
                    y:{ticks:{color:'#94a3b8'}}
                },
                onClick: (evt, elements) => {
                    if (elements && elements.length > 0) {
                        playErrorChartBar(elements[0].index);
                    }
                }
            }
        });
        
        // Setup selection handlers
        setupErrorChartSelection();
    } else {
        const ctx = document.getElementById('mainErrorChart').getContext('2d');
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('No error data in Formula mode', ctx.canvas.width/2, ctx.canvas.height/2 - 10);
        ctx.fillText('(Enable "Compute bounded window" for P/C data)', ctx.canvas.width/2, ctx.canvas.height/2 + 15);
    }
}

function updateAllDisplays() {
    updateViewSectorDropdown();
    updateMainStats(); updateMainCharts(); updateMainTable(); drawMainRing(); drawSectorTree();
    drawTheoryViz();
    updateGapAnalysis(); computeFranel(); computeDedekind(); updateCFDisplay();
    computePSL(); computeEulerProduct(); updateModularAnalysis(); draw3D();
    drawHyperbolic(); drawSmithChart(); updateStatistics(); updatePrimeAnalysis();
}

function updateViewSectorDropdown() {
    const select = document.getElementById('viewSector');
    if (!select) return;
    const currentVal = select.value || '2';
    const maxSector = state.sectorMax || 10;
    select.innerHTML = '';
    for (let i = 1; i <= Math.min(maxSector, 20); i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = i;
        if (i === parseInt(currentVal)) opt.selected = true;
        select.appendChild(opt);
    }
    // Update point count for range controls
    if (typeof updateSectorPointCount === 'function') {
        updateSectorPointCount();
    }
}

// THEORY VIZ FUNCTIONS
function phi(n) { return NumberTheory.phi(n); }

function drawTheoryViz() {
    drawSectorPartition();
    drawDensityCone();
    drawTotientSum();
    drawLatticeViz();
    drawProofSteps();
    drawConvergenceAnalysis();
    drawDensityHeatmap();
}

function drawSectorPartition() {
    const canvas = document.getElementById('sectorPartitionCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxSectors = +(document.getElementById('tvMaxSectors')?.value || 8);
    const showValues = document.getElementById('tvShowSectorValues')?.checked ?? true;
    const showWidths = document.getElementById('tvShowSectorWidths')?.checked ?? false;
    const style = document.getElementById('tvPartitionStyle')?.value || 'bar';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 50, barH = 40;
    const centerY = H/2;
    
    let legendHtml = '';
    
    if (style === 'arc') {
        // Arc/pie style
        const cx = W/2, cy = H/2, radius = Math.min(W,H)/2 - 60;
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, cy, radius, 0, 2*Math.PI); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const a1 = left * 2 * Math.PI - Math.PI/2;
            const a2 = right * 2 * Math.PI - Math.PI/2;
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.arc(cx, cy, radius, a1, a2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.stroke();
            
            if (showValues && n <= 6) {
                const midAngle = (a1 + a2) / 2;
                const labelR = radius * 0.7;
                ctx.fillStyle = '#e2e8f0';
                ctx.font = 'bold 11px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`S${n}`, cx + Math.cos(midAngle)*labelR, cy + Math.sin(midAngle)*labelR + 4);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else if (style === 'number') {
        // Number line style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        // Tick marks
        for (let i = 0; i <= 10; i++) {
            const x = margin + (i/10) * (W - 2*margin);
            ctx.beginPath(); ctx.moveTo(x, centerY - 10); ctx.lineTo(x, centerY + 10); ctx.stroke();
            ctx.fillStyle = '#94a3b8'; ctx.font = '10px system-ui'; ctx.textAlign = 'center';
            ctx.fillText((i/10).toFixed(1), x, centerY + 25);
        }
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color;
            ctx.fillRect(x1, centerY - 5, x2 - x1, 10);
            
            if (showValues && x2-x1 > 20) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '9px system-ui';
                ctx.fillText(`S${n}`, (x1+x2)/2, centerY - 15);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else {
        // Default bar style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.fillRect(x1, centerY - barH, x2 - x1, barH * 2);
            ctx.strokeStyle = color; ctx.lineWidth = 1;
            ctx.strokeRect(x1, centerY - barH, x2 - x1, barH * 2);
            
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 11px system-ui';
            ctx.textAlign = 'center';
            if(x2-x1 > 25) ctx.fillText(`S${n}`, (x1+x2)/2, centerY + 4);
            
            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px system-ui';
            ctx.fillText(`1/${n+1}`, x1, centerY + barH + 18);
            
            if (showWidths && x2-x1 > 30) {
                const width = 1/(n*(n+1));
                ctx.fillStyle = '#64748b';
                ctx.font = '8px system-ui';
                ctx.fillText(`w=${width.toFixed(3)}`, (x1+x2)/2, centerY + barH + 35);
            }
            
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}=(1/${n+1},1/${n}]</div>`;
        }
        
        ctx.fillStyle = '#f1f5f9';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('0', margin - 12, centerY + barH + 18);
        ctx.textAlign = 'right';
        ctx.fillText('1', W - margin + 12, centerY + barH + 18);
    }
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sectors Partition (0,1]', W/2, 25);
    
    document.getElementById('sectorPartitionLegend').innerHTML = legendHtml;
}

function drawDensityCone() {
    const canvas = document.getElementById('densityConeCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const numSectors = +(document.getElementById('tvConeSectors')?.value || 4);
    const logScale = document.getElementById('tvLogScale')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:55, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    const maxY = formula(1, maxN);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY * i / 4), margin.l - 5, y + 3);
    }
    
    let legendHtml = '';
    for (let n = 1; n <= numSectors; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let N = 10; N <= maxN; N += 3) {
            const C = formula(n, N);
            const x = margin.l + (N / maxN) * plotW;
            const yVal = logScale ? Math.log(C + 1) / Math.log(maxY + 1) : C / maxY;
            const y = margin.t + plotH - yVal * plotH;
            N === 10 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.font = '10px system-ui';
        const labelY = margin.t + plotH - (formula(n, maxN) / maxY) * plotH;
        ctx.fillText(`n=${n}`, W - margin.r - 30, Math.max(margin.t + 15, labelY + 4));
        
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N ‚Üí', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('C(n,N) ‚Üí', 0, 0);
    ctx.restore();
    
    document.getElementById('densityConeLegend').innerHTML = legendHtml;
}

function drawTotientSum() {
    const canvas = document.getElementById('totientSumCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const showActual = document.getElementById('tvShowTotientActual')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowTotientPredicted')?.checked ?? true;
    const showError = document.getElementById('tvShowTotientError')?.checked ?? false;
    const fill = document.getElementById('tvTotientFill')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:65, r:20, t:20, b:40};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumPhi = 0;
    const data = [];
    for (let b = 1; b <= maxN; b++) {
        cumPhi += phi(b);
        data.push({b, cumPhi, predicted: 3*b*b/(Math.PI*Math.PI)});
    }
    
    const maxY = data[data.length-1].cumPhi;
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY*i/4), margin.l - 5, y+3);
    }
    
    if (showActual) {
        if (fill) {
            ctx.fillStyle = 'rgba(99, 102, 241, 0.2)';
            ctx.beginPath();
            ctx.moveTo(margin.l, margin.t + plotH);
            data.forEach((d, i) => {
                const x = margin.l + (d.b / maxN) * plotW;
                const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
                ctx.lineTo(x, y);
            });
            ctx.lineTo(margin.l + plotW, margin.t + plotH);
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    if (showError) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const maxErr = data.reduce((max, d) => { const v = Math.abs(d.cumPhi - d.predicted); return v > max ? v : max; }, 0);
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const err = Math.abs(d.cumPhi - d.predicted) / maxErr;
            const y = margin.t + plotH - err * plotH * 0.3;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('b ‚Üí', W/2, H - 10);
}

function drawLatticeViz() {
    const canvas = document.getElementById('latticeVizCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxB = +(document.getElementById('tvLatticeSize')?.value || 22);
    const highlightSector = +(document.getElementById('tvHighlightSector')?.value || 2);
    const showHidden = document.getElementById('tvShowHidden')?.checked ?? true;
    const showSectorLines = document.getElementById('tvShowSectorLines')?.checked ?? true;
    const colorBySector = document.getElementById('tvColorBySector')?.checked ?? false;
    const pointSize = +(document.getElementById('tvPointSize')?.value || 4);
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 45;
    const scale = (Math.min(W, H) - 2*margin) / maxB;
    
    // Draw sector boundary lines first
    if (showSectorLines) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.setLineDash([5,5]);
        
        // Lines for highlighted sector boundaries
        const leftSlope = 1/(highlightSector+1);
        const rightSlope = 1/highlightSector;
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * leftSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * rightSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    for (let b = 1; b <= maxB; b++) {
        for (let a = 1; a <= b; a++) {
            const x = margin + a * scale;
            const y = H - margin - b * scale;
            
            const visible = gcd(a, b) === 1;
            
            if (!visible && !showHidden) continue;
            
            let color;
            if (!visible) {
                color = '#334155';
            } else if (colorBySector) {
                const sector = getSector(a, b);
                color = sector ? getSectorColor(sector) : '#6366f1';
            } else {
                color = '#6366f1';
            }
            
            // Highlight points in selected sector
            const inSector = visible && a/b > 1/(highlightSector+1) && a/b <= 1/highlightSector;
            
            ctx.fillStyle = inSector ? '#22c55e' : color;
            ctx.beginPath();
            ctx.arc(x, y, visible ? pointSize : pointSize/2, 0, 2*Math.PI);
            ctx.fill();
        }
    }
    
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, H - margin);
    ctx.lineTo(W - margin, H - margin);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('a ‚Üí', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('b ‚Üí', 0, 0);
    ctx.restore();
    
    // Sector label
    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector ${highlightSector} highlighted`, W/2, 20);
}

function drawProofSteps() {
    const canvas = document.getElementById('proofStepsCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const n = +(document.getElementById('tvProofSector')?.value || 2);
    const maxB = +(document.getElementById('tvMaxN')?.value || 100);
    const showContrib = document.getElementById('tvShowContribBars')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowProofPredicted')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumCount = 0;
    const data = [];
    for (let b = 2; b <= maxB; b++) {
        const sectorRes = (state.residuesBySector[n]||[]).filter(r => r.m === b).length;
        const contrib = sectorRes > 0 ? sectorRes : Math.round(phi(b) / (n * (n+1)));
        cumCount += contrib;
        data.push({b, cumCount, predicted: formula(n, b), contrib});
    }
    
    const maxY = Math.max(data[data.length-1].cumCount, data[data.length-1].predicted);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
    }
    
    if (showContrib) {
        ctx.fillStyle = '#f59e0b30';
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const h = (d.contrib / maxY) * plotH * 3;
            ctx.fillRect(x - 2, margin.t + plotH - h, 4, h);
        });
    }
    
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (d.b / maxB) * plotW;
        const y = margin.t + plotH - (d.cumCount / maxY) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Denominator b ‚Üí', W/2, H - 10);
    
    ctx.fillStyle = '#8b5cf6';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector n=${n}`, W/2, 18);
}

function drawConvergenceAnalysis() {
    const canvas = document.getElementById('convergenceCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const analysisType = document.getElementById('tvConvergenceType')?.value || 'relative';
    const showTrend = document.getElementById('tvShowConvergenceTrend')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:30, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate convergence data for multiple N values
    const data = [];
    for (let N = 20; N <= 200; N += 10) {
        const sectorData = [];
        for (let n = 1; n <= 5; n++) {
            // Simulate exact count based on formula with random error
            const predicted = formula(n, N);
            const exactEstimate = predicted + (Math.random() - 0.5) * Math.sqrt(N) * 2;
            
            let value;
            if (analysisType === 'relative') {
                value = ((exactEstimate - predicted) / predicted) * 100;
            } else if (analysisType === 'absolute') {
                value = exactEstimate - predicted;
            } else {
                value = exactEstimate / predicted;
            }
            sectorData.push({n, value});
        }
        data.push({N, sectors: sectorData});
    }
    
    // Find y-axis range
    let minY = Infinity, maxY = -Infinity;
    data.forEach(d => {
        d.sectors.forEach(s => {
            if (s.value < minY) minY = s.value;
            if (s.value > maxY) maxY = s.value;
        });
    });
    const yRange = maxY - minY || 1;
    
    // Grid
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        const label = minY + (i/4) * yRange;
        ctx.fillText(label.toFixed(analysisType === 'ratio' ? 2 : 1), margin.l - 5, y + 3);
    }
    
    // Draw lines for each sector
    let legendHtml = '';
    for (let n = 1; n <= 5; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        
        data.forEach((d, i) => {
            const sectorData = d.sectors.find(s => s.n === n);
            if (sectorData) {
                const x = margin.l + (i / (data.length - 1)) * plotW;
                const y = margin.t + plotH - ((sectorData.value - minY) / yRange) * plotH;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    // Trend line (zero for relative/absolute, 1 for ratio)
    if (showTrend) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1;
        const targetY = analysisType === 'ratio' ? 1 : 0;
        const y = margin.t + plotH - ((targetY - minY) / yRange) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        ctx.setLineDash([]);
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Target</div>`;
    }
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N ‚Üí', W/2, H - 10);
    
    const titles = {relative: 'Relative Error %', absolute: 'Absolute Error', ratio: 'Actual / Predicted'};
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(titles[analysisType], W/2, 18);
    
    document.getElementById('convergenceLegend').innerHTML = legendHtml;
}

function drawDensityHeatmap() {
    const canvas = document.getElementById('densityHeatmapCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const nMin = +(document.getElementById('tvHeatmapNMin')?.value || 20);
    const nMax = +(document.getElementById('tvHeatmapNMax')?.value || 150);
    const numSectors = +(document.getElementById('tvHeatmapSectors')?.value || 10);
    const colorScheme = document.getElementById('tvHeatmapColor')?.value || 'viridis';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:80, t:30, b:50};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate heatmap data
    const nSteps = 20;
    const nStep = (nMax - nMin) / nSteps;
    
    let minVal = Infinity, maxVal = -Infinity;
    const heatData = [];
    
    for (let i = 0; i <= nSteps; i++) {
        const N = nMin + i * nStep;
        const row = [];
        for (let n = 1; n <= numSectors; n++) {
            const val = formula(n, N);
            row.push(val);
            if (val < minVal) minVal = val;
            if (val > maxVal) maxVal = val;
        }
        heatData.push({N, values: row});
    }
    
    // Color functions
    function getColor(t, scheme) {
        if (scheme === 'viridis') {
            const r = Math.round(68 + t * (253 - 68));
            const g = Math.round(1 + t * (231 - 1));
            const b = Math.round(84 + t * (37 - 84));
            return `rgb(${r},${g},${b})`;
        } else if (scheme === 'plasma') {
            const r = Math.round(13 + t * (240 - 13));
            const g = Math.round(8 + t * (249 - 8));
            const b = Math.round(135 + t * (33 - 135));
            return `rgb(${r},${g},${b})`;
        } else {
            // Cool-warm
            if (t < 0.5) {
                const r = Math.round(59 + t * 2 * (255 - 59));
                const g = Math.round(76 + t * 2 * (255 - 76));
                const b = Math.round(192 - t * 2 * (192 - 255));
                return `rgb(${r},${g},${b})`;
            } else {
                const r = 255;
                const g = Math.round(255 - (t - 0.5) * 2 * (255 - 59));
                const b = Math.round(255 - (t - 0.5) * 2 * (255 - 76));
                return `rgb(${r},${g},${b})`;
            }
        }
    }
    
    // Draw heatmap cells
    const cellW = plotW / numSectors;
    const cellH = plotH / (nSteps + 1);
    
    heatData.forEach((row, i) => {
        row.values.forEach((val, j) => {
            const t = (val - minVal) / (maxVal - minVal);
            ctx.fillStyle = getColor(t, colorScheme);
            ctx.fillRect(margin.l + j * cellW, margin.t + i * cellH, cellW - 1, cellH - 1);
        });
    });
    
    // X-axis labels (sectors)
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    for (let n = 1; n <= numSectors; n++) {
        ctx.fillText(`S${n}`, margin.l + (n - 0.5) * cellW, H - margin.b + 20);
    }
    ctx.fillText('Sector n', margin.l + plotW/2, H - 10);
    
    // Y-axis labels (N values)
    ctx.textAlign = 'right';
    for (let i = 0; i <= nSteps; i += 4) {
        const N = Math.round(nMin + i * nStep);
        ctx.fillText(N, margin.l - 5, margin.t + i * cellH + cellH/2 + 3);
    }
    ctx.save();
    ctx.translate(15, margin.t + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = 'center';
    ctx.fillText('N ‚Üí', 0, 0);
    ctx.restore();
    
    // Color bar
    const barW = 20, barH = plotH;
    const barX = W - margin.r + 20;
    for (let i = 0; i < barH; i++) {
        const t = 1 - i / barH;
        ctx.fillStyle = getColor(t, colorScheme);
        ctx.fillRect(barX, margin.t + i, barW, 1);
    }
    ctx.strokeStyle = '#475569';
    ctx.strokeRect(barX, margin.t, barW, barH);
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(fmt(maxVal), barX + barW + 5, margin.t + 10);
    ctx.fillText(fmt(minVal), barX + barW + 5, margin.t + barH);
    ctx.fillText('C(n,N)', barX + barW + 5, margin.t + barH/2);
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`Sector Density Heatmap (N: ${nMin}-${nMax})`, W/2, 18);
}

let theoryAnimationId = null;
function animateTheoryViz() {
    if (theoryAnimationId) {
        cancelAnimationFrame(theoryAnimationId);
        theoryAnimationId = null;
        return;
    }
    
    let currentN = 20;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const originalN = document.getElementById('tvMaxN').value;
    
    function step() {
        document.getElementById('tvMaxN').value = currentN;
        drawTheoryViz();
        
        currentN += 5;
        if (currentN <= maxN) {
            theoryAnimationId = requestAnimationFrame(() => setTimeout(step, 100));
        } else {
            document.getElementById('tvMaxN').value = originalN;
            theoryAnimationId = null;
        }
    }
    step();
}

function updateMainStats() {
    const hasExact = state.sectors.some(s=>s.exact!==null);
    const total = hasExact ? state.sectors.reduce((s,x)=>s+(x.exact||0),0) : null;
    const totalPred = state.sectors.reduce((s,x)=>s+x.predicted,0);
    const primeCount = hasExact ? state.allResidues.filter(r => r.isPrime).length : null;
    const primeRate = total && primeCount ? (primeCount / total * 100).toFixed(1) : '-';
    const error = total ? ((total - totalPred) / totalPred * 100).toFixed(2) : '-';
    const avgPerSector = total ? (total / state.sectors.length).toFixed(0) : '-';
    
    document.getElementById('mainStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${state.nMin === 1 ? fmt(state.nMax) : state.nMin + '-' + fmt(state.nMax)}</div><div class="stat-label">N Range</div></div>
        <div class="stat-card"><div class="stat-value">${hasExact ? fmt(total) : fmt(totalPred)}</div><div class="stat-label">${hasExact ? '|F‚Çô| Exact' : 'Predicted'}</div></div>
        <div class="stat-card"><div class="stat-value" style="color:${parseFloat(error)>=0?'#22c55e':'#ef4444'}">${error}%</div><div class="stat-label">Error</div></div>
        <div class="stat-card"><div class="stat-value">${state.sectors.length}</div><div class="stat-label">Sectors</div></div>
        <div class="stat-card"><div class="stat-value">${primeRate}%</div><div class="stat-label">Prime Denom</div></div>
        <div class="stat-card"><div class="stat-value">${avgPerSector}</div><div class="stat-label">Avg/Sector</div></div>
    `;
    
    updateFormulaDisplay();
}

function updateFormulaDisplay() {
    const formulaComputed = document.getElementById('formulaComputed');
    if (!formulaComputed) return;
    
    const N = state.nMax;
    const n = document.getElementById('viewSector')?.value || 1;
    let nVal = parseInt(n) || 1;
    if (nVal < 1) nVal = 1; // Prevent division by zero
    
    // Calculate the formula result for current sector
    const N2 = N * N;
    const pi2 = Math.PI * Math.PI;
    const denominator = nVal * (nVal + 1);
    const result = (3 * N2) / (pi2 * denominator);
    
    // Show computed values
    formulaComputed.innerHTML = `<span style="color:#94a3b8;">For n=${nVal}, N=${N.toLocaleString()}:</span> ` +
        `C(${nVal}, ${N.toLocaleString()}) = 3√ó${N.toLocaleString()}¬≤ / (œÄ¬≤√ó${nVal}√ó${nVal+1}) = ` +
        `<span style="color:#22c55e;font-weight:bold;">${result.toFixed(4)}</span>`;
    formulaComputed.style.display = 'block';
}

function updateMainCharts() {
    const labels = state.sectors.map(s=>s.n);
    const hasExact = state.sectors.some(s=>s.exact!==null);
    
    if(state.charts.mainCount) state.charts.mainCount.destroy();
    const ds = [{label:'Predicted',data:state.sectors.map(s=>s.predicted),borderColor:'#22c55e',borderDash:[5,5],fill:false}];
    if(hasExact) ds.unshift({label:'Exact',data:state.sectors.map(s=>s.exact),borderColor:'#6366f1',backgroundColor:'rgba(99,102,241,0.1)',fill:true});
    state.charts.mainCount = new Chart(document.getElementById('mainCountChart'),{type:'line',data:{labels,datasets:ds},options:{responsive:true,plugins:{legend:{labels:{color:'#94a3b8'}},zoom:{zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'xy'},pan:{enabled:true,mode:'xy'}}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.mainError) state.charts.mainError.destroy();
    if(hasExact) {
        state.charts.mainError = new Chart(document.getElementById('mainErrorChart'),{
            type:'bar',
            data:{
                labels,
                datasets:[{
                    label:'Rel Err%',
                    data:state.sectors.map(s=>s.relError),
                    backgroundColor: state.sectors.map((s, i) => 
                        errorChartSelection.start !== null && i >= errorChartSelection.start && i <= errorChartSelection.end 
                            ? 'rgba(34,197,94,0.9)' 
                            : 'rgba(245,158,11,0.7)'
                    )
                }]
            },
            options:{
                responsive:true,
                plugins:{
                    legend:{display:false},
                    zoom:{
                        zoom:{
                            wheel:{enabled:true},
                            pinch:{enabled:true},
                            mode:'xy'
                        },
                        pan:{
                            enabled:true,
                            mode:'xy'
                        }
                    }
                },
                scales:{
                    x:{
                        ticks:{
                            color:'#94a3b8',
                            maxRotation: 45,
                            autoSkip: true,
                            maxTicksLimit: 30
                        },
                        title: {display: true, text: 'Sector n', color: '#64748b'}
                    },
                    y:{ticks:{color:'#94a3b8'}}
                },
                onClick: (evt, elements) => {
                    if (elements.length > 0) {
                        const idx = elements[0].index;
                        playErrorChartBar(idx);
                    }
                }
            }
        });
        
        // Add drag selection for region
        setupErrorChartSelection();
    }
}

function updateMainTable() {
    const tbody = document.querySelector('#mainTable tbody');
    const theadRow = document.getElementById('mainTableHeader');
    const sectorSelect = document.getElementById('sectorDataSelect');
    const showCategories = document.getElementById('showCategoryColumns')?.checked || false;
    const categoryLegend = document.getElementById('categoryLegend');
    const decimals = parseInt(document.getElementById('sectorTableDecimals')?.value || 2);
    
    // Show/hide legend
    if (categoryLegend) categoryLegend.style.display = showCategories ? 'block' : 'none';
    
    // Update header based on category toggle
    if (theadRow) {
        if (showCategories) {
            theadRow.innerHTML = '<th>n</th><th>Interval</th><th>Exact</th><th>Pred</th><th>Err%</th>' +
                '<th title="P(m) = Prime denominator count (m is prime: 2,3,5,7,...)" style="color:#f59e0b;">P(m)</th>' +
                '<th title="C(m) = Composite denominator count (m is composite: 4,6,8,9,...)" style="color:#6366f1;">C(m)</th>' +
                '<th title="P/C = P(m)/C(m) ratio">P/C</th>' +
                '<th title="P(r) = Prime numerator count (r is prime)" style="color:#a5b4fc;">P(r)</th>' +
                '<th title="PP = Both prime (r prime AND m prime)" style="color:#22c55e;">PP</th>' +
                '<th title="PC = Prime numerator, Composite denominator" style="color:#f59e0b;">PC</th>' +
                '<th title="CP = Composite numerator, Prime denominator" style="color:#6366f1;">CP</th>' +
                '<th title="CC = Both composite (r composite AND m composite)" style="color:#94a3b8;">CC</th>';
        } else {
            theadRow.innerHTML = '<th>n</th><th>Interval</th><th>Exact</th><th>Pred</th><th>Err%</th>' +
                '<th title="P(m) = Prime denominator count (m is prime: 2,3,5,7,...)">P(m)</th>' +
                '<th title="C(m) = Composite denominator count (m is composite: 4,6,8,9,...)">C(m)</th>' +
                '<th title="P/C = P(m)/C(m) ratio">P/C</th>';
        }
    }
    
    let html = '';
    let optionsHtml = '<option value="">-- Select Sector --</option>';
    
    // Check if we're in formula/large N mode and have bounded data
    const usesBoundedData = state.nMax > 3000 || state.mode === 'formula';
    const hasBoundedData = Object.keys(state.boundedResiduesBySector).length > 0;
    
    state.sectors.forEach((s, idx) => {
        // Use actual residues if available, otherwise use bounded data
        let res = state.residuesBySector[s.n] || [];
        let primeCount, compositeCount, primeNumCount, ppCount, pcCount, cpCount, ccCount;
        let dataSource = '';
        
        if (res.length > 0) {
            // We have exact data for this sector
            primeCount = res.filter(r => r.isPrime).length;
            compositeCount = res.length - primeCount;
            primeNumCount = s.primeNumCount || res.filter(r => r.isPrimeNum).length;
            ppCount = s.ppCount || res.filter(r => r.category === 'PP').length;
            pcCount = s.pcCount || res.filter(r => r.category === 'PC').length;
            cpCount = s.cpCount || res.filter(r => r.category === 'CP').length;
            ccCount = s.ccCount || res.filter(r => r.category === 'CC').length;
        } else if (hasBoundedData && state.boundedResiduesBySector[s.n]) {
            // Use bounded window data
            res = state.boundedResiduesBySector[s.n];
            primeCount = s.boundedPrimeCount || res.filter(r => r.isPrime).length;
            compositeCount = s.boundedCompositeCount || (res.length - primeCount);
            primeNumCount = s.boundedPrimeNumCount || res.filter(r => r.isPrimeNum).length;
            ppCount = s.boundedPP || res.filter(r => r.category === 'PP').length;
            pcCount = s.boundedPC || res.filter(r => r.category === 'PC').length;
            cpCount = s.boundedCP || res.filter(r => r.category === 'CP').length;
            ccCount = s.boundedCC || res.filter(r => r.category === 'CC').length;
            dataSource = '*';
        } else {
            primeCount = 0;
            compositeCount = 0;
            primeNumCount = 0;
            ppCount = 0; pcCount = 0; cpCount = 0; ccCount = 0;
        }
        
        const errColor = s.relError !== null && Math.abs(s.relError) > 10 ? '#f87171' : '#4ade80';
        
        // Calculate P/C ratio (use bounded if available)
        let pcRatio = '-';
        let pcColor = '#94a3b8';
        if (s.boundedPCRatio !== undefined && s.boundedPCRatio !== null) {
            pcRatio = s.boundedPCRatio.toFixed(decimals);
            pcColor = s.boundedPCRatio > 1 ? '#f59e0b' : s.boundedPCRatio < 1 ? '#6366f1' : '#22c55e';
        } else if (compositeCount > 0) {
            const ratio = primeCount / compositeCount;
            pcRatio = ratio.toFixed(decimals);
            pcColor = ratio > 1 ? '#f59e0b' : ratio < 1 ? '#6366f1' : '#22c55e';
        } else if (primeCount > 0) {
            pcRatio = '‚àû';
            pcColor = '#f59e0b';
        }
        
        // Format predicted with configurable precision
        const predStr = s.predicted !== null ? s.predicted.toFixed(decimals) : '-';
        
        // Show bounded error if available, otherwise regular error
        let errStr = '-';
        let errValue = null;
        if (s.relError !== null) {
            errStr = s.relError.toFixed(decimals) + '%';
            errValue = s.relError;
        } else if (s.boundedRelError !== null) {
            errStr = s.boundedRelError.toFixed(decimals) + '%*';
            errValue = s.boundedRelError;
        }
        const displayErrColor = errValue !== null && Math.abs(errValue) > 10 ? '#f87171' : '#4ade80';
        
        // Show exact count or bounded exact
        let exactDisplay = '-';
        if (s.exact !== null) {
            exactDisplay = s.exact;
        } else if (s.boundedExact !== null) {
            exactDisplay = s.boundedExact + '*';
        }
        
        // Prime/composite display
        const primeDisplay = primeCount > 0 ? primeCount + dataSource : '-';
        const compositeDisplay = compositeCount > 0 ? compositeCount + dataSource : '-';
        const primeNumDisplay = primeNumCount > 0 ? primeNumCount + dataSource : '-';
        
        html += '<tr data-sector="' + s.n + '" data-idx="' + idx + '" onclick="showSectorDataDetail(' + s.n + ')" style="cursor:pointer" title="Click to see sector ' + s.n + ' details">' +
            '<td><strong>' + s.n + '</strong></td>' +
            '<td>(1/' + (s.n+1) + ', 1/' + s.n + ']</td>' +
            '<td>' + exactDisplay + '</td>' +
            '<td style="font-family:monospace;font-size:11px;">' + predStr + '</td>' +
            '<td style="color:' + displayErrColor + ';font-family:monospace;font-size:11px;">' + errStr + '</td>' +
            '<td style="color:#f59e0b;font-size:11px;">' + primeDisplay + '</td>' +
            '<td style="color:#6366f1;font-size:11px;">' + compositeDisplay + '</td>' +
            '<td style="color:' + pcColor + ';font-family:monospace;">' + pcRatio + '</td>';
        
        // Add category columns if enabled
        if (showCategories) {
            html += '<td style="color:#a5b4fc;font-size:11px;">' + primeNumDisplay + '</td>' +
                    '<td style="color:#22c55e;font-size:11px;">' + (ppCount > 0 ? ppCount + dataSource : '-') + '</td>' +
                    '<td style="color:#f59e0b;font-size:11px;">' + (pcCount > 0 ? pcCount + dataSource : '-') + '</td>' +
                    '<td style="color:#6366f1;font-size:11px;">' + (cpCount > 0 ? cpCount + dataSource : '-') + '</td>' +
                    '<td style="color:#94a3b8;font-size:11px;">' + (ccCount > 0 ? ccCount + dataSource : '-') + '</td>';
        }
        
        html += '</tr>';
        
        optionsHtml += '<option value="' + s.n + '">Sector ' + s.n + ' (' + (res.length || 'formula') + ' fractions)</option>';
    });
    
    // Add footnote if using bounded data
    const colSpan = showCategories ? 13 : 8;
    if (usesBoundedData && hasBoundedData) {
        html += '<tr style="background:#1e1b4b;"><td colspan="' + colSpan + '" style="font-size:10px;color:#a5b4fc;padding:8px;text-align:center;">* Data from bounded window N ‚â§ ' + state.boundedN + ' | P(m)=Prime denom, C(m)=Composite denom, P(r)=Prime num | PP=Both prime, PC=P num C denom, CP=C num P denom, CC=Both composite</td></tr>';
    }
    
    tbody.innerHTML = html;
    if (sectorSelect) sectorSelect.innerHTML = optionsHtml;
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = `Sector ${n}: (1/${n+1}, 1/${n}]`;
    
    let html = `
        <div class="stat-grid" style="margin-bottom:15px;">
            <div class="stat-card"><div class="stat-value">${res.length}</div><div class="stat-label">Total Pairs</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#f59e0b">${primes.length}</div><div class="stat-label">Prime Moduli</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#6366f1">${composites.length}</div><div class="stat-label">Composite Moduli</div></div>
            <div class="stat-card"><div class="stat-value">${sector ? fmt(sector.predicted) : '-'}</div><div class="stat-label">Predicted</div></div>
            <div class="stat-card"><div class="stat-value">${sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-'}</div><div class="stat-label">Error</div></div>
        </div>
        
        <h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (${primes.length})</h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #f59e0b30;">
            ${primes.length > 0 ? primes.map(p => `<span class="residue-item prime" title="m=${p.m} is prime">${p.r}/${p.m}</span>`).join('') : '<span style="color:#64748b">No prime moduli in this sector</span>'}
        </div>
        
        <h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (${composites.length}) <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #6366f130;">
            ${composites.length > 0 ? composites.slice(0,100).map(c => `<span class="residue-item">${c.r}/${c.m}</span>`).join('') : '<span style="color:#64748b">No composite moduli in this sector</span>'}
            ${composites.length > 100 ? `<span style="color:#64748b; display:block; margin-top:8px;">... and ${composites.length - 100} more</span>` : ''}
        </div>
        
        <div style="margin-top:15px; display:flex; gap:10px; flex-wrap:wrap;">
            <button onclick="playSectorAudio(${n}, 'forward')" style="background:linear-gradient(135deg,#22c55e,#16a34a);">‚ñ∂ Play All Forward</button>
            <button onclick="playSectorAudio(${n}, 'backward')" style="background:linear-gradient(135deg,#6366f1,#8b5cf6);">‚óÄ Play All Backward</button>
            <button onclick="playSectorPrimes(${n})" style="background:linear-gradient(135deg,#f59e0b,#d97706);">‚ñ∂ Play Primes</button>
            <button onclick="stopAllPlayback()" style="background:#ef4444;">‚ñ† Stop</button>
            <button onclick="exportSectorData(${n})">Export Sector CSV</button>
            <button class="secondary" onclick="viewSectorOnRing(${n})">View on Ring</button>
        </div>
    `;
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += `${r.r},${r.m},${r.value},${r.isPrime}\n`;
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `sector_${n}_data.csv`;
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

// =============================================
// GLOBAL DISPLAY FORMAT SYSTEM
// =============================================

const globalFormat = {
    type: 'fraction',
    precision: 4
};

function updateGlobalDisplayFormat() {
    globalFormat.type = document.getElementById('globalDisplayFormat')?.value || 'fraction';
    globalFormat.precision = parseInt(document.getElementById('globalPrecision')?.value) || 4;
    
    // Update preview
    const preview = document.getElementById('globalFormatPreview');
    if (preview) {
        preview.textContent = '1/2 = ' + formatValueGlobal(1, 2);
    }
    
    // Refresh displays that use global format
    if (document.getElementById('sectorDetailPanel')?.style.display !== 'none') {
        const sectorSelect = document.getElementById('sectorDataSelect');
        if (sectorSelect?.value) showSectorDataDetail(sectorSelect.value);
    }
    if (typeof updateHorizonTree === 'function' && typeof horizonData !== 'undefined' && horizonData?.gatekeeper) {
        const n = parseInt(document.getElementById('horizonSectorN')?.value) || 5;
        updateHorizonTree(horizonData, n);
        updateHorizonFractionList(horizonData);
    }
}

function formatValueGlobal(r, m) {
    const value = r / m;
    const prec = globalFormat.precision;
    
    switch (globalFormat.type) {
        case 'fraction':
            return r + '/' + m;
        case 'decimal':
            return value.toFixed(prec);
        case 'degree':
            return (value * 360).toFixed(prec) + '¬∞';
        case 'radian':
            return (value * 2 * Math.PI).toFixed(prec) + ' rad';
        case 'pi':
            return (value * 2).toFixed(prec) + 'œÄ';
        default:
            return r + '/' + m;
    }
}

function formatFractionGlobal(f) {
    if (f.r !== undefined && f.m !== undefined) {
        return formatValueGlobal(f.r, f.m);
    } else if (f.p !== undefined && f.q !== undefined) {
        return formatValueGlobal(f.p, f.q);
    }
    return '?/?';
}

// =============================================
// SECTOR DATA DETAIL FUNCTIONS
// =============================================

function showSectorDataDetail(n) {
    if (!n) {
        document.getElementById('sectorDetailPanel').style.display = 'none';
        state.highlightSectorOnly = null;
        drawMainRing();
        return;
    }
    
    n = parseInt(n);
    
    // Highlight this sector on the ring (show all, dim others)
    document.getElementById('showAllSectors').checked = true;
    state.highlightSectorOnly = n;
    drawMainRing();
    
    // Use actual residues if available, otherwise use bounded data
    let res = state.residuesBySector[n] || [];
    let dataSource = '';
    
    if (res.length === 0 && state.boundedResiduesBySector[n]) {
        res = state.boundedResiduesBySector[n];
        dataSource = ' (from bounded N‚â§' + state.boundedN + ')';
    }
    
    const primes = res.filter(r => r.isPrime);        // Prime denominator
    const composites = res.filter(r => !r.isPrime);   // Composite denominator
    const primeNums = res.filter(r => r.isPrimeNum);  // Prime numerator
    
    // Category counts
    const ppFracs = res.filter(r => r.category === 'PP');  // Both prime
    const pcFracs = res.filter(r => r.category === 'PC');  // Prime num, Comp denom
    const cpFracs = res.filter(r => r.category === 'CP');  // Comp num, Prime denom
    const ccFracs = res.filter(r => r.category === 'CC');  // Both composite
    
    // Update dropdown
    document.getElementById('sectorDataSelect').value = n;
    
    // Update title
    document.getElementById('sectorDetailTitle').textContent = 
        'Sector ' + n + ': (1/' + (n+1) + ', 1/' + n + '] ‚Äî ' + res.length + ' fractions' + dataSource;
    
    // Update counts
    document.getElementById('sectorPrimeCount').textContent = primes.length;
    document.getElementById('sectorCompositeCount').textContent = composites.length;
    
    // Update category stats
    document.getElementById('statPrimeM').textContent = primes.length;
    document.getElementById('statCompM').textContent = composites.length;
    document.getElementById('statPrimeR').textContent = primeNums.length;
    document.getElementById('statPP').textContent = ppFracs.length;
    document.getElementById('statPC').textContent = pcFracs.length;
    document.getElementById('statCP').textContent = cpFracs.length;
    document.getElementById('statCC').textContent = ccFracs.length;
    
    // Calculate and display P/C ratio
    const pcRatioEl = document.getElementById('sectorPCRatio');
    if (composites.length > 0) {
        const ratio = primes.length / composites.length;
        pcRatioEl.textContent = ratio.toFixed(10) + dataSource;
        pcRatioEl.style.color = ratio > 1 ? '#f59e0b' : ratio < 1 ? '#6366f1' : '#22c55e';
    } else if (primes.length > 0) {
        pcRatioEl.textContent = '‚àû (no composites)' + dataSource;
        pcRatioEl.style.color = '#f59e0b';
    } else {
        pcRatioEl.textContent = '0/0 (empty)';
        pcRatioEl.style.color = '#64748b';
    }
    
    // Helper to format fraction with category color
    function formatFracWithCategory(f) {
        const catColors = { 'PP': '#22c55e', 'PC': '#f59e0b', 'CP': '#6366f1', 'CC': '#94a3b8' };
        const bgColors = { 'PP': '#22c55e33', 'PC': '#f59e0b33', 'CP': '#6366f133', 'CC': '#94a3b833' };
        const color = catColors[f.category] || '#94a3b8';
        const bg = bgColors[f.category] || '#94a3b833';
        return '<span onclick="triggerGlobalHarmonic(' + f.r + ',' + f.m + ')" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:' + bg + ';border:1px solid ' + color + ';cursor:pointer;color:' + color + ';" title="' + (f.r/f.m).toFixed(10) + ' [' + f.category + ']">' + formatValueGlobal(f.r, f.m) + '</span>';
    }
    
    // Format and display primes (sorted by value, showing category)
    const primesHtml = primes.length > 0 
        ? primes.sort((a,b) => a.r/a.m - b.r/b.m).map(formatFracWithCategory).join('')
        : '<span style="color:#64748b">No prime denominators in this sector</span>';
    
    // Format and display composites (limit to 200)
    const compositesHtml = composites.length > 0 
        ? composites.sort((a,b) => a.r/a.m - b.r/b.m).slice(0, 200).map(formatFracWithCategory).join('') + 
          (composites.length > 200 ? '<br><span style="color:#64748b;margin-top:8px;display:block;">... and ' + (composites.length - 200) + ' more</span>' : '')
        : '<span style="color:#64748b">No composite denominators in this sector</span>';
    
    document.getElementById('sectorPrimesList').innerHTML = primesHtml;
    document.getElementById('sectorCompositesList').innerHTML = compositesHtml;
    
    // Show panel
    document.getElementById('sectorDetailPanel').style.display = 'block';
}

function closeSectorDetail() {
    document.getElementById('sectorDetailPanel').style.display = 'none';
    document.getElementById('sectorDataSelect').value = '';
    state.highlightSectorOnly = null;
    drawMainRing();
}

function playSectorDetailFractions(type, direction) {
    const n = parseInt(document.getElementById('sectorDataSelect').value);
    if (!n) {
        showPlaybackStatus('Select a sector first');
        return;
    }
    
    // Use actual residues if available, otherwise use bounded data
    let res = state.residuesBySector[n] || [];
    if (res.length === 0 && state.boundedResiduesBySector[n]) {
        res = state.boundedResiduesBySector[n];
    }
    
    let fracs;
    let typeLabel = type;
    
    // Filter by type
    switch(type) {
        case 'primes':
            fracs = res.filter(r => r.isPrime);
            typeLabel = 'prime denominators';
            break;
        case 'composites':
            fracs = res.filter(r => !r.isPrime);
            typeLabel = 'composite denominators';
            break;
        case 'primeNums':
            fracs = res.filter(r => r.isPrimeNum);
            typeLabel = 'prime numerators';
            break;
        case 'PP':
            fracs = res.filter(r => r.category === 'PP');
            typeLabel = 'PP (both prime)';
            break;
        case 'PC':
            fracs = res.filter(r => r.category === 'PC');
            typeLabel = 'PC (prime num, comp denom)';
            break;
        case 'CP':
            fracs = res.filter(r => r.category === 'CP');
            typeLabel = 'CP (comp num, prime denom)';
            break;
        case 'CC':
            fracs = res.filter(r => r.category === 'CC');
            typeLabel = 'CC (both composite)';
            break;
        default:
            fracs = res;
            typeLabel = 'all';
    }
    
    if (fracs.length === 0) {
        showPlaybackStatus('No ' + typeLabel + ' fractions in sector ' + n);
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value
    fracs = [...fracs].sort((a, b) => direction === 'forward' ? a.r/a.m - b.r/b.m : b.r/b.m - a.r/a.m);
    
    // Play all fractions (no limit)
    playbackState.queue = fracs.map(f => ({ r: f.r, m: f.m }));
    playbackState.direction = direction;
    playbackState.mode = 'sector-detail';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing ${typeLabel} from sector ${n} (${fracs.length} fractions)`);
    startPlaybackLoop();
}

function exportSectorCSV(n) {
    if (!n) {
        alert('Please select a sector first');
        return;
    }
    n = parseInt(n);
    
    // Use actual residues if available, otherwise use bounded data
    let res = state.residuesBySector[n] || [];
    let dataSource = '';
    if (res.length === 0 && state.boundedResiduesBySector[n]) {
        res = state.boundedResiduesBySector[n];
        dataSource = ' (from bounded N‚â§' + state.boundedN + ')';
    }
    
    if (res.length === 0) {
        alert('No data for sector ' + n);
        return;
    }
    
    const primeCount = res.filter(r => r.isPrime).length;
    const compositeCount = res.filter(r => !r.isPrime).length;
    const primeNumCount = res.filter(r => r.isPrimeNum).length;
    const ppCount = res.filter(r => r.category === 'PP').length;
    const pcCount = res.filter(r => r.category === 'PC').length;
    const cpCount = res.filter(r => r.category === 'CP').length;
    const ccCount = res.filter(r => r.category === 'CC').length;
    const pcRatio = compositeCount > 0 ? (primeCount / compositeCount).toFixed(10) : (primeCount > 0 ? 'Infinity' : 'N/A');
    
    const prec = 10; // Use 10 decimal places
    let csv = 'Sector ' + n + ' Data Export' + dataSource + '\n';
    csv += 'Interval,(1/' + (n+1) + ', 1/' + n + ']\n';
    csv += 'Total Fractions,' + res.length + '\n';
    csv += 'Prime Denominators P(m),' + primeCount + '\n';
    csv += 'Composite Denominators C(m),' + compositeCount + '\n';
    csv += 'Prime Numerators P(r),' + primeNumCount + '\n';
    csv += 'P/C Ratio (denom),' + pcRatio + '\n';
    csv += 'PP (both prime),' + ppCount + '\n';
    csv += 'PC (prime num comp denom),' + pcCount + '\n';
    csv += 'CP (comp num prime denom),' + cpCount + '\n';
    csv += 'CC (both composite),' + ccCount + '\n\n';
    csv += 'Numerator,Denominator,Value,Degrees,Radians,Pi-Fraction,Denom Type,Num Type,Category,Frequency (Hz)\n';
    
    res.sort((a, b) => a.r/a.m - b.r/b.m).forEach(f => {
        const val = f.r / f.m;
        const freq = (harmonicSettings?.baseFreq || 440) * val;
        csv += f.r + ',' + f.m + ',' + val.toFixed(prec) + ',' + 
               (val * 360).toFixed(prec) + ',' + 
               (val * 2 * Math.PI).toFixed(prec) + ',' + 
               (val * 2).toFixed(prec) + 'œÄ,' +
               (f.isPrime ? 'Prime' : 'Composite') + ',' +
               (f.isPrimeNum ? 'Prime' : 'Composite') + ',' +
               (f.category || '-') + ',' +
               freq.toFixed(2) + '\n';
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'sector_' + n + '_N' + state.nMax + '_data.csv';
    a.click();
}

function exportAllSectorsCSV() {
    if (state.sectors.length === 0) {
        alert('No data to export. Run computation first.');
        return;
    }
    
    const prec = 10; // Use 10 decimal places
    const hasBoundedData = Object.keys(state.boundedResiduesBySector).length > 0;
    
    let csv = 'All Sectors Data Export\n';
    csv += 'N Range,' + state.nMin + ' to ' + state.nMax + '\n';
    csv += 'Sectors,' + state.sectorMin + ' to ' + state.sectorMax + '\n';
    csv += 'Total Fractions,' + state.allResidues.length + '\n';
    if (hasBoundedData) {
        csv += 'Bounded Window N,' + state.boundedN + '\n';
    }
    csv += '\n';
    
    // Add sector summary with P/C ratios and categories
    csv += 'SECTOR SUMMARY\n';
    csv += 'Sector,Interval,Exact,Predicted,Error%,P(m),C(m),P/C Ratio,P(r),PP,PC,CP,CC\n';
    state.sectors.forEach(s => {
        // Use actual residues if available, otherwise use bounded data
        let res = state.residuesBySector[s.n] || [];
        if (res.length === 0 && state.boundedResiduesBySector[s.n]) {
            res = state.boundedResiduesBySector[s.n];
        }
        
        const primeCount = res.filter(r => r.isPrime).length;
        const compositeCount = res.length - primeCount;
        const primeNumCount = res.filter(r => r.isPrimeNum).length;
        const ppCount = res.filter(r => r.category === 'PP').length;
        const pcCount = res.filter(r => r.category === 'PC').length;
        const cpCount = res.filter(r => r.category === 'CP').length;
        const ccCount = res.filter(r => r.category === 'CC').length;
        const pcRatio = compositeCount > 0 ? (primeCount / compositeCount).toFixed(10) : (primeCount > 0 ? 'Infinity' : 'N/A');
        
        csv += s.n + ',' +
               '(1/' + (s.n+1) + ' - 1/' + s.n + '],' +
               (s.exact !== null ? s.exact : (s.boundedExact || '')) + ',' +
               (s.predicted !== null ? s.predicted.toFixed(10) : '') + ',' +
               (s.relError !== null ? s.relError.toFixed(6) : (s.boundedRelError ? s.boundedRelError.toFixed(6) : '')) + ',' +
               primeCount + ',' +
               compositeCount + ',' +
               pcRatio + ',' +
               primeNumCount + ',' +
               ppCount + ',' +
               pcCount + ',' +
               cpCount + ',' +
               ccCount + '\n';
    });
    
    csv += '\nFRACTION DETAILS\n';
    csv += 'Sector,Numerator,Denominator,Value,Degrees,Radians,Pi-Fraction,Denom Type,Num Type,Category,Frequency (Hz)\n';
    
    for (let s = state.sectorMin; s <= state.sectorMax; s++) {
        // Use actual residues if available, otherwise use bounded data
        let res = state.residuesBySector[s] || [];
        if (res.length === 0 && state.boundedResiduesBySector[s]) {
            res = state.boundedResiduesBySector[s];
        }
        
        res.sort((a, b) => a.r/a.m - b.r/b.m).forEach(f => {
            const val = f.r / f.m;
            const freq = (harmonicSettings?.baseFreq || 440) * val;
            csv += s + ',' + f.r + ',' + f.m + ',' + val.toFixed(prec) + ',' + 
                   (val * 360).toFixed(prec) + ',' + 
                   (val * 2 * Math.PI).toFixed(prec) + ',' + 
                   (val * 2).toFixed(prec) + 'œÄ,' +
                   (f.isPrime ? 'Prime' : 'Composite') + ',' +
                   (f.isPrimeNum ? 'Prime' : 'Composite') + ',' +
                   (f.category || '-') + ',' +
                   freq.toFixed(2) + '\n';
        });
    }
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'all_sectors_N' + state.nMax + '_data.csv';
    a.click();
}

function boostPointSize() {
    const slider = document.getElementById('ringPointSize');
    if (slider) {
        let val = parseFloat(slider.value) || 0;
        if (val === 0) val = 3; // Start from 3 if on auto
        else val = Math.min(20, val + 2);
        slider.value = val;
        drawMainRing();
    }
}

function setPointSize(size) {
    const slider = document.getElementById('ringPointSize');
    if (slider) {
        slider.value = size;
        updatePtSizeDisplay();
        drawMainRing();
    }
}

function updatePtSizeDisplay() {
    const size = parseFloat(document.getElementById('ringPointSize').value);
    const display = document.getElementById('ptSizeDisplay');
    if (display) {
        display.textContent = size === 0 ? 'auto' : size.toString();
    }
}

function resizeRingCanvas() {
    const size = parseInt(document.getElementById('ringCanvasSize').value);
    const canvas = document.getElementById('mainRing');
    if (canvas) {
        canvas.width = size;
        canvas.height = size;
        drawMainRing();
    }
}

function resizeTreeCanvas() {
    const sizeStr = document.getElementById('treeCanvasSize').value;
    const [w, h] = sizeStr.split('x').map(Number);
    const canvas = document.getElementById('sectorTreeCanvas');
    if (canvas) {
        canvas.width = w;
        canvas.height = h;
        drawSectorTree();
    }
}

// Ring zoom and pan state
const ringView = {
    zoom: 1,
    panX: 0,
    panY: 0,
    isPanning: false,
    lastX: 0,
    lastY: 0
};

function zoomRing(delta) {
    ringView.zoom = Math.max(0.5, Math.min(10, ringView.zoom + delta));
    updateRingTransform();
}

function resetRingZoom() {
    ringView.zoom = 1;
    ringView.panX = 0;
    ringView.panY = 0;
    updateRingTransform();
}

function updateRingTransform() {
    const canvas = document.getElementById('mainRing');
    if (!canvas) return;
    
    canvas.style.transform = `scale(${ringView.zoom}) translate(${ringView.panX}px, ${ringView.panY}px)`;
    canvas.style.transformOrigin = 'center center';
    
    // Update zoom display
    const zoomDisplay = document.getElementById('ringZoomLevel');
    if (zoomDisplay) {
        zoomDisplay.textContent = Math.round(ringView.zoom * 100) + '%';
    }
    
    // Show pan hint when zoomed
    const panHint = document.getElementById('panHint');
    if (panHint) {
        panHint.style.display = ringView.zoom > 1 ? 'block' : 'none';
    }
    
    // Update cursor
    canvas.style.cursor = ringView.zoom > 1 ? (ringView.isPanning ? 'grabbing' : 'grab') : 'crosshair';
}

let ringZoomInitialized = false;

function initRingZoomPan() {
    if (ringZoomInitialized) return;
    ringZoomInitialized = true;
    
    const canvas = document.getElementById('mainRing');
    if (!canvas) return;
    
    // Mouse wheel zoom
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.15 : 0.15;
        ringView.zoom = Math.max(0.5, Math.min(10, ringView.zoom + delta));
        updateRingTransform();
    }, { passive: false });
    
    // Pan with mouse drag
    canvas.addEventListener('mousedown', (e) => {
        if (ringView.zoom > 1) {
            ringView.isPanning = true;
            ringView.lastX = e.clientX;
            ringView.lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
        }
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (ringView.isPanning && ringView.zoom > 1) {
            const dx = (e.clientX - ringView.lastX) / ringView.zoom;
            const dy = (e.clientY - ringView.lastY) / ringView.zoom;
            ringView.panX += dx;
            ringView.panY += dy;
            ringView.lastX = e.clientX;
            ringView.lastY = e.clientY;
            updateRingTransform();
        }
    });
    
    canvas.addEventListener('mouseup', () => {
        ringView.isPanning = false;
        canvas.style.cursor = ringView.zoom > 1 ? 'grab' : 'crosshair';
    });
    
    canvas.addEventListener('mouseleave', () => {
        ringView.isPanning = false;
    });
    
    // Touch support for mobile
    let touchStartX, touchStartY;
    canvas.addEventListener('touchstart', (e) => {
        if (ringView.zoom > 1 && e.touches.length === 1) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }
    }, { passive: true });
    
    canvas.addEventListener('touchmove', (e) => {
        if (ringView.zoom > 1 && e.touches.length === 1) {
            const dx = (e.touches[0].clientX - touchStartX) / ringView.zoom;
            const dy = (e.touches[0].clientY - touchStartY) / ringView.zoom;
            ringView.panX += dx;
            ringView.panY += dy;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            updateRingTransform();
        }
    }, { passive: true });
}

// Initialize zoom/pan on load
document.addEventListener('DOMContentLoaded', initRingZoomPan);

function zoomToSector(sectorNum) {
    // Calculate angle range for sector
    const canvas = document.getElementById('mainRing');
    if (!canvas) return;
    
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    
    // Sector n spans (1/(n+1), 1/n]
    const angleStart = (1 / (sectorNum + 1)) * 2 * Math.PI;
    const angleEnd = (1 / sectorNum) * 2 * Math.PI;
    const angleMid = (angleStart + angleEnd) / 2;
    
    // Zoom to 3x and pan to center the sector
    ringView.zoom = 3;
    
    // Calculate pan to center the sector midpoint
    // The sector midpoint in canvas coords (at max radius)
    const maxR = Math.min(W, H) / 2 - 35;
    const targetX = cx + maxR * 0.7 * Math.cos(angleMid);
    const targetY = cy - maxR * 0.7 * Math.sin(angleMid);
    
    // Pan so target is at center
    ringView.panX = (cx - targetX) / ringView.zoom;
    ringView.panY = (cy - targetY) / ringView.zoom;
    
    updateRingTransform();
}

// Track highlighted point on ring (for click selection)
let highlightedRingPoint = null;

function drawMainRing() {
    const canvas = document.getElementById('mainRing'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-35;
    const sector = +document.getElementById('viewSector').value;
    const colorMode = document.getElementById('colorMode').value;
    const showAll = document.getElementById('showAllSectors').checked;
    const invertOrder = document.getElementById('invertRingOrder')?.checked || false;
    
    // Label settings
    const labelFormat = document.getElementById('ringLabelFormat')?.value || 'none';
    const labelWhich = document.getElementById('ringLabelWhich')?.value || 'none';
    const labelSize = +(document.getElementById('ringLabelSize')?.value || 9);
    const labelBg = document.getElementById('ringLabelBg')?.checked || false;
    
    // Tracker settings
    const trackerOn = document.getElementById('enableResidueTracker')?.checked || false;
    const trackerMode = document.getElementById('trackerMode')?.value || 'manual';
    const trackStr = trackerMode === 'manual' ? (document.getElementById('trackResidues')?.value || '') : String(document.getElementById('trackerSliderR')?.value || 1);
    const trackerColor = document.getElementById('trackerColor')?.value || '#00ffff';
    const trackerSize = +(document.getElementById('trackerSize')?.value || 8);
    const trackerGlow = document.getElementById('trackerGlow')?.checked || false;
    const trackerConnect = document.getElementById('trackerConnect')?.checked || false;
    const trackerModFilterStr = document.getElementById('trackerModFilter')?.value || '';
    const trackerModFilter = trackerModFilterStr.trim() ? trackerModFilterStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n)) : null;
    const trackedResidues = parseTrackerResidues(trackStr);
    
    // Rotation settings
    const rotationOn = document.getElementById('enableRingRotation')?.checked || false;
    const rotationAmt = +(document.getElementById('ringRotationAmount')?.value || 0) * Math.PI / 180;
    const rotationCumulative = document.getElementById('rotationCumulative')?.checked || true;
    const globalPhase = +(document.getElementById('ringGlobalPhase')?.value || 0) * Math.PI / 180;
    const showRingLabels = document.getElementById('showRingLabels')?.checked || false;
    const ringSpacing = parseFloat(document.getElementById('ringSpacing')?.value || 1);
    
    // Sector analysis
    const showBounds = document.getElementById('showSectorBounds')?.checked || false;
    const showMedian = document.getElementById('showMedianLine')?.checked || false;
    const showAllLines = document.getElementById('showAllSectorLines')?.checked || false;
    const dimOutside = document.getElementById('dimOutsideSector')?.checked || false;
    const sectorColorMode = document.getElementById('sectorColorMode')?.value || 'preserve';
    const ringBgColor = document.getElementById('ringBgColor')?.value || '#0f172a';
    
    // Clear canvas with background color
    ctx.fillStyle = ringBgColor; ctx.fillRect(0,0,W,H);
    
    // Draw all 1/n sector lines if enabled
    if (showAllLines) {
        ctx.strokeStyle = 'rgba(150,100,255,0.3)'; ctx.lineWidth = 1;
        for(let n=1; n<=Math.min(20,state.sectorMax); n++) {
            const angle = (1/n)*2*Math.PI;
            ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(angle)*maxR, cy-Math.sin(angle)*maxR); ctx.stroke();
        }
    }
    
    // Draw sector bounds
    if (showBounds && !showAll) {
        const a1 = (1/(sector+1))*2*Math.PI, a2 = (1/sector)*2*Math.PI;
        ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2; ctx.setLineDash([5,5]);
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(a1)*maxR, cy-Math.sin(a1)*maxR); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(a2)*maxR, cy-Math.sin(a2)*maxR); ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Draw median line
    if (showMedian && !showAll) {
        const medAngle = ((1/(sector+1) + 1/sector)/2)*2*Math.PI;
        ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 1; ctx.setLineDash([3,3]);
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(medAngle)*maxR, cy-Math.sin(medAngle)*maxR); ctx.stroke();
        ctx.setLineDash([]);
        // Draw mediant fraction label
        const medP = 1 + 1, medQ = (sector+1) + sector;
        ctx.fillStyle = '#22c55e'; ctx.font = '10px system-ui';
        ctx.fillText(`${medP}/${medQ}`, cx+Math.cos(medAngle)*(maxR+18)-8, cy-Math.sin(medAngle)*(maxR+18));
    }
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
    for(let n=1; n<=Math.min(15,state.sectorMax); n++) {
        const angle = (1/n)*2*Math.PI;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(angle)*maxR, cy-Math.sin(angle)*maxR); ctx.stroke();
        ctx.fillStyle='#64748b'; ctx.font='9px system-ui';
        ctx.fillText(`1/${n}`, cx+Math.cos(angle)*(maxR+12)-8, cy-Math.sin(angle)*(maxR+12));
    }
    
    if(!showAll) {
        const a1=(1/(sector+1))*2*Math.PI, a2=(1/sector)*2*Math.PI;
        ctx.fillStyle='rgba(99,102,241,0.1)'; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,maxR,-a2,-a1); ctx.closePath(); ctx.fill();
    }
    
    state.ringPoints = [];
    
    // Get residues - prefer full data, fall back to bounded data
    let residues;
    const fullData = showAll ? Object.values(state.residuesBySector).flat() : (state.residuesBySector[sector]||[]);
    const boundedData = showAll ? Object.values(state.boundedResiduesBySector||{}).flat() : (state.boundedResiduesBySector?.[sector]||[]);
    
    if (fullData.length > 0) {
        residues = fullData;
    } else if (boundedData.length > 0) {
        residues = boundedData;
        // Note: bounded data only goes up to boundedN, not full N
    } else {
        residues = [];
    }
    
    // Adaptive point size calculation
    // Goal: Points visible but not overlapping excessively
    const numPoints = residues.length;
    const rangeSpan = state.nMax - state.nMin + 1;
    
    // Calculate adaptive size based on point density
    // Key insight: even with many points, they need to be visible
    let adaptiveSize;
    if (numPoints === 0) {
        adaptiveSize = 3;
    } else if (numPoints < 100) {
        adaptiveSize = Math.max(4, 400 / numPoints);
    } else if (numPoints < 1000) {
        adaptiveSize = Math.max(2.5, 80 / Math.sqrt(numPoints));
    } else if (numPoints < 10000) {
        adaptiveSize = Math.max(1.8, 60 / Math.sqrt(numPoints));
    } else if (numPoints < 100000) {
        adaptiveSize = Math.max(1.2, 40 / Math.sqrt(numPoints));
    } else {
        adaptiveSize = Math.max(0.8, 25 / Math.sqrt(numPoints));
    }
    
    // Range factor - but don't reduce below 60%
    const rangeFactor = Math.min(1, 800 / rangeSpan);
    adaptiveSize *= Math.max(0.6, rangeFactor);
    
    // Final clamp - minimum 1px so always visible
    adaptiveSize = Math.max(1, Math.min(10, adaptiveSize));
    
    // Slider: 0 = auto (use adaptive), >0 = direct override
    const sliderVal = +(document.getElementById('ringPointSize')?.value || 5);
    const finalPointSize = sliderVal > 0 ? sliderVal : adaptiveSize;
    
    // Update display
    const ptDisplay = document.getElementById('ptSizeDisplay');
    if (ptDisplay) {
        if (sliderVal > 0) {
            ptDisplay.textContent = sliderVal < 0.01 ? sliderVal.toFixed(4) : sliderVal < 1 ? sliderVal.toFixed(2) : sliderVal.toFixed(1);
        } else {
            ptDisplay.textContent = `auto(${adaptiveSize.toFixed(1)})`;
        }
    }
    
    // Get filter settings
    const pointFilterVal = document.getElementById('pointFilter')?.value || 'all';
    const minDenom = parseInt(document.getElementById('minDenomFilter')?.value) || 2;
    const maxDenom = parseInt(document.getElementById('maxDenomFilter')?.value) || Infinity;
    const hideSmall = document.getElementById('hideSmallDenom')?.checked || false;
    const showFractionLabels = document.getElementById('showFractionLabels')?.checked || false;
    const highlightPrimeRings = document.getElementById('highlightPrimeRings')?.checked || false;
    
    let maxGap=0, minGap=Infinity;
    residues.forEach(r => { const g=r.gapRight||0; if(g>maxGap)maxGap=g; if(g>0&&g<minGap)minGap=g; });
    
    const maxM = residues.reduce((max, r) => r.m > max ? r.m : max, 1);
    const trackerPoints = [];
    let debugDrawnCount = 0;
    let debugNaNCount = 0;
    
    // Draw prime ring highlights if enabled
    if (highlightPrimeRings) {
        const primeMs = [...new Set(residues.filter(r => r.isPrime).map(r => r.m))].sort((a,b) => a-b);
        ctx.strokeStyle = 'rgba(245,158,11,0.3)';
        ctx.lineWidth = 2;
        primeMs.forEach(pm => {
            let radNorm = invertOrder ? (1 - (pm-state.nMin)/(state.nMax-state.nMin+1)) : ((pm-state.nMin)/(state.nMax-state.nMin+1));
            if (ringSpacing !== 1) radNorm = Math.pow(radNorm, 1/ringSpacing);
            const rad = Math.max(radNorm, 0.05) * maxR;
            ctx.beginPath();
            ctx.arc(cx, cy, rad, 0, 2 * Math.PI);
            ctx.stroke();
        });
    }
    
    // Draw points
    const labeledPoints = [];
    residues.forEach(res => {
        const {r,m,sector:s,isPrime:ip} = res;
        
        // Apply filters
        if (hideSmall && m <= 5) return;
        if (m < minDenom || m > maxDenom) return;
        if (pointFilterVal === 'prime_denom' && !ip) return;
        if (pointFilterVal === 'composite_denom' && ip) return;
        if (pointFilterVal === 'prime_num' && !isPrime(r)) return;
        if (pointFilterVal === 'twin_prime' && !(ip && (isPrime(m-2) || isPrime(m+2)))) return;
        
        let angle = (r/m)*2*Math.PI;
        
        // Apply rotation (cumulative per ring + global phase)
        if (rotationOn) {
            const ringIdx = m;
            const ringRotation = rotationCumulative ? rotationAmt * ringIdx : rotationAmt;
            angle += ringRotation + globalPhase;
        }
        
        let radNorm = invertOrder ? (1 - (m-state.nMin)/(state.nMax-state.nMin+1)) : ((m-state.nMin)/(state.nMax-state.nMin+1));
        // Apply ring spacing - power function spreads outer rings more
        if (ringSpacing !== 1) {
            radNorm = Math.pow(radNorm, 1/ringSpacing);
        }
        const rad = Math.max(radNorm, 0.05) * maxR;
        const x = cx+rad*Math.cos(angle), y = cy-rad*Math.sin(angle);
        
        // Check for NaN/Infinity
        if(!isFinite(x) || !isFinite(y) || !isFinite(rad)) {
            debugNaNCount++;
            return;
        }
        debugDrawnCount++;
        
        let color = getRingPointColor(colorMode, res, s, ip, m, r, maxGap, minGap);
        let size = finalPointSize;
        if (colorMode === 'prime' && ip) size = finalPointSize * 1.25;
        
        // Apply sector color mode
        const inSector = s === sector;
        if (!showAll && sectorColorMode !== 'preserve') {
            if (sectorColorMode === 'gold' && inSector) color = '#ffd700';
            else if (sectorColorMode === 'inout') color = inSector ? '#ffd700' : '#4b5563';
            else if (sectorColorMode === 'enhance' && inSector) {
                // Brighten color
                const rgb = color.match(/\d+/g);
                if (rgb) color = `rgb(${Math.min(255,+rgb[0]*1.3)},${Math.min(255,+rgb[1]*1.3)},${Math.min(255,+rgb[2]*1.3)})`;
            }
        }
        
        // Dim outside sector (or highlight specific sector when showAll)
        let alpha = 1;
        if ((dimOutside || sectorColorMode === 'dim') && !showAll && !inSector) alpha = 0.2;
        // When showAll is true but we have a highlighted sector, dim others
        if (showAll && state.highlightSectorOnly !== null && s !== state.highlightSectorOnly) alpha = 0.5;
        
        // Ring loop highlight - brighten current ring, dim others
        if (typeof highlightedRingM !== 'undefined' && highlightedRingM !== null) {
            if (m === highlightedRingM) {
                alpha = 1;
                size = finalPointSize * 2; // Make highlighted ring points bigger
            } else {
                alpha = 0.3;
            }
        }
        
        ctx.globalAlpha = alpha;
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,size,0,2*Math.PI); ctx.fill();
        ctx.globalAlpha = 1;
        
        state.ringPoints.push({x,y,r,m,sector:s,isPrime:ip,gap:res.gapRight,color,angle,rad});
        
        // Track residue (with mod filter support)
        if (trackerOn && trackedResidues.includes(r)) {
            if (!trackerModFilter || trackerModFilter.includes(m)) {
                trackerPoints.push({x,y,r,m,angle,rad});
            }
        }
    });
    
    // Draw tracker connections
    if (trackerOn && trackerConnect && trackerPoints.length > 1) {
        ctx.strokeStyle = trackerColor; ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
        ctx.beginPath();
        trackerPoints.forEach((p,i) => i === 0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
        ctx.stroke(); ctx.globalAlpha = 1;
    }
    
    // Draw tracker highlights
    if (trackerOn && trackerPoints.length > 0) {
        trackerPoints.forEach(p => {
            if (trackerGlow) { ctx.shadowColor = trackerColor; ctx.shadowBlur = 12; }
            ctx.fillStyle = trackerColor;
            ctx.beginPath(); ctx.arc(p.x,p.y,trackerSize,0,2*Math.PI); ctx.fill();
            ctx.shadowBlur = 0;
        });
    }
    
    // Draw highlighted point (from click) - white circle
    if (highlightedRingPoint) {
        const hp = state.ringPoints.find(p => p.r === highlightedRingPoint.r && p.m === highlightedRingPoint.m);
        if (hp) {
            const highlightSize = Math.max(finalPointSize * 2, 6);
            // White circle outline
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(hp.x, hp.y, highlightSize + 5, 0, 2 * Math.PI);
            ctx.stroke();
        }
    }
    
    // Update tracker info panel
    updateTrackerInfo(trackerPoints, trackerOn);
    
    // Draw labels
    if (labelFormat !== 'none' && labelWhich !== 'none') {
        ctx.font = `${labelSize}px system-ui`; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
        state.ringPoints.forEach((p, idx) => {
            const res = residues[idx];
            if (!shouldLabelPoint(res, labelWhich, sector, maxM)) return;
            const txt = getRingLabelText(res, labelFormat);
            if (!txt) return;
            if (labelBg) {
                const w = ctx.measureText(txt).width;
                ctx.fillStyle = 'rgba(15,23,42,0.85)';
                ctx.fillRect(p.x - w/2 - 2, p.y - finalPointSize - labelSize - 2, w + 4, labelSize + 2);
            }
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText(txt, p.x, p.y - finalPointSize - 2);
        });
    }
    
    // Simple fraction labels for all points when enabled (limited to avoid clutter)
    if (showFractionLabels && state.ringPoints.length <= 500) {
        ctx.font = '8px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        state.ringPoints.forEach(p => {
            ctx.fillStyle = 'rgba(226, 232, 240, 0.8)';
            ctx.fillText(`${p.r}/${p.m}`, p.x, p.y - finalPointSize - 1);
        });
    }
    
    // Draw ring labels (modulus values at ring positions)
    if (showRingLabels && rotationOn) {
        ctx.fillStyle = '#ffd700';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'left';
        const labeledRings = new Set();
        residues.forEach(res => {
            if (labeledRings.has(res.m)) return;
            labeledRings.add(res.m);
            let radNorm = invertOrder ? (1 - (res.m-state.nMin)/(state.nMax-state.nMin+1)) : ((res.m-state.nMin)/(state.nMax-state.nMin+1));
            if (ringSpacing !== 1) radNorm = Math.pow(radNorm, 1/ringSpacing);
            const rad = Math.max(radNorm, 0.05) * maxR;
            const ringRotation = rotationCumulative ? rotationAmt * res.m : rotationAmt;
            const labelAngle = -Math.PI/2 + ringRotation + globalPhase;
            const lx = cx + rad * Math.cos(labelAngle);
            const ly = cy + rad * Math.sin(labelAngle);
            ctx.fillText(`m=${res.m}`, lx + 3, ly + 3);
        });
    }
    
    ctx.fillStyle='#e2e8f0'; ctx.beginPath(); ctx.arc(cx,cy,4,0,2*Math.PI); ctx.fill();
    
    // Draw highlighted ring circle during loop playback
    if (typeof highlightedRingM !== 'undefined' && highlightedRingM !== null) {
        const invertOrder = document.getElementById('invertRingOrder')?.checked || false;
        let radNorm = invertOrder ? (1 - (highlightedRingM-state.nMin)/(state.nMax-state.nMin+1)) : ((highlightedRingM-state.nMin)/(state.nMax-state.nMin+1));
        if (ringSpacing !== 1) radNorm = Math.pow(radNorm, 1/ringSpacing);
        const ringRad = Math.max(radNorm, 0.05) * maxR;
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(cx, cy, ringRad, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        // Label the ring
        ctx.fillStyle = '#fbbf24';
        ctx.font = 'bold 14px monospace';
        ctx.fillText(`Ring m=${highlightedRingM}`, cx + ringRad + 10, cy);
    }
    
    // Debug info on canvas - show point size and data source
    const usingBounded = fullData.length === 0 && boundedData.length > 0;
    ctx.fillStyle = usingBounded ? '#f59e0b' : '#94a3b8'; 
    ctx.font = '11px monospace';
    const dataLabel = usingBounded ? `Bounded N‚â§${state.boundedN}` : `N: ${state.nMin}-${state.nMax}`;
    ctx.fillText(`${dataLabel} | Points: ${debugDrawnCount} | Size: ${finalPointSize.toFixed(1)}px${usingBounded ? ' (Formula mode - limited data)' : ''}`, 10, H - 10);
    
    // Draw word art on top
    drawWordArt(ctx);
    
    updateColorLegend(colorMode, showAll, sector);
    updateSectorStats(sector, residues);
}

function updateTrackerInfo(trackerPoints, enabled) {
    const panel = document.getElementById('trackerInfoPanel');
    const data = document.getElementById('trackerInfoData');
    if (!panel || !data) return;
    panel.style.display = enabled && trackerPoints.length > 0 ? 'block' : 'none';
    if (trackerPoints.length === 0) return;
    
    let html = `<div style="color:#94a3b8;">Tracking ${trackerPoints.length} points:</div>`;
    trackerPoints.slice(0, 10).forEach(p => {
        html += `<span style="color:#00ffff;margin-right:6px;">${p.r}/${p.m}</span>`;
    });
    if (trackerPoints.length > 10) html += `<span style="color:#64748b;">... +${trackerPoints.length - 10} more</span>`;
    data.innerHTML = html;
}

function updateSectorStats(sector, residues) {
    const sectorRes = residues.filter(r => r.sector === sector);
    const coprime = sectorRes.length;
    const N = state.nMax;
    const predicted = (3 * N * N) / (Math.PI * Math.PI * sector * (sector + 1));
    const error = coprime > 0 ? ((coprime - predicted) / predicted * 100).toFixed(1) : '‚Äî';
    
    const statC = document.getElementById('statCoprime');
    const statP = document.getElementById('statPredicted');
    const statE = document.getElementById('statError');
    if (statC) statC.textContent = coprime;
    if (statP) statP.textContent = predicted.toFixed(1);
    if (statE) statE.textContent = error + '%';
}

function parseTrackerResidues(str) {
    if (!str.trim()) return [];
    const res = [];
    str.split(',').forEach(p => {
        p = p.trim();
        if (p.includes('-')) {
            const [a,b] = p.split('-').map(Number);
            for (let i = a; i <= b; i++) res.push(i);
        } else if (p) res.push(parseInt(p));
    });
    return res.filter(r => !isNaN(r));
}

function shouldLabelPoint(res, which, curSector, maxM) {
    switch(which) {
        case 'all': return true;
        case 'outer': return res.m === maxM;
        case 'primes': return res.isPrime;
        case 'sector': return res.sector === curSector;
        case 'simple': return res.m <= 12;
        default: return false;
    }
}

function getRingLabelText(res, fmt) {
    const {r,m,sector,isPrime} = res;
    switch(fmt) {
        case 'fraction': return `${r}/${m}`;
        case 'decimal': return (r/m).toFixed(3);
        case 'angle': return ((r/m)*360).toFixed(1) + '¬∞';
        case 'residue': return String(r);
        case 'sector': return `S${sector}`;
        case 'gcd': return `g${gcd(r,m)}`;
        case 'order': return `o${getMultOrder(r,m)}`;
        case 'totient': return `œÜ${eulerPhi(m)}`;
        case 'cfPath': const cf = toCF(r,m); return cf.length <= 3 ? `[${cf.join(',')}]` : `[${cf.slice(0,2).join(',')}...]`;
        case 'cents': return Math.round(1200*Math.log2(r/m)) + '¬¢';
        default: return '';
    }
}

function getMultOrder(a, n) {
    if (gcd(a, n) !== 1) return 0;
    let order = 1, cur = a % n;
    while (cur !== 1 && order <= n) { cur = (cur * a) % n; order++; }
    return order;
}

function setTrackerPreset(preset) {
    const input = document.getElementById('trackResidues');
    switch(preset) {
        case 'phi12': input.value = '1,5,7,11'; break;
        case 'phi30': input.value = '1,7,11,13,17,19,23,29'; break;
        case 'phi60': input.value = '1,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59'; break;
        case 'primes': input.value = '2,3,5,7,11,13'; break;
        case 'twins': input.value = '1,11,13,17,19,29'; break;
    }
    document.getElementById('enableResidueTracker').checked = true;
    toggleRingSection('secTracker', true);
    drawMainRing();
}

function showSectorStats() {
    const sector = +document.getElementById('viewSector').value;
    const res = state.residuesBySector[sector] || [];
    const primeCount = res.filter(r => r.isPrime).length;
    const N = state.nMax;
    const pred = (3*N*N)/(Math.PI*Math.PI*sector*(sector+1));
    const err = ((res.length-pred)/pred*100).toFixed(2);
    const density = (res.length / (N*N) * 100).toFixed(4);
    const zetaDensity = (6/(Math.PI*Math.PI)*100).toFixed(4);
    
    // Update stats panel
    document.getElementById('statCoprime').textContent = res.length;
    document.getElementById('statPredicted').textContent = pred.toFixed(1);
    document.getElementById('statError').textContent = err + '%';
    document.getElementById('statError').style.color = Math.abs(parseFloat(err)) < 5 ? '#00ff88' : '#ff6496';
    
    alert(`Sector ${sector} Full Statistics
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Range: (1/${sector+1}, 1/${sector}]
Angular: ${(360/(sector+1)).toFixed(1)}¬∞ ‚Äì ${(360/sector).toFixed(1)}¬∞

Counts:
  Total Coprimes: ${res.length}
  Prime m: ${primeCount} (${(primeCount/res.length*100).toFixed(1)}%)
  Composite m: ${res.length - primeCount}

Formula Analysis:
  Predicted: ${pred.toFixed(2)}
  Absolute Error: ${(res.length - pred).toFixed(2)}
  Relative Error: ${err}%
  
Density:
  Observed: ${density}%
  1/Œ∂(2): ${zetaDensity}%`);
}

function compareSectors() {
    const maxSector = Math.min(10, state.sectorMax);
    let report = `Sector Comparison (N=${state.nMax})\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    report += 'Sect ‚îÇ Count ‚îÇ Pred  ‚îÇ Error%\n';
    report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
    
    for (let s = 1; s <= maxSector; s++) {
        const res = state.residuesBySector[s] || [];
        const count = res.length;
        const pred = (3 * state.nMax * state.nMax) / (Math.PI * Math.PI * s * (s + 1));
        const errPct = ((count - pred) / pred * 100).toFixed(1);
        report += `  ${s}  ‚îÇ ${count.toString().padStart(5)} ‚îÇ ${pred.toFixed(0).padStart(5)} ‚îÇ ${errPct.padStart(5)}%\n`;
    }
    alert(report);
}

function resetRingAnimation() {
    stopRingAnimation();
    stopSectorSweep();
    document.getElementById('nMax').value = 50;
    document.getElementById('sectorMin').value = 1;
    document.getElementById('sectorMax').value = 10;
    document.getElementById('viewSector').value = 2;
    document.getElementById('ringAnimStatus').textContent = 'Reset to defaults';
    computeFareySectors();
}

// Collapsible section toggle
function toggleRingSection(sectionId, forceOpen) {
    const section = document.getElementById(sectionId);
    const icon = document.getElementById(sectionId + 'Icon');
    if (!section) return;
    
    const isHidden = section.style.display === 'none';
    const shouldOpen = forceOpen !== undefined ? forceOpen : isHidden;
    
    section.style.display = shouldOpen ? 'block' : 'none';
    if (icon) icon.textContent = shouldOpen ? '‚àí' : '+';
}

function toggleAdvancedControls() {
    const panel = document.getElementById('advancedControlsPanel');
    if (panel) {
        const isHidden = panel.style.display === 'none';
        panel.style.display = isHidden ? 'block' : 'none';
    }
}

function expandAllRingSections() {
    ['secRotation', 'secFarey', 'secTracker', 'secLabels'].forEach(id => toggleRingSection(id, true));
}

function collapseAllRingSections() {
    ['secRotation', 'secFarey', 'secTracker', 'secLabels'].forEach(id => toggleRingSection(id, false));
}

// Rotation controls
function updateRotationDisplay() {
    const val = document.getElementById('ringRotationAmount').value;
    document.getElementById('rotationAmountV').textContent = val + '¬∞';
}

// Update rotation from slider - syncs a/b display
function updateRotationFromSlider() {
    const degrees = parseFloat(document.getElementById('ringRotationAmount').value);
    document.getElementById('rotationAmountV').textContent = degrees.toFixed(1) + '¬∞';
    
    // Convert degrees to fraction of 360
    const frac = degrees / 360;
    const approxFrac = approximateFraction(frac, 100);
    document.getElementById('ringRotationFrac').value = approxFrac.a + '/' + approxFrac.b;
    
    drawMainRing();
}

// Update rotation from a/b input
function updateRotationFromFrac() {
    const fracStr = document.getElementById('ringRotationFrac').value.trim();
    const match = fracStr.match(/^(-?\d+(?:\.\d+)?)\s*\/\s*(\d+(?:\.\d+)?)$/);
    
    if (match) {
        const a = parseFloat(match[1]);
        const b = parseFloat(match[2]);
        if (b !== 0) {
            const degrees = (a / b) * 360;
            const clampedDegrees = ((degrees % 360) + 360) % 360;
            document.getElementById('ringRotationAmount').value = clampedDegrees;
            document.getElementById('rotationAmountV').textContent = clampedDegrees.toFixed(1) + '¬∞';
            document.getElementById('enableRingRotation').checked = true;
            drawMainRing();
        }
    }
}

// Approximate a decimal as a/b fraction
function approximateFraction(x, maxDenom) {
    if (x === 0) return { a: 0, b: 1 };
    
    let bestA = 0, bestB = 1, bestErr = Math.abs(x);
    
    for (let b = 1; b <= maxDenom; b++) {
        const a = Math.round(x * b);
        const err = Math.abs(x - a / b);
        if (err < bestErr) {
            bestErr = err;
            bestA = a;
            bestB = b;
        }
        if (err < 1e-10) break;
    }
    
    // Reduce fraction
    const g = gcd(Math.abs(bestA), bestB);
    return { a: bestA / g, b: bestB / g };
}

// Set rotation preset with fraction label
function setRotationPreset(degrees, fracLabel) {
    document.getElementById('ringRotationAmount').value = degrees;
    document.getElementById('rotationAmountV').textContent = degrees.toFixed(1) + '¬∞';
    document.getElementById('ringRotationFrac').value = fracLabel || approximateFraction(degrees/360, 100).a + '/' + approximateFraction(degrees/360, 100).b;
    document.getElementById('enableRingRotation').checked = true;
    toggleRingSection('secRotation', true);
    drawMainRing();
}

function updatePhaseDisplay() {
    const val = document.getElementById('ringGlobalPhase').value;
    document.getElementById('globalPhaseV').textContent = val + '¬∞';
}

// Advanced controls helper functions
function applyTrackerFilter() {
    const filter = document.getElementById('trackerModFilter').value;
    if (!filter) {
        document.getElementById('trackResidues').value = '';
        drawMainRing();
        return;
    }
    
    // Generate residues based on filter
    const maxM = state.nMax || 100;
    let residues = [];
    
    if (filter === 'prime') {
        for (let m = 2; m <= Math.min(maxM, 500); m++) {
            if (isPrime(m)) residues.push(m);
        }
    } else if (filter === 'composite') {
        for (let m = 4; m <= Math.min(maxM, 500); m++) {
            if (!isPrime(m)) residues.push(m);
        }
    } else if (filter.startsWith('mod')) {
        const [, mod, rem] = filter.match(/mod(\d+)_(\d+)/);
        for (let m = 2; m <= Math.min(maxM, 500); m++) {
            if (m % parseInt(mod) === parseInt(rem)) residues.push(m);
        }
    }
    
    document.getElementById('trackResidues').value = residues.slice(0, 50).join(',');
    document.getElementById('enableResidueTracker').checked = true;
    drawMainRing();
}

function clearTracker() {
    document.getElementById('enableResidueTracker').checked = false;
    document.getElementById('trackResidues').value = '';
    document.getElementById('trackerModFilter').value = '';
    drawMainRing();
}

function resetFilters() {
    document.getElementById('pointFilter').value = 'all';
    document.getElementById('minDenomFilter').value = '2';
    document.getElementById('maxDenomFilter').value = '';
    document.getElementById('hideSmallDenom').checked = false;
    drawMainRing();
}

let ringAnimationId = null;
let ringAnimFrame = 0;

function startRingAnimation() {
    if (ringAnimationId) return;
    
    const mode = document.getElementById('ringAnimMode').value;
    const speed = parseInt(document.getElementById('ringAnimSpeed').value);
    const loop = document.getElementById('ringAnimLoop').checked;
    
    document.getElementById('ringAnimBtn').textContent = '‚è∏ Pause';
    
    function animate() {
        ringAnimFrame++;
        
        if (mode === 'rotation') {
            const phase = (ringAnimFrame * speed / 10) % 360;
            document.getElementById('ringGlobalPhase').value = phase;
            document.getElementById('enableRingRotation').checked = true;
        } else if (mode === 'growth') {
            // Animate N range growth
            const maxN = state.nMax;
            const currentN = Math.min(2 + Math.floor(ringAnimFrame * speed / 50), maxN);
            // This would need deeper integration
        } else if (mode === 'pulse') {
            const scale = 1 + 0.3 * Math.sin(ringAnimFrame * speed / 100);
            ringView.zoom = scale;
            updateRingTransform();
        } else if (mode === 'wave') {
            const phase = ringAnimFrame * speed / 20;
            document.getElementById('ringRotationAmount').value = 30 * Math.sin(phase);
            updateRotationDisplay();
            document.getElementById('enableRingRotation').checked = true;
        }
        
        drawMainRing();
        
        if (loop || ringAnimFrame < 360) {
            ringAnimationId = requestAnimationFrame(animate);
        } else {
            stopRingAnimation();
        }
    }
    
    animate();
}

function stopRingAnimation() {
    if (ringAnimationId) {
        cancelAnimationFrame(ringAnimationId);
        ringAnimationId = null;
    }
    ringAnimFrame = 0;
    document.getElementById('ringAnimBtn').textContent = '‚ñ∂ Animate';
}

function applyRotationFraction() {
    const frac = document.getElementById('ringRotationFrac').value.trim();
    if (!frac) return;
    
    let degrees = 0;
    if (frac.includes('/')) {
        const [num, den] = frac.split('/').map(Number);
        if (den && !isNaN(num) && !isNaN(den)) {
            degrees = (num / den) * 360;
        }
    } else {
        degrees = parseFloat(frac);
    }
    
    if (!isNaN(degrees)) {
        document.getElementById('ringRotationAmount').value = degrees % 360;
        updateRotationDisplay();
        document.getElementById('enableRingRotation').checked = true;
        drawMainRing();
    }
}

// Sector quick select
function setQuickSector(s) {
    document.getElementById('viewSector').value = s;
    drawMainRing();
    updateFormulaDisplay();
    updateSectorAnalysis();
}

function updateSectorAnalysis() {
    const sector = +document.getElementById('viewSector').value;
    const res = state.residuesBySector[sector] || [];
    const N = state.nMax;
    const pred = (3*N*N)/(Math.PI*Math.PI*sector*(sector+1));
    const err = res.length > 0 ? ((res.length-pred)/pred*100).toFixed(1) : '‚Äî';
    
    document.getElementById('statCoprime').textContent = res.length;
    document.getElementById('statPredicted').textContent = pred.toFixed(1);
    document.getElementById('statError').textContent = err + '%';
}

// Tracker mode
function updateTrackerMode() {
    const mode = document.getElementById('trackerMode').value;
    document.getElementById('trackerManualControls').style.display = mode === 'manual' ? 'block' : 'none';
    document.getElementById('trackerSliderControls').style.display = mode === 'slider' ? 'block' : 'none';
    drawMainRing();
}

function updateTrackerSlider() {
    const val = document.getElementById('trackerSliderR').value;
    document.getElementById('trackerSliderV').textContent = val;
}

function updateTrackerSizeDisplay() {
    const val = document.getElementById('trackerSize').value;
    const disp = document.getElementById('trackerSizeV');
    if (disp) disp.textContent = val;
}

function getRingPointColor(colorMode, res, s, ip, m, r, maxGap, minGap) {
    const cf = toCF(r, m);
    const sbDepth = cf.length;
    const phi = eulerPhi(m);
    
    switch(colorMode) {
        case 'sector': return getSectorColor(s);
        case 'prime': return ip ? '#f59e0b' : '#6366f1';
        case 'denominator': return `hsl(${260-((m-state.nMin)/(state.nMax-state.nMin+1))*200},70%,60%)`;
        case 'numerator': return `hsl(${(r/m)*360},70%,55%)`;
        case 'gap': 
            const g = res.gapRight || minGap;
            const gn = maxGap > minGap ? (g-minGap)/(maxGap-minGap) : 0.5;
            return `hsl(${120-gn*120},80%,50%)`;
        
        // Harmonic color modes
        case 'harmonic':
            if (m === 1) return '#22c55e'; // Unison
            if (m <= 4) return '#3b82f6';  // Consonant
            if (m <= 8) return '#f59e0b';  // Complex
            if (m <= 16) return '#ef4444'; // Dissonant
            return '#94a3b8';
        case 'primeLimit':
            const primes = [2,3,5,7,11,13];
            let limit = 1;
            let temp = m;
            for (const p of primes) { while(temp % p === 0) { limit = Math.max(limit, p); temp /= p; } }
            if (temp > 1) limit = temp;
            if (limit <= 2) return '#22c55e';
            if (limit <= 3) return '#3b82f6';
            if (limit <= 5) return '#8b5cf6';
            if (limit <= 7) return '#f59e0b';
            if (limit <= 11) return '#ef4444';
            return '#64748b';
        case 'tenney':
            const tenney = Math.log2(r) + Math.log2(m);
            const tenneyNorm = Math.min(tenney / 12, 1);
            return `hsl(${120 - tenneyNorm * 120}, 70%, 55%)`;
        case 'consonance':
            const cons = 1 / (r * m);
            if (cons >= 0.1) return '#22c55e';
            if (cons >= 0.02) return '#3b82f6';
            if (cons >= 0.005) return '#f59e0b';
            return '#ef4444';
        
        // Number theory modes
        case 'gcd':
            const gcdVal = gcd(r, m);
            return gcdVal === 1 ? '#ffd700' : `hsl(${(gcdVal % 10) * 36}, 60%, 50%)`;
        case 'quadRes':
            const isQR = isQuadraticResidue(r, m);
            return isQR ? '#22c55e' : '#6366f1';
        case 'sbDepth':
            return `hsl(${260 - (sbDepth / 15) * 200}, 70%, 55%)`;
        case 'totient':
            const phiRatio = phi / m;
            return `hsl(${phiRatio * 120}, 70%, 55%)`;
        
        // Gradients
        case 'rainbow':
            return `hsl(${(r/m)*360}, 80%, 55%)`;
        case 'fire':
            const fireT = (m - state.nMin) / (state.nMax - state.nMin + 1);
            return fireT < 0.33 ? `rgb(${Math.floor(255*fireT*3)},0,0)` :
                   fireT < 0.66 ? `rgb(255,${Math.floor(255*(fireT-0.33)*3)},0)` :
                   `rgb(255,255,${Math.floor(255*(fireT-0.66)*3)})`;
        case 'plasma':
            const pt = (r/m + (m - state.nMin)/(state.nMax - state.nMin + 1)) / 2;
            return `hsl(${280 - pt * 200}, 100%, ${40 + pt * 30}%)`;
        case 'viridis':
            const vt = (m - state.nMin) / (state.nMax - state.nMin + 1);
            return `hsl(${260 - vt * 200}, ${50 + vt * 30}%, ${30 + vt * 40}%)`;
        case 'ocean':
            const ot = (r/m);
            return `hsl(${200 + ot * 60}, 70%, ${30 + ot * 40}%)`;
        
        default: return '#6366f1';
    }
}

function isQuadraticResidue(a, n) {
    if (n <= 1) return true;
    a = a % n;
    for (let x = 0; x < n; x++) {
        if ((x * x) % n === a) return true;
    }
    return false;
}

function eulerPhi(n) {
    let result = n;
    for (let p = 2; p * p <= n; p++) {
        if (n % p === 0) {
            while (n % p === 0) n /= p;
            result -= result / p;
        }
    }
    if (n > 1) result -= result / n;
    return Math.floor(result);
}

function resizeRingCanvas() {
    const size = +(document.getElementById('ringCanvasSize')?.value || 600);
    const canvas = document.getElementById('mainRing');
    canvas.width = size;
    canvas.height = size;
    canvas.style.maxWidth = '100%';
    drawMainRing();
}

function exportRingHiRes() {
    const canvas = document.getElementById('mainRing');
    const link = document.createElement('a');
    link.download = `farey_sector_ring_${canvas.width}x${canvas.height}_${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

function updateColorLegend(colorMode, showAll, sector) {
    const legend = document.getElementById('colorLegend');
    let html = '';
    switch(colorMode) {
        case 'sector': 
            if(showAll) { for(let s=1;s<=Math.min(10,state.sectorMax);s++) html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(s)}"></div>S${s}</div>`; } 
            else html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(sector)}"></div>Sector ${sector}</div>`; 
            break;
        case 'prime': 
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Composite</div>`; 
            break;
        case 'denominator': 
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(260,70%,60%)"></div>Small m</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(60,70%,60%)"></div>Large m</div>`; 
            break;
        case 'numerator':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,70%,55%)"></div>r‚âà0</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(180,70%,55%)"></div>r/m‚âà0.5</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(360,70%,55%)"></div>r‚âàm</div>`;
            break;
        case 'gap': 
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(120,80%,50%)"></div>Small</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,80%,50%)"></div>Large</div>`; 
            break;
        case 'harmonic':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Unison</div><div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>Consonant</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Complex</div><div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>Dissonant</div>`;
            break;
        case 'primeLimit':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>2-lim</div><div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>3-lim</div><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>5-lim</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>7-lim</div><div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>11+</div>`;
            break;
        case 'tenney':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(120,70%,55%)"></div>Simple</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,70%,55%)"></div>Complex</div>`;
            break;
        case 'consonance':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Perfect</div><div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>Imperfect</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Mixed</div><div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>Dissonant</div>`;
            break;
        case 'gcd':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#ffd700"></div>GCD=1</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(180,60%,50%)"></div>GCD>1</div>`;
            break;
        case 'quadRes':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Quad Res</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Non-QR</div>`;
            break;
        case 'sbDepth':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(260,70%,55%)"></div>Shallow</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(60,70%,55%)"></div>Deep</div>`;
            break;
        case 'totient':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,70%,55%)"></div>œÜ/m low</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(120,70%,55%)"></div>œÜ/m high</div>`;
            break;
        case 'rainbow':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:linear-gradient(90deg,red,yellow,green,cyan,blue,magenta)"></div>r/m‚Üíhue</div>`;
            break;
        case 'fire':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:linear-gradient(90deg,#300,red,orange,yellow,white)"></div>m‚Üíheat</div>`;
            break;
        case 'plasma':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:linear-gradient(90deg,#0d0887,#7e03a8,#cc4778,#f89540,#f0f921)"></div>Plasma</div>`;
            break;
        case 'viridis':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:linear-gradient(90deg,#440154,#31688e,#35b779,#fde725)"></div>Viridis</div>`;
            break;
        case 'ocean':
            html+=`<div class="color-legend-item"><div class="color-swatch" style="background:linear-gradient(90deg,#001133,#003366,#0066aa,#33aacc)"></div>Ocean</div>`;
            break;
    }
    legend.innerHTML = html;
}

document.getElementById('mainRing').addEventListener('click', function(e) {
    const canvas = this;
    const rect = canvas.getBoundingClientRect();
    // Account for canvas scaling (canvas size vs display size)
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    // Hide tooltip on click
    document.getElementById('pointTooltip').classList.remove('visible');
    
    let closest = null, minDist = 20 * Math.max(scaleX, scaleY); // Scale hit detection too
    state.ringPoints.forEach(p => { 
        const d = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2); 
        if (d < minDist) { minDist = d; closest = p; } 
    });
    
    if (closest) {
        // Shift-click adds to word art
        if (e.shiftKey && document.getElementById('wordArtEnabled')?.checked) {
            addPointToWordArt(closest);
            return;
        }
        
        // Just highlight the point, don't change sector view
        highlightedRingPoint = closest;
        drawMainRing(); // Redraw to show highlight
        
        // Show info modal
        openPointModal(closest);
        
        // Update tree path
        selectPointForTree(closest);
        
        // Trigger global harmonic system (handles display + optional audio)
        triggerGlobalHarmonic(closest.r, closest.m);
        
        // Update solver display with clicked point
        updateSolverLive(closest.r, closest.m);
    } else {
        // Clicked empty space - clear highlight
        if (highlightedRingPoint) {
            highlightedRingPoint = null;
            drawMainRing();
        }
    }
});

// Disable hover tooltip - only show on click
document.getElementById('mainRing').addEventListener('mousemove', function(e) {
    // Tooltip disabled - info shown via click modal only
});

function openPointModal(p) {
    document.getElementById('pointModalTitle').textContent = `${p.r}/${p.m}`;
    const cf = toCF(p.r, p.m);
    document.getElementById('pointModalBody').innerHTML = `
        <div class="detail-grid">
            <div class="detail-card"><h5>Fraction</h5><div class="value">${p.r}/${p.m}</div><div class="sub">= ${(p.r/p.m).toFixed(8)}</div></div>
            <div class="detail-card"><h5>Sector</h5><div class="value">${p.sector}</div><div class="sub">(1/${p.sector+1}, 1/${p.sector}]</div></div>
            <div class="detail-card"><h5>Modulus</h5><div class="value" style="color:${p.isPrime?'#f59e0b':'#6366f1'}">${p.m}</div><div class="sub">${p.isPrime?'Prime':'Composite'}</div></div>
            <div class="detail-card"><h5>Category</h5><div class="value" style="color:${p.category==='PP'?'#22c55e':p.category==='PC'?'#f59e0b':p.category==='CP'?'#6366f1':'#94a3b8'}">${p.category || 'N/A'}</div><div class="sub">${p.category==='PP'?'Both Prime':p.category==='PC'?'Prime/Comp':p.category==='CP'?'Comp/Prime':'Both Comp'}</div></div>
        </div>
        <div class="theorem-box"><strong>CF:</strong> [${cf.join('; ')}]<br><strong>Path:</strong> ${cfPath(cf)}</div>
        <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
            <button onclick="closePointModal();playFraction(${p.r},${p.m},1.0)" style="background:linear-gradient(135deg,#22c55e,#16a34a);">‚ñ∂ Play</button>
            <button onclick="closePointModal();playTreePathAudio('forward')" style="background:linear-gradient(135deg,#f59e0b,#d97706);">‚ñ∂ Path</button>
            <button onclick="closePointModal();viewPointOnAll(${p.r},${p.m},${p.sector})" style="background:linear-gradient(135deg,#6366f1,#8b5cf6);">View on All</button>
            <button onclick="closePointModal();scrollToSectorTree()" style="background:linear-gradient(135deg,#8b5cf6,#7c3aed);">See on Tree</button>
            <button onclick="closePointModal();addToSolver(${p.r}/${p.m})" style="background:linear-gradient(135deg,#10b981,#059669);">Add to Solver</button>
        </div>
    `;
    document.getElementById('pointModal').classList.add('active');
}
function closePointModal() { document.getElementById('pointModal').classList.remove('active'); }

// View point on all sectors with its sector highlighted
function viewPointOnAll(r, m, sector) {
    document.getElementById('showAllSectors').checked = true;
    state.highlightSectorOnly = sector;
    
    // Set point size from solver control if available
    const solverPtSize = parseFloat(document.getElementById('solverPointSize')?.value || 5);
    document.getElementById('ringPointSize').value = solverPtSize;
    updatePtSizeDisplay();
    
    // Enable tracker to highlight the specific fraction
    document.getElementById('enableResidueTracker').checked = true;
    document.getElementById('trackResidues').value = r;
    document.getElementById('trackerColor').value = '#10b981';
    document.getElementById('trackerGlow').checked = true;
    document.getElementById('trackerSize').value = solverPtSize;
    
    drawMainRing();
}

// Select point by a/b input
function selectPointByFraction() {
    const input = document.getElementById('pointSelectInput').value.trim();
    const match = input.match(/^(\d+)\s*\/\s*(\d+)$/);
    
    if (!match) {
        alert('Enter fraction as a/b (e.g., 3/7)');
        return;
    }
    
    const r = parseInt(match[1]);
    const m = parseInt(match[2]);
    
    if (m === 0 || r >= m || r <= 0) {
        alert('Invalid fraction: need 0 < a < b');
        return;
    }
    
    if (gcd(r, m) !== 1) {
        alert(`${r}/${m} is not in lowest terms. Use ${r/gcd(r,m)}/${m/gcd(r,m)}`);
        return;
    }
    
    // Find the point in ringPoints or create it
    let point = state.ringPoints?.find(p => p.r === r && p.m === m);
    
    if (!point) {
        // Point not currently visible - create a virtual one and switch to its sector
        const sector = Math.floor(m / r);
        point = {
            r, m,
            sector: sector,
            value: r / m,
            isPrime: NumberTheory.isPrime(m),
            isPrimeNum: NumberTheory.isPrime(r),
            category: (NumberTheory.isPrime(r) && NumberTheory.isPrime(m)) ? 'PP' :
                      (NumberTheory.isPrime(r) && !NumberTheory.isPrime(m)) ? 'PC' :
                      (!NumberTheory.isPrime(r) && NumberTheory.isPrime(m)) ? 'CP' : 'CC'
        };
        
        // Switch to the correct sector
        document.getElementById('viewSector').value = sector;
        document.getElementById('showAllSectors').checked = false;
        drawMainRing();
        
        // Try to find it again after redraw
        setTimeout(() => {
            point = state.ringPoints?.find(p => p.r === r && p.m === m);
            if (point) {
                highlightedRingPoint = point;
                drawMainRing();
                openPointModal(point);
                selectPointForTree(point);
                selectFractionForHarmonic(r, m);
            } else {
                // Still not visible - m might be larger than nMax
                alert(`Fraction ${r}/${m} not in current data (m=${m} may exceed N=${state.nMax}). Increase N and recompute.`);
            }
        }, 100);
        return;
    }
    
    // Point found - highlight and show modal
    highlightedRingPoint = point;
    drawMainRing();
    openPointModal(point);
    selectPointForTree(point);
    selectFractionForHarmonic(point.r, point.m);
}

function openSectorModal(n) { document.getElementById('viewSector').value=n; document.getElementById('showAllSectors').checked=false; drawMainRing(); }
function scrollToSectorTree() { document.getElementById('sectorTreeCanvas').scrollIntoView({ behavior: 'smooth', block: 'center' }); }

// Solver panel toggle
function toggleSolverPanel() {
    const panel = document.getElementById('solverPanel');
    const arrow = document.getElementById('solverArrow');
    const isHidden = panel.style.display === 'none';
    panel.style.display = isHidden ? 'block' : 'none';
    arrow.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
}

// Word Art panel toggle and functions
let wordArtPoints = [];

function toggleWordArtPanel() {
    const panel = document.getElementById('wordArtPanel');
    const arrow = document.getElementById('wordArtArrow');
    const isHidden = panel.style.display === 'none';
    panel.style.display = isHidden ? 'block' : 'none';
    arrow.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
}

function clearWordArt() {
    wordArtPoints = [];
    stopWordArtPlayback();
    const previewEl = document.getElementById('wordArtPreview');
    if (previewEl) previewEl.textContent = '';
    updateWordArtUI();
    drawMainRing();
}

function addPointToWordArt(p) {
    if (!document.getElementById('wordArtEnabled')?.checked) return false;
    
    // Avoid duplicates
    if (wordArtPoints.find(wp => wp.r === p.r && wp.m === p.m)) return true;
    
    // Add point to word art
    wordArtPoints.push({ r: p.r, m: p.m, x: p.x, y: p.y });
    updateWordArtUI();
    drawMainRing();
    return true;
}

// Generate word art from text - writes within specified sector from left to right
function generateWordArt() {
    const text = document.getElementById('wordArtText').value.toUpperCase();
    if (!text) return;
    
    clearWordArt();
    
    const sectorVal = document.getElementById('wordArtSector')?.value || '2';
    
    // Sector bounds in angle (as fraction of circle)
    let leftBound, rightBound;
    if (sectorVal === 'all') {
        leftBound = 0;
        rightBound = 1;
    } else {
        const sector = parseInt(sectorVal);
        leftBound = 1 / (sector + 1);  // e.g., 1/3 for sector 2
        rightBound = 1 / sector;        // e.g., 1/2 for sector 2
    }
    
    // Letter patterns - relative positions within a character cell
    // Each letter is array of [xOffset, yOffset] where x is 0-1 (left-right), y is 0-1 (inner-outer)
    const letterPatterns = {
        'W': [[0,0.9],[0.25,0.2],[0.5,0.6],[0.75,0.2],[1,0.9]],
        'E': [[0,0.9],[0,0.5],[0,0.1],[0.7,0.1],[0,0.5],[0.5,0.5],[0,0.9],[0.7,0.9]],
        'S': [[0.8,0.1],[0.2,0.2],[0.2,0.45],[0.8,0.55],[0.8,0.8],[0.2,0.9]],
        'N': [[0,0.9],[0,0.1],[0.9,0.9],[0.9,0.1]],
        'A': [[0,0.9],[0.5,0.1],[1,0.9],[0.25,0.5],[0.75,0.5]],
        'B': [[0,0.9],[0,0.1],[0.7,0.2],[0,0.5],[0.7,0.7],[0,0.9]],
        'C': [[0.8,0.2],[0.2,0.1],[0.2,0.9],[0.8,0.8]],
        'D': [[0,0.1],[0,0.9],[0.7,0.5],[0,0.1]],
        'F': [[0,0.9],[0,0.1],[0.8,0.1],[0,0.5],[0.6,0.5]],
        'G': [[0.8,0.2],[0.2,0.1],[0.2,0.9],[0.8,0.8],[0.8,0.5],[0.5,0.5]],
        'H': [[0,0.1],[0,0.9],[0,0.5],[1,0.5],[1,0.1],[1,0.9]],
        'I': [[0.5,0.1],[0.5,0.9]],
        'J': [[0.2,0.8],[0.5,0.9],[0.8,0.8],[0.8,0.1]],
        'K': [[0,0.1],[0,0.9],[0,0.5],[0.9,0.1],[0,0.5],[0.9,0.9]],
        'L': [[0,0.1],[0,0.9],[0.8,0.9]],
        'M': [[0,0.9],[0,0.1],[0.5,0.5],[1,0.1],[1,0.9]],
        'O': [[0.5,0.1],[0,0.5],[0.5,0.9],[1,0.5],[0.5,0.1]],
        'P': [[0,0.9],[0,0.1],[0.8,0.2],[0,0.5]],
        'Q': [[0.5,0.1],[0,0.5],[0.5,0.9],[1,0.5],[0.5,0.1],[0.8,0.8]],
        'R': [[0,0.9],[0,0.1],[0.8,0.2],[0,0.5],[0.9,0.9]],
        'T': [[0,0.1],[1,0.1],[0.5,0.1],[0.5,0.9]],
        'U': [[0,0.1],[0,0.9],[1,0.9],[1,0.1]],
        'V': [[0,0.1],[0.5,0.9],[1,0.1]],
        'X': [[0,0.1],[1,0.9],[0.5,0.5],[1,0.1],[0,0.9]],
        'Y': [[0,0.1],[0.5,0.5],[1,0.1],[0.5,0.5],[0.5,0.9]],
        'Z': [[0,0.1],[1,0.1],[0,0.9],[1,0.9]],
        ' ': []
    };
    
    const canvas = document.getElementById('mainRing');
    const W = canvas.width, H = canvas.height;
    const cx = W/2, cy = H/2;
    const maxR = Math.min(W, H) * 0.42;
    
    const numChars = text.replace(/ /g, '').length;
    const sectorWidth = rightBound - leftBound;
    const charWidth = sectorWidth / Math.max(numChars, 1);
    const padding = charWidth * 0.1;
    
    let charIndex = 0;
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (char === ' ') continue;
        
        const pattern = letterPatterns[char] || [];
        
        // Mirror: write from right to left (rightBound going left)
        const charStart = rightBound - (charIndex + 1) * charWidth + padding;
        const charEnd = rightBound - charIndex * charWidth - padding;
        
        pattern.forEach(([xOff, yOff]) => {
            // Map x offset to angle within character's slice (mirrored)
            const angle = (charStart + (1 - xOff) * (charEnd - charStart)) * 2 * Math.PI;
            // Map y offset to radius - use OUTER rings (0.75 to 0.98 of maxR)
            const rad = (0.75 + yOff * 0.23) * maxR;
            
            const targetX = cx + rad * Math.cos(angle);
            const targetY = cy - rad * Math.sin(angle);
            
            // Find closest ring point
            let closest = null, minDist = Infinity;
            state.ringPoints.forEach(p => {
                const d = Math.sqrt((p.x - targetX)**2 + (p.y - targetY)**2);
                if (d < minDist) {
                    minDist = d;
                    closest = p;
                }
            });
            
            if (closest && minDist < 80) {
                // Avoid duplicates
                if (!wordArtPoints.find(wp => wp.r === closest.r && wp.m === closest.m)) {
                    wordArtPoints.push({ r: closest.r, m: closest.m, x: closest.x, y: closest.y, char: char });
                }
            }
        });
        
        charIndex++;
    }
    
    updateWordArtUI();
    drawMainRing();
}

function updateWordArtUI() {
    const countEl = document.getElementById('wordArtPointCount');
    const previewEl = document.getElementById('wordArtPreview');
    const textEl = document.getElementById('wordArtText');
    const dropdown = document.getElementById('wordArtPointsDropdown');
    
    if (countEl) countEl.textContent = wordArtPoints.length;
    if (previewEl && textEl && wordArtPoints.length > 0) {
        previewEl.textContent = textEl.value || '';
    }
    
    // Update dropdown
    if (dropdown) {
        dropdown.innerHTML = '<option value="">-- Select to highlight --</option>';
        wordArtPoints.forEach((p, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = `${i+1}. ${p.r}/${p.m} = ${(p.r/p.m).toFixed(6)}${p.char ? ' ('+p.char+')' : ''}`;
            dropdown.appendChild(opt);
        });
    }
}

function highlightWordArtPoint(idx) {
    if (idx === '' || idx === null) return;
    const p = wordArtPoints[parseInt(idx)];
    if (!p) return;
    
    // Find full point data from ring points
    const fullPoint = state.ringPoints.find(rp => rp.r === p.r && rp.m === p.m);
    if (fullPoint) {
        highlightedRingPoint = fullPoint;
        selectPointForTree(fullPoint);
        drawMainRing();
    }
}

let wordArtPlaybackId = null;
let wordArtLooping = false;

function playWordArt(direction) {
    if (wordArtPoints.length === 0) {
        console.warn('No word art points to play');
        return;
    }
    
    stopWordArtPlayback();
    initAudioContext();
    wordArtLooping = true;
    
    const points = direction === 'backward' ? [...wordArtPoints].reverse() : [...wordArtPoints];
    let idx = 0;
    
    function playNext() {
        if (!wordArtLooping) return;
        
        if (idx >= points.length) {
            // Loop back to start
            idx = 0;
        }
        
        const p = points[idx];
        
        // Validate point before playing
        if (p && p.r && p.m && p.m > 0) {
            playFraction(p.r, p.m, 0.3);
            updateSolverLive(p.r, p.m);
            
            // Highlight point
            const fullPoint = state.ringPoints.find(rp => rp.r === p.r && rp.m === p.m);
            if (fullPoint) {
                highlightedRingPoint = fullPoint;
                drawMainRing();
            }
            
            // Update dropdown selection
            const realIdx = direction === 'backward' ? wordArtPoints.length - 1 - idx : idx;
            const dropdown = document.getElementById('wordArtPointsDropdown');
            if (dropdown) dropdown.value = realIdx;
        }
        
        idx++;
        wordArtPlaybackId = setTimeout(playNext, 250);
    }
    
    playNext();
}

function stopWordArtPlayback() {
    wordArtLooping = false;
    if (wordArtPlaybackId) {
        clearTimeout(wordArtPlaybackId);
        wordArtPlaybackId = null;
    }
}

// Draw word art on ring canvas
function drawWordArt(ctx) {
    if (!document.getElementById('wordArtEnabled')?.checked) return;
    if (wordArtPoints.length < 2) return;
    
    const color = document.getElementById('wordArtColor')?.value || '#ffd700';
    const size = parseFloat(document.getElementById('wordArtSize')?.value || 3);
    
    // Draw connecting lines
    ctx.strokeStyle = color;
    ctx.lineWidth = size;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.globalAlpha = 0.8;
    
    ctx.beginPath();
    ctx.moveTo(wordArtPoints[0].x, wordArtPoints[0].y);
    for (let i = 1; i < wordArtPoints.length; i++) {
        ctx.lineTo(wordArtPoints[i].x, wordArtPoints[i].y);
    }
    ctx.stroke();
    
    // Draw points
    ctx.fillStyle = color;
    ctx.globalAlpha = 1;
    wordArtPoints.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, size * 1.5, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    ctx.globalAlpha = 1;
}

function addToSolver(value) {
    // Open solver panel if closed
    const panel = document.getElementById('solverPanel');
    if (panel.style.display === 'none') {
        toggleSolverPanel();
    }
    document.getElementById('solverInput').value = value;
    solverSearch(value.toString());
    
    // Apply view on ring after search completes
    setTimeout(() => {
        if (solverCurrentMatch) {
            solverHighlightOnRing();
        }
    }, 100);
}

// SECTOR TREE VISUALIZATION
let selectedTreePoint = null;
let treeAnimationId = null;

// Tree zoom/pan state
let treeZoom = 1;
let treePanX = 0;
let treePanY = 0;
let treeIsDragging = false;
let treeDragStartX = 0;
let treeDragStartY = 0;
let treePanStartX = 0;
let treePanStartY = 0;

function drawSectorTree() {
    const canvas = document.getElementById('sectorTreeCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const depth = +document.getElementById('treeDepth').value;
    const showLabels = document.getElementById('showTreeLabels').checked;
    const showGrid = document.getElementById('showTreeGrid').checked;
    const sectorFilter = document.getElementById('treeSectorFilter')?.value || 'all';
    const colorMode = document.getElementById('treeColorMode')?.value || 'default';
    const highlightOnly = document.getElementById('treeHighlightOnly')?.checked || false;
    const basePointSize = parseFloat(document.getElementById('treePointSize')?.value || 4);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw grid if enabled
    if (showGrid) {
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 1;
        for (let i = 1; i < depth; i++) {
            const y = 40 + (i / depth) * (H - 80);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y);
            ctx.stroke();
        }
    }
    
    // Draw sector boundary lines if filtering
    if (sectorFilter !== 'all') {
        const sectorNum = parseInt(sectorFilter);
        const leftBound = 1 / (sectorNum + 1);
        const rightBound = 1 / sectorNum;
        
        // Convert to x positions (fractions map to horizontal position)
        const leftX = leftBound * W;
        const rightX = rightBound * W;
        
        // Draw sector region highlight
        ctx.fillStyle = 'rgba(99, 102, 241, 0.1)';
        ctx.fillRect(leftX, 0, rightX - leftX, H);
        
        // Draw boundary lines
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(leftX, 0);
        ctx.lineTo(leftX, H);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(rightX, 0);
        ctx.lineTo(rightX, H);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Label boundaries
        ctx.fillStyle = '#a5b4fc';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`1/${sectorNum + 1}`, leftX, H - 5);
        ctx.fillText(`1/${sectorNum}`, rightX, H - 5);
    }
    
    // Build and draw Stern-Brocot tree
    const treeNodes = buildSternBrocotTree(depth);
    
    // Calculate sector for each node
    treeNodes.forEach(node => {
        node.sector = getSector(node.r, node.m);
        node.isPrime = isPrime(node.m);
    });
    
    // Draw edges first
    treeNodes.forEach(node => {
        if (node.parent) {
            const inSector = sectorFilter === 'all' || node.sector === parseInt(sectorFilter);
            const parentInSector = sectorFilter === 'all' || node.parent.sector === parseInt(sectorFilter);
            
            if (highlightOnly && sectorFilter !== 'all' && !inSector && !parentInSector) {
                ctx.strokeStyle = '#1e293b';
            } else if (inSector && sectorFilter !== 'all') {
                ctx.strokeStyle = getSectorColor(node.sector);
            } else {
                ctx.strokeStyle = '#334155';
            }
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(node.parent.x, node.parent.y);
            ctx.lineTo(node.x, node.y);
            ctx.stroke();
        }
    });
    
    // Draw nodes
    treeNodes.forEach(node => {
        const isOnPath = selectedTreePoint && isNodeOnPath(node, selectedTreePoint);
        const isTarget = selectedTreePoint && node.r === selectedTreePoint.r && node.m === selectedTreePoint.m;
        const inSector = sectorFilter === 'all' || node.sector === parseInt(sectorFilter);
        
        // Skip dim nodes if highlight only
        if (highlightOnly && sectorFilter !== 'all' && !inSector && !isOnPath && !isTarget) {
            ctx.fillStyle = '#1e293b';
            ctx.beginPath();
            ctx.arc(node.x, node.y, basePointSize * 0.4, 0, 2 * Math.PI);
            ctx.fill();
            return;
        }
        
        ctx.beginPath();
        const nodeSize = isTarget ? basePointSize * 2.5 : (isOnPath ? basePointSize * 1.75 : (inSector && sectorFilter !== 'all' ? basePointSize * 1.5 : basePointSize));
        ctx.arc(node.x, node.y, nodeSize, 0, 2 * Math.PI);
        
        if (isTarget) {
            ctx.fillStyle = '#22c55e';
        } else if (isOnPath) {
            ctx.fillStyle = '#f59e0b';
        } else {
            // Apply color mode
            switch (colorMode) {
                case 'sector':
                    ctx.fillStyle = getSectorColor(node.sector);
                    break;
                case 'prime':
                    ctx.fillStyle = node.isPrime ? '#f59e0b' : '#6366f1';
                    break;
                case 'arnold':
                    if (typeof getHarmonicMode === 'function') {
                        const mode = getHarmonicMode(node.m);
                        ctx.fillStyle = mode.color;
                    } else {
                        ctx.fillStyle = '#6366f1';
                    }
                    break;
                default:
                    if (sectorFilter !== 'all' && inSector) {
                        ctx.fillStyle = getSectorColor(node.sector);
                    } else {
                        ctx.fillStyle = '#6366f1';
                    }
            }
        }
        ctx.fill();
        
        // Labels
        const showThisLabel = showLabels && (node.depth <= 5 || (inSector && sectorFilter !== 'all'));
        if (showThisLabel) {
            ctx.fillStyle = inSector && sectorFilter !== 'all' ? '#fff' : '#e2e8f0';
            ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
        }
    });
    
    // Draw highlighted path if point selected
    if (selectedTreePoint) {
        drawTreePath(ctx, treeNodes, selectedTreePoint);
    }
    
    // Draw tree labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('0/1', 10, 30);
    ctx.textAlign = 'right';
    ctx.fillText('1/1', W - 10, 30);
    ctx.textAlign = 'center';
    ctx.fillText('1/2 (root)', W/2, 25);
    
    // Sector info
    if (sectorFilter !== 'all') {
        const sectorNum = parseInt(sectorFilter);
        const nodesInSector = treeNodes.filter(n => n.sector === sectorNum);
        ctx.fillStyle = '#a5b4fc';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText(`Sector ${sectorNum}: ${nodesInSector.length} nodes in tree`, W - 10, 15);
    }
    
    // Depth markers
    ctx.textAlign = 'left';
    ctx.fillStyle = '#475569';
    for (let d = 1; d <= Math.min(depth, 6); d++) {
        const y = 40 + (d / depth) * (H - 80);
        ctx.fillText(`d=${d}`, 5, y + 4);
    }
    
    // Draw zoom/pan indicator (mini-map) in bottom-right
    if (treeZoom !== 1 || treePanX !== 0 || treePanY !== 0) {
        const mapSize = 80;
        const mapX = W - mapSize - 10;
        const mapY = H - mapSize - 10;
        
        // Mini-map background
        ctx.fillStyle = 'rgba(15, 23, 42, 0.85)';
        ctx.fillRect(mapX, mapY, mapSize, mapSize);
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.strokeRect(mapX, mapY, mapSize, mapSize);
        
        // Calculate viewport rectangle
        const viewW = W / treeZoom;
        const viewH = H / treeZoom;
        const viewX = (W/2 - treePanX) / treeZoom - viewW/2;
        const viewY = (H/2 - treePanY) / treeZoom - viewH/2;
        
        // Scale to mini-map
        const scale = mapSize / Math.max(W, H);
        const rectX = mapX + viewX * scale;
        const rectY = mapY + viewY * scale;
        const rectW = viewW * scale;
        const rectH = viewH * scale;
        
        // Draw viewport indicator
        ctx.strokeStyle = '#8b5cf6';
        ctx.lineWidth = 2;
        ctx.strokeRect(
            Math.max(mapX, Math.min(mapX + mapSize - rectW, rectX)),
            Math.max(mapY, Math.min(mapY + mapSize - rectH, rectY)),
            Math.min(rectW, mapSize),
            Math.min(rectH, mapSize)
        );
        
        // Zoom label
        ctx.fillStyle = '#8b5cf6';
        ctx.font = 'bold 10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round(treeZoom * 100)}%`, mapX + mapSize/2, mapY - 4);
    }
}

function playTreeSectorFractions() {
    const sectorFilter = document.getElementById('treeSectorFilter')?.value || 'all';
    if (sectorFilter === 'all') {
        showPlaybackStatus('Select a specific sector to play');
        return;
    }
    
    const sectorNum = parseInt(sectorFilter);
    const depth = +document.getElementById('treeDepth').value;
    const treeNodes = buildSternBrocotTree(depth);
    
    // Get nodes in this sector
    const nodesInSector = treeNodes.filter(n => getSector(n.r, n.m) === sectorNum);
    
    if (nodesInSector.length === 0) {
        showPlaybackStatus(`No nodes in sector ${sectorNum} at depth ${depth}`);
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value (ascending)
    nodesInSector.sort((a, b) => a.r/a.m - b.r/b.m);
    
    playbackState.queue = nodesInSector.map(n => ({ r: n.r, m: n.m }));
    playbackState.direction = 'forward';
    playbackState.mode = 'tree-sector';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing ${nodesInSector.length} fractions from sector ${sectorNum}`);
    startPlaybackLoop();
}

function buildSternBrocotTree(maxDepth) {
    const nodes = [];
    const W = document.getElementById('sectorTreeCanvas').width;
    const H = document.getElementById('sectorTreeCanvas').height;
    
    // Center for zoom/pan transforms
    const centerX = W / 2;
    const centerY = H / 2;
    
    // Root node: 1/2
    const baseX = W/2;
    const baseY = 50;
    const root = { 
        r: 1, m: 2, depth: 1, 
        baseX: baseX, baseY: baseY,
        x: (baseX - centerX) * treeZoom + centerX + treePanX, 
        y: (baseY - centerY) * treeZoom + centerY + treePanY, 
        parent: null, path: '', 
        leftAncestor: {r:0,m:1}, rightAncestor: {r:1,m:1} 
    };
    nodes.push(root);
    
    // BFS to build tree
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        if (node.depth >= maxDepth) continue;
        
        const nextDepth = node.depth + 1;
        const baseLevelY = 40 + (nextDepth / maxDepth) * (H - 80);
        const spreadFactor = Math.pow(0.5, nextDepth) * W * 0.45;
        
        // Left child: mediant of left ancestor and current
        const leftR = node.leftAncestor.r + node.r;
        const leftM = node.leftAncestor.m + node.m;
        if (leftM <= 200) {
            const baseX = node.baseX - spreadFactor;
            const baseY = baseLevelY;
            const leftChild = {
                r: leftR, m: leftM, depth: nextDepth,
                baseX: baseX, baseY: baseY,
                x: (baseX - centerX) * treeZoom + centerX + treePanX,
                y: (baseY - centerY) * treeZoom + centerY + treePanY,
                parent: node,
                path: node.path + 'L',
                leftAncestor: node.leftAncestor,
                rightAncestor: { r: node.r, m: node.m }
            };
            nodes.push(leftChild);
            queue.push(leftChild);
        }
        
        // Right child: mediant of current and right ancestor
        const rightR = node.r + node.rightAncestor.r;
        const rightM = node.m + node.rightAncestor.m;
        if (rightM <= 200) {
            const baseX = node.baseX + spreadFactor;
            const baseY = baseLevelY;
            const rightChild = {
                r: rightR, m: rightM, depth: nextDepth,
                baseX: baseX, baseY: baseY,
                x: (baseX - centerX) * treeZoom + centerX + treePanX,
                y: (baseY - centerY) * treeZoom + centerY + treePanY,
                parent: node,
                path: node.path + 'R',
                leftAncestor: { r: node.r, m: node.m },
                rightAncestor: node.rightAncestor
            };
            nodes.push(rightChild);
            queue.push(rightChild);
        }
    }
    
    return nodes;
}

function isNodeOnPath(node, target) {
    // Check if this node is on the path to the target
    const targetPath = getPathToFraction(target.r, target.m);
    return targetPath.startsWith(node.path) || node.path === '' || 
           (node.r === 1 && node.m === 2 && targetPath.length > 0);
}

function getPathToFraction(r, m) {
    // Generate the Stern-Brocot path to reach r/m
    let path = '';
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    const targetVal = r / m;
    const maxIter = 100;
    let iter = 0;
    
    while (iter < maxIter && (medR !== r || medM !== m)) {
        const medVal = medR / medM;
        
        if (targetVal < medVal) {
            // Go left
            path += 'L';
            rightR = medR;
            rightM = medM;
        } else if (targetVal > medVal) {
            // Go right
            path += 'R';
            leftR = medR;
            leftM = medM;
        } else {
            break;
        }
        
        medR = leftR + rightR;
        medM = leftM + rightM;
        iter++;
    }
    
    return path;
}

function drawTreePath(ctx, treeNodes, target) {
    const path = getPathToFraction(target.r, target.m);
    const animate = document.getElementById('animatePath').checked;
    
    // Find nodes on path
    const pathNodes = [treeNodes.find(n => n.r === 1 && n.m === 2)]; // Start with root
    let currentPath = '';
    
    for (let i = 0; i < path.length; i++) {
        currentPath += path[i];
        const node = treeNodes.find(n => n.path === currentPath);
        if (node) pathNodes.push(node);
    }
    
    // Draw path edges with highlight
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#f59e0b';
    ctx.shadowBlur = 10;
    
    for (let i = 0; i < pathNodes.length - 1; i++) {
        const from = pathNodes[i];
        const to = pathNodes[i + 1];
        
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        
        // Draw direction indicator
        const midX = (from.x + to.x) / 2;
        const midY = (from.y + to.y) / 2;
        const dir = path[i];
        
        ctx.fillStyle = dir === 'L' ? '#ef4444' : '#3b82f6';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(dir, midX + (dir === 'L' ? -15 : 15), midY);
    }
    
    ctx.shadowBlur = 0;
    
    // Draw target node larger
    if (pathNodes.length > 0) {
        const targetNode = pathNodes[pathNodes.length - 1];
        ctx.beginPath();
        ctx.arc(targetNode.x, targetNode.y, 12, 0, 2 * Math.PI);
        ctx.fillStyle = '#22c55e';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`${target.r}/${target.m}`, targetNode.x, targetNode.y - 18);
    }
}

function updateTreePathInfo(point) {
    const path = getPathToFraction(point.r, point.m);
    const cf = toCF(point.r, point.m);
    const freq = harmonicSettings.baseFreq * (point.r / point.m);
    const note = frequencyToNote(freq);
    const mode = getHarmonicMode(point.m);
    
    // Count L's and R's
    const lCount = (path.match(/L/g) || []).length;
    const rCount = (path.match(/R/g) || []).length;
    
    // Format path with colors
    const coloredPath = path.split('').map(c => 
        `<span style="color:${c === 'L' ? '#ef4444' : '#3b82f6'}; font-weight:bold;">${c}</span>`
    ).join('');
    
    document.getElementById('treePathInfo').innerHTML = `
        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:15px; align-items:start;">
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Target Fraction</div>
                <div style="color:#22c55e; font-size:1.4em; font-weight:bold;">${point.r}/${point.m}</div>
                <div style="color:#64748b; font-size:0.85em;">= ${(point.r/point.m).toFixed(8)}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Stern-Brocot Path</div>
                <div style="font-size:1.1em; word-break:break-all;">${coloredPath || '<span style="color:#22c55e;">ROOT</span>'}</div>
                <div style="color:#64748b; font-size:0.85em;">Length: ${path.length} steps</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Path Statistics</div>
                <div><span style="color:#ef4444;">L: ${lCount}</span> | <span style="color:#3b82f6;">R: ${rCount}</span></div>
                <div style="color:#64748b; font-size:0.85em;">Ratio: ${lCount > 0 ? (rCount/lCount).toFixed(2) : '‚àû'}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Continued Fraction</div>
                <div style="color:#8b5cf6;">[${cf.join('; ')}]</div>
                <div style="color:#64748b; font-size:0.85em;">Depth: ${cf.length} terms</div>
            </div>
            <div style="background:#1e293b; padding:10px; border-radius:6px; border:1px solid #334155;">
                <div style="color:#94a3b8; font-size:0.8em;">Harmonic</div>
                <div style="color:#8b5cf6; font-size:1.2em; font-weight:bold;">${freq.toFixed(1)} Hz</div>
                <div style="color:#22c55e; font-size:0.9em;">${note.name} <span class="mode-badge ${mode.class}" style="font-size:9px;">${mode.name}</span></div>
                <div style="margin-top:8px; display:flex; gap:5px;">
                    <button onclick="playTreeFraction()" style="flex:1; padding:5px 8px; font-size:11px; background:linear-gradient(135deg,#22c55e,#16a34a); border:none; border-radius:4px; color:white; cursor:pointer;">‚ñ∂ Play</button>
                    <button onclick="playTreeScale()" style="flex:1; padding:5px 8px; font-size:11px; background:#6366f1; border:none; border-radius:4px; color:white; cursor:pointer;">‚ô™ Scale</button>
                </div>
            </div>
        </div>
        <div style="margin-top:12px; padding-top:12px; border-top:1px solid #334155;">
            <span style="color:#94a3b8; font-size:0.8em;">Sector:</span> <span style="color:#6366f1;">${point.sector}</span> 
            <span style="margin-left:15px; color:#94a3b8; font-size:0.8em;">Modulus:</span> 
            <span style="color:${point.isPrime ? '#f59e0b' : '#6366f1'};">${point.m} (${point.isPrime ? 'Prime' : 'Composite'})</span>
        </div>
    `;
}

function clearTreePath() {
    selectedTreePoint = null;
    drawSectorTree();
    document.getElementById('treePathInfo').innerHTML = '<span style="color:#64748b;">Click a point on the ring above to see its tree path</span>';
}

function playTreeFraction() {
    if (selectedTreePoint) {
        playFraction(selectedTreePoint.r, selectedTreePoint.m, 0.8);
        
        // Visual feedback
        const btn = document.getElementById('treePlayBtn');
        btn.style.transform = 'scale(1.1)';
        setTimeout(() => btn.style.transform = 'scale(1)', 150);
    } else {
        alert('Select a point on the ring first to play its frequency');
    }
}

function playTreeScale() {
    if (!selectedTreePoint) {
        alert('Select a point on the ring first');
        return;
    }
    
    initAudioContext();
    
    // Get all fractions along the path to the selected point
    const path = getPathToFraction(selectedTreePoint.r, selectedTreePoint.m);
    const fractions = [{ r: 1, m: 2 }]; // Start with root
    
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    for (let i = 0; i < path.length; i++) {
        if (path[i] === 'L') {
            rightR = medR;
            rightM = medM;
        } else {
            leftR = medR;
            leftM = medM;
        }
        medR = leftR + rightR;
        medM = leftM + rightM;
        fractions.push({ r: medR, m: medM });
    }
    
    // Play each fraction in sequence
    let delay = 0;
    fractions.forEach((f, i) => {
        setTimeout(() => {
            playFraction(f.r, f.m, 0.35);
            updateSolverLive(f.r, f.m);
            
            // Highlight in tree path info
            const info = document.getElementById('treePathInfo');
            if (info) {
                const highlight = document.createElement('span');
                highlight.style.cssText = 'background:#6366f1;padding:2px 6px;border-radius:3px;margin-left:5px;';
                highlight.textContent = `Playing: ${f.r}/${f.m}`;
                const existing = info.querySelector('.playing-indicator');
                if (existing) existing.remove();
                highlight.className = 'playing-indicator';
                info.appendChild(highlight);
            }
        }, delay);
        delay += 300;
    });
    
    // Clean up indicator after all notes played
    setTimeout(() => {
        const indicator = document.querySelector('.playing-indicator');
        if (indicator) indicator.remove();
    }, delay + 500);
}

function selectPointForTree(point) {
    selectedTreePoint = point;
    updateTreePathInfo(point);
    
    const animate = document.getElementById('animatePath').checked;
    if (animate) {
        animateTreePath(point);
    } else {
        drawSectorTree();
    }
}

// Go to fraction from a/b input
function goToTreeFraction() {
    const input = document.getElementById('treeFractionInput').value.trim();
    const match = input.match(/^(\d+)\s*[\/]\s*(\d+)$/);
    
    if (!match) {
        alert('Enter fraction as a/b (e.g., 3/7)');
        return;
    }
    
    const r = parseInt(match[1]);
    const m = parseInt(match[2]);
    
    if (m === 0 || r > m || r < 0) {
        alert('Invalid fraction. Must be 0 < a < b');
        return;
    }
    
    // Check if coprime
    if (gcd(r, m) !== 1) {
        const g = gcd(r, m);
        alert(`Fraction ${r}/${m} reduces to ${r/g}/${m/g}. Using reduced form.`);
        const rr = r / g;
        const mm = m / g;
        goToTreeFractionDirect(rr, mm);
        return;
    }
    
    goToTreeFractionDirect(r, m);
}

function goToTreeFractionDirect(r, m) {
    const sector = getSector(r, m);
    const point = {
        r: r,
        m: m,
        sector: sector,
        isPrime: isPrime(m)
    };
    
    selectPointForTree(point);
    
    // Also update solver live
    updateSolverLive(r, m);
    
    // Scroll to tree
    document.getElementById('sectorTreeCanvas').scrollIntoView({ behavior: 'smooth', block: 'center' });
}

// Enter key support for tree fraction input
document.addEventListener('DOMContentLoaded', function() {
    const treeFracInput = document.getElementById('treeFractionInput');
    if (treeFracInput) {
        treeFracInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') goToTreeFraction();
        });
    }
});

function animateTreePath(point) {
    if (treeAnimationId) {
        cancelAnimationFrame(treeAnimationId);
    }
    
    const path = getPathToFraction(point.r, point.m);
    let currentStep = 0;
    const zoomToPath = document.getElementById('zoomToPath')?.checked;
    
    // Store original zoom state to restore later
    const originalZoom = treeViewState.zoom;
    const originalOffsetX = treeViewState.offsetX;
    const originalOffsetY = treeViewState.offsetY;
    
    function animateStep() {
        const canvas = document.getElementById('sectorTreeCanvas');
        const ctx = canvas.getContext('2d');
        const depth = +document.getElementById('treeDepth').value;
        const showLabels = document.getElementById('showTreeLabels').checked;
        const basePointSize = parseFloat(document.getElementById('treePointSize')?.value || 4);
        
        // Calculate zoom for current step if zoomToPath is enabled
        if (zoomToPath && path.length > 0) {
            const progress = currentStep / path.length;
            if (currentStep < path.length) {
                // Zoom in progressively as we traverse the path
                const targetZoom = Math.min(300, 100 + progress * 150);
                treeViewState.zoom = targetZoom;
                document.getElementById('treeZoomDisplay').textContent = Math.round(targetZoom);
                document.getElementById('treeZoomSlider').value = targetZoom;
            }
        }
        
        // Redraw base tree
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const treeNodes = buildSternBrocotTree(depth);
        
        // Draw all edges
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        treeNodes.forEach(node => {
            if (node.parent) {
                ctx.beginPath();
                ctx.moveTo(node.parent.x, node.parent.y);
                ctx.lineTo(node.x, node.y);
                ctx.stroke();
            }
        });
        
        // Draw nodes
        treeNodes.forEach(node => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, basePointSize, 0, 2 * Math.PI);
            ctx.fillStyle = '#6366f1';
            ctx.fill();
            
            if (showLabels && node.depth <= 5) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
            }
        });
        
        // Draw animated path up to current step
        const partialPath = path.substring(0, currentStep);
        let currentNode = treeNodes.find(n => n.r === 1 && n.m === 2);
        
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#f59e0b';
        ctx.shadowBlur = 10;
        
        let pathStr = '';
        for (let i = 0; i < partialPath.length; i++) {
            pathStr += partialPath[i];
            const nextNode = treeNodes.find(n => n.path === pathStr);
            if (nextNode && currentNode) {
                ctx.beginPath();
                ctx.moveTo(currentNode.x, currentNode.y);
                ctx.lineTo(nextNode.x, nextNode.y);
                ctx.stroke();
                
                // Direction label
                const midX = (currentNode.x + nextNode.x) / 2;
                const midY = (currentNode.y + nextNode.y) / 2;
                ctx.fillStyle = partialPath[i] === 'L' ? '#ef4444' : '#3b82f6';
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(partialPath[i], midX + (partialPath[i] === 'L' ? -15 : 15), midY);
                
                currentNode = nextNode;
            }
        }
        
        ctx.shadowBlur = 0;
        
        // Highlight current position
        if (currentNode) {
            ctx.beginPath();
            ctx.arc(currentNode.x, currentNode.y, currentStep === path.length ? basePointSize * 3 : basePointSize * 2, 0, 2 * Math.PI);
            ctx.fillStyle = currentStep === path.length ? '#22c55e' : '#f59e0b';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Pan to keep current node in view if zooming
            if (zoomToPath && currentNode) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                // Gradually shift view toward current node
                treeViewState.offsetX += (centerX - currentNode.x) * 0.1;
                treeViewState.offsetY += (centerY - currentNode.y) * 0.05;
            }
        }
        
        currentStep++;
        
        if (currentStep <= path.length) {
            treeAnimationId = requestAnimationFrame(() => setTimeout(animateStep, 150));
        } else if (zoomToPath) {
            // Animation complete - zoom back out smoothly
            setTimeout(() => zoomOutAfterPath(originalZoom, originalOffsetX, originalOffsetY), 500);
        }
    }
    
    animateStep();
}

// Smooth zoom out after path animation completes
function zoomOutAfterPath(targetZoom, targetOffsetX, targetOffsetY) {
    const steps = 30;
    let step = 0;
    
    const startZoom = treeViewState.zoom;
    const startOffsetX = treeViewState.offsetX;
    const startOffsetY = treeViewState.offsetY;
    
    function animateZoomOut() {
        step++;
        const t = step / steps;
        const eased = 1 - Math.pow(1 - t, 3); // ease out cubic
        
        treeViewState.zoom = startZoom + (targetZoom - startZoom) * eased;
        treeViewState.offsetX = startOffsetX + (targetOffsetX - startOffsetX) * eased;
        treeViewState.offsetY = startOffsetY + (targetOffsetY - startOffsetY) * eased;
        
        document.getElementById('treeZoomDisplay').textContent = Math.round(treeViewState.zoom);
        document.getElementById('treeZoomSlider').value = treeViewState.zoom;
        
        drawSectorTree();
        
        if (step < steps) {
            requestAnimationFrame(animateZoomOut);
        }
    }
    
    animateZoomOut();
}

// Add click handler for tree canvas to select and play nodes
document.addEventListener('DOMContentLoaded', function() {
    const treeCanvas = document.getElementById('sectorTreeCanvas');
    if (treeCanvas) {
        treeCanvas.addEventListener('click', handleTreeCanvasClick);
        treeCanvas.addEventListener('wheel', handleTreeWheel, { passive: false });
        treeCanvas.addEventListener('mousedown', handleTreeMouseDown);
        treeCanvas.addEventListener('mousemove', handleTreeMouseMove);
        treeCanvas.addEventListener('mouseup', handleTreeMouseUp);
        treeCanvas.addEventListener('mouseleave', handleTreeMouseUp);
        // Touch support
        treeCanvas.addEventListener('touchstart', handleTreeTouchStart, { passive: false });
        treeCanvas.addEventListener('touchmove', handleTreeTouchMove, { passive: false });
        treeCanvas.addEventListener('touchend', handleTreeTouchEnd);
        treeCanvas.style.cursor = 'grab';
        
        // Make canvas focusable for keyboard events
        treeCanvas.tabIndex = 0;
        treeCanvas.addEventListener('keydown', handleTreeKeyboard);
    }
});

// Keyboard shortcuts for tree navigation
function handleTreeKeyboard(e) {
    const key = e.key.toLowerCase();
    let handled = false;
    
    switch(key) {
        case '+':
        case '=':
            zoomTree('in');
            handled = true;
            break;
        case '-':
        case '_':
            zoomTree('out');
            handled = true;
            break;
        case 'arrowleft':
            panTree('left');
            handled = true;
            break;
        case 'arrowright':
            panTree('right');
            handled = true;
            break;
        case 'arrowup':
            panTree('up');
            handled = true;
            break;
        case 'arrowdown':
            panTree('down');
            handled = true;
            break;
        case 'home':
        case 'r':
            resetTreeZoom();
            handled = true;
            break;
        case 'f':
            fitTreeToView();
            handled = true;
            break;
    }
    
    if (handled) {
        e.preventDefault();
        e.stopPropagation();
    }
}

// Tree zoom/pan functions
function handleTreeWheel(e) {
    e.preventDefault();
    const canvas = e.target;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;
    
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.max(0.2, Math.min(10, treeZoom * zoomFactor));
    
    // Zoom toward mouse position
    const zoomRatio = newZoom / treeZoom;
    treePanX = mouseX - (mouseX - treePanX) * zoomRatio;
    treePanY = mouseY - (mouseY - treePanY) * zoomRatio;
    
    treeZoom = newZoom;
    updateTreeZoomDisplay();
    drawSectorTree();
}

function handleTreeMouseDown(e) {
    if (e.button !== 0) return; // Only left click
    treeIsDragging = false;
    treeDragStartX = e.clientX;
    treeDragStartY = e.clientY;
    treePanStartX = treePanX;
    treePanStartY = treePanY;
    e.target.style.cursor = 'grabbing';
}

function handleTreeMouseMove(e) {
    if (e.buttons !== 1) return; // Must be holding left button
    
    const dx = e.clientX - treeDragStartX;
    const dy = e.clientY - treeDragStartY;
    
    // Only start dragging after moving a bit (to allow clicks)
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
        treeIsDragging = true;
    }
    
    if (treeIsDragging) {
        const canvas = e.target;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        treePanX = treePanStartX + dx * scaleX;
        treePanY = treePanStartY + dy * scaleY;
        drawSectorTree();
    }
}

function handleTreeMouseUp(e) {
    const canvas = document.getElementById('sectorTreeCanvas');
    if (canvas) canvas.style.cursor = 'grab';
    // Small delay to prevent click firing after drag
    setTimeout(() => { treeIsDragging = false; }, 50);
}

// Touch support for mobile zoom/pan
let treeTouchStartDist = 0;
let treeTouchStartZoom = 1;
let treeTouchStartPan = { x: 0, y: 0 };
let treeTouchStartMid = { x: 0, y: 0 };

function handleTreeTouchStart(e) {
    if (e.touches.length === 1) {
        treeDragStartX = e.touches[0].clientX;
        treeDragStartY = e.touches[0].clientY;
        treePanStartX = treePanX;
        treePanStartY = treePanY;
        treeIsDragging = false;
    } else if (e.touches.length === 2) {
        e.preventDefault();
        const t1 = e.touches[0], t2 = e.touches[1];
        treeTouchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        treeTouchStartZoom = treeZoom;
        treeTouchStartPan = { x: treePanX, y: treePanY };
        treeTouchStartMid = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
    }
}

function handleTreeTouchMove(e) {
    const canvas = document.getElementById('sectorTreeCanvas');
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    if (e.touches.length === 1) {
        const dx = e.touches[0].clientX - treeDragStartX;
        const dy = e.touches[0].clientY - treeDragStartY;
        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
            treeIsDragging = true;
            treePanX = treePanStartX + dx * scaleX;
            treePanY = treePanStartY + dy * scaleY;
            drawSectorTree();
        }
    } else if (e.touches.length === 2) {
        e.preventDefault();
        const t1 = e.touches[0], t2 = e.touches[1];
        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const midX = (t1.clientX + t2.clientX) / 2;
        const midY = (t1.clientY + t2.clientY) / 2;
        
        const newZoom = Math.max(0.2, Math.min(10, treeTouchStartZoom * (dist / treeTouchStartDist)));
        const zoomRatio = newZoom / treeZoom;
        
        const canvasX = (midX - rect.left) * scaleX;
        const canvasY = (midY - rect.top) * scaleY;
        
        treePanX = canvasX - (canvasX - treePanX) * zoomRatio;
        treePanY = canvasY - (canvasY - treePanY) * zoomRatio;
        treeZoom = newZoom;
        
        updateTreeZoomDisplay();
        drawSectorTree();
    }
}

function handleTreeTouchEnd(e) {
    setTimeout(() => { treeIsDragging = false; }, 50);
}

function zoomTree(direction) {
    const canvas = document.getElementById('sectorTreeCanvas');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    const zoomFactor = direction === 'in' ? 1.3 : 0.7;
    const newZoom = Math.max(0.2, Math.min(10, treeZoom * zoomFactor));
    
    // Zoom toward center
    const zoomRatio = newZoom / treeZoom;
    treePanX = centerX - (centerX - treePanX) * zoomRatio;
    treePanY = centerY - (centerY - treePanY) * zoomRatio;
    
    treeZoom = newZoom;
    updateTreeZoomDisplay();
    drawSectorTree();
}

function resetTreeZoom() {
    treeZoom = 1;
    treePanX = 0;
    treePanY = 0;
    updateTreeZoomDisplay();
    drawSectorTree();
}

function updateTreeZoomDisplay() {
    const display = document.getElementById('treeZoomDisplay');
    const slider = document.getElementById('treeZoomSlider');
    const zoomPercent = Math.round(treeZoom * 100);
    if (display) display.textContent = zoomPercent;
    if (slider) slider.value = zoomPercent;
}

function setTreeZoomFromSlider(value) {
    const canvas = document.getElementById('sectorTreeCanvas');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    const newZoom = Math.max(0.2, Math.min(5, value / 100));
    const zoomRatio = newZoom / treeZoom;
    
    // Zoom toward center
    treePanX = centerX - (centerX - treePanX) * zoomRatio;
    treePanY = centerY - (centerY - treePanY) * zoomRatio;
    
    treeZoom = newZoom;
    updateTreeZoomDisplay();
    drawSectorTree();
}

function panTree(direction) {
    const canvas = document.getElementById('sectorTreeCanvas');
    const panAmount = 50 / treeZoom; // Pan more at lower zoom
    
    switch(direction) {
        case 'left':  treePanX += panAmount; break;
        case 'right': treePanX -= panAmount; break;
        case 'up':    treePanY += panAmount; break;
        case 'down':  treePanY -= panAmount; break;
    }
    drawSectorTree();
}

function fitTreeToView() {
    const canvas = document.getElementById('sectorTreeCanvas');
    const W = canvas.width, H = canvas.height;
    const depth = +document.getElementById('treeDepth').value;
    
    // Reset first to get base coordinates
    treeZoom = 1;
    treePanX = 0;
    treePanY = 0;
    
    // Build tree to find bounds
    const treeNodes = buildSternBrocotTree(depth);
    
    if (treeNodes.length === 0) {
        updateTreeZoomDisplay();
        drawSectorTree();
        return;
    }
    
    // Find bounding box of all nodes
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    
    treeNodes.forEach(node => {
        minX = Math.min(minX, node.baseX);
        maxX = Math.max(maxX, node.baseX);
        minY = Math.min(minY, node.baseY);
        maxY = Math.max(maxY, node.baseY);
    });
    
    // Add padding
    const padding = 30;
    minX -= padding; minY -= padding;
    maxX += padding; maxY += padding;
    
    // Calculate zoom to fit
    const contentW = maxX - minX;
    const contentH = maxY - minY;
    const zoomX = W / contentW;
    const zoomY = H / contentH;
    treeZoom = Math.min(zoomX, zoomY, 3); // Cap at 3x
    
    // Center content
    const centerContentX = (minX + maxX) / 2;
    const centerContentY = (minY + maxY) / 2;
    treePanX = W/2 - centerContentX * treeZoom;
    treePanY = H/2 - centerContentY * treeZoom;
    
    updateTreeZoomDisplay();
    drawSectorTree();
}

function handleTreeCanvasClick(e) {
    // Ignore if we just finished dragging
    if (treeIsDragging) return;
    
    const canvas = e.target;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    const depth = +document.getElementById('treeDepth').value;
    
    const treeNodes = buildSternBrocotTree(depth);
    
    // Find closest node (positions already include zoom/pan)
    let closest = null;
    let minDist = 20 * treeZoom; // Scale hit distance with zoom
    
    treeNodes.forEach(node => {
        const dist = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);
        if (dist < minDist) {
            minDist = dist;
            closest = node;
        }
    });
    
    if (closest) {
        // Create a point object similar to ring points
        const point = {
            r: closest.r,
            m: closest.m,
            sector: getSector(closest.r, closest.m),
            isPrime: isPrime(closest.m)
        };
        
        selectedTreePoint = point;
        updateTreePathInfo(point);
        
        // Trigger harmonic
        triggerGlobalHarmonic(closest.r, closest.m, point);
        
        // Redraw tree with this node highlighted
        const animate = document.getElementById('animatePath').checked;
        if (animate) {
            animateTreePath(point);
        } else {
            drawSectorTree();
        }
    }
}

// GAP ANALYSIS
function updateGapAnalysis() {
    if(state.gaps.length===0) { document.getElementById('gapStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const gaps = state.gaps.map(g=>g.gap);
    const n = gaps.length;
    const sum = gaps.reduce((a,b)=>a+b,0);
    const mean = sum / n;
    const sorted = [...gaps].sort((a,b)=>a-b);
    const median = sorted[Math.floor(n/2)];
    const maxGap = sorted[n-1];
    const minGap = sorted[0];
    const variance = gaps.reduce((s,g) => s + (g-mean)**2, 0) / n;
    const stdDev = Math.sqrt(variance);
    const skewness = gaps.reduce((s,g) => s + Math.pow((g-mean)/stdDev, 3), 0) / n;
    const kurtosis = gaps.reduce((s,g) => s + Math.pow((g-mean)/stdDev, 4), 0) / n - 3;
    
    // Expected average gap: 1/|F_N| where |F_N| ~ 3N¬≤/œÄ¬≤
    const expectedAvgGap = (Math.PI * Math.PI) / (3 * state.nMax * state.nMax);
    const expectedFN = 3 * state.nMax * state.nMax / (Math.PI * Math.PI);
    
    // Gap ratio (max/min)
    const gapRatio = maxGap / minGap;
    
    // Count gaps by sector
    const gapsBySector = {};
    state.gaps.forEach(g => {
        const s = g.sector || 1;
        gapsBySector[s] = (gapsBySector[s] || 0) + 1;
    });
    
    // Largest denominator product
    const maxDenomProd = state.gaps.reduce((max, g) => g.denomProduct > max ? g.denomProduct : max, 0);
    const minDenomProd = state.gaps.reduce((min, g) => g.denomProduct < min ? g.denomProduct : min, Infinity);
    
    // Verification: sum of all gaps should equal 1 (for full Farey sequence)
    const sumCheck = sum.toFixed(6);
    
    // Q1, Q3 for IQR
    const q1 = sorted[Math.floor(n/4)];
    const q3 = sorted[Math.floor(3*n/4)];
    const iqr = q3 - q1;
    
    document.getElementById('gapStats').innerHTML = 
        '<div class="stat-card"><div class="stat-value">' + n + '</div><div class="stat-label">Total Gaps</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + Math.round(expectedFN) + '</div><div class="stat-label">Expected |F_N|</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + sumCheck + '</div><div class="stat-label">Sum (should‚âà1)</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + mean.toExponential(3) + '</div><div class="stat-label">Mean Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + expectedAvgGap.toExponential(3) + '</div><div class="stat-label">Expected 1/|F_N|</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + ((mean/expectedAvgGap)*100).toFixed(1) + '%</div><div class="stat-label">Mean/Expected</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + median.toExponential(3) + '</div><div class="stat-label">Median</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + stdDev.toExponential(3) + '</div><div class="stat-label">Std Dev</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (stdDev/mean*100).toFixed(1) + '%</div><div class="stat-label">CV (œÉ/Œº)</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#ef4444">' + maxGap.toExponential(3) + '</div><div class="stat-label">Max Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#22c55e">' + minGap.toExponential(3) + '</div><div class="stat-label">Min Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + gapRatio.toFixed(1) + '</div><div class="stat-label">Max/Min Ratio</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + q1.toExponential(2) + '</div><div class="stat-label">Q1 (25%)</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + q3.toExponential(2) + '</div><div class="stat-label">Q3 (75%)</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + iqr.toExponential(2) + '</div><div class="stat-label">IQR</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + skewness.toFixed(3) + '</div><div class="stat-label">Skewness</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + kurtosis.toFixed(3) + '</div><div class="stat-label">Excess Kurtosis</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + minDenomProd + '</div><div class="stat-label">Min bd Product</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + maxDenomProd + '</div><div class="stat-label">Max bd Product</div></div>';
    
    // Gap Distribution - Gradient colored histogram
    const bins = 20;
    const bw = (maxGap - minGap) / bins;
    const hist = new Array(bins).fill(0);
    gaps.forEach(g => { const b = Math.min(bins-1, Math.floor((g-minGap)/bw)); hist[b]++; });
    
    const gradientColors = hist.map((_, i) => {
        const ratio = i / (bins - 1);
        const r = Math.round(34 + ratio * (239 - 34));
        const g = Math.round(197 - ratio * (197 - 68));
        const b = Math.round(94 - ratio * (94 - 68));
        return 'rgba(' + r + ',' + g + ',' + b + ',0.8)';
    });
    
    if(state.charts.gapDist) state.charts.gapDist.destroy();
    state.charts.gapDist = new Chart(document.getElementById('gapDistChart'), {
        type: 'bar',
        data: {
            labels: hist.map((_, i) => (minGap + i * bw).toExponential(1)),
            datasets: [{
                label: 'Frequency',
                data: hist,
                backgroundColor: gradientColors,
                borderColor: gradientColors.map(c => c.replace('0.8', '1')),
                borderWidth: 1,
                borderRadius: 4
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Gap Size Distribution (Small to Large)', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8', maxRotation: 45, font: { size: 9 } },
                    grid: { color: '#334155' }
                },
                y: { 
                    title: { display: true, text: 'Count', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Gap vs Denom Product - Scatter with theoretical curve
    const sample = state.gaps.slice(0, 500);
    const scatterData = sample.map(g => ({ x: g.left.m * g.right.m, y: g.gap }));
    
    // Generate theoretical curve points
    const maxProd = sample.reduce((max, g) => {const v = g.left.m * g.right.m; return v > max ? v : max;}, 0);
    const theoreticalPoints = [];
    for (let p = 4; p <= maxProd; p += Math.max(1, Math.floor(maxProd / 100))) {
        theoreticalPoints.push({ x: p, y: 1 / p });
    }
    
    if(state.charts.gapVsDenom) state.charts.gapVsDenom.destroy();
    state.charts.gapVsDenom = new Chart(document.getElementById('gapVsDenomChart'), {
        type: 'scatter',
        data: {
            datasets: [
                {
                    label: 'Actual Gaps',
                    data: scatterData,
                    backgroundColor: scatterData.map(d => {
                        const ratio = Math.min(1, d.y * 1000);
                        return 'rgba(' + Math.round(99 + ratio * 140) + ',' + Math.round(102 - ratio * 50) + ',' + Math.round(241 - ratio * 100) + ',0.6)';
                    }),
                    pointRadius: 3,
                    pointHoverRadius: 6
                },
                {
                    label: 'Theoretical 1/(bd)',
                    data: theoreticalPoints,
                    type: 'line',
                    borderColor: '#22c55e',
                    borderWidth: 3,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { labels: { color: '#94a3b8' } },
                title: { display: true, text: 'Gap = 1/(b√ód) Verification', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Denominator Product (b√ód)', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                },
                y: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Gap Position Chart - where gaps occur in [0,1]
    const positionData = state.gaps.slice(0, 300).map(g => ({
        x: g.left.value,
        y: g.gap
    }));
    
    if(state.charts.gapPosition) state.charts.gapPosition.destroy();
    state.charts.gapPosition = new Chart(document.getElementById('gapPositionChart'), {
        type: 'bar',
        data: {
            labels: positionData.map(d => d.x.toFixed(3)),
            datasets: [{
                label: 'Gap at Position',
                data: positionData.map(d => d.y),
                backgroundColor: positionData.map(d => `hsla(${d.x * 360}, 70%, 55%, 0.7)`),
                borderWidth: 0
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Gap Sizes Along [0,1]', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    title: { display: true, text: 'Position in [0,1]', color: '#94a3b8' },
                    ticks: { display: false },
                    grid: { color: '#334155' }
                },
                y: { 
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Gap Size vs Position Scatter
    const scatterPosData = state.gaps.slice(0, 500).map(g => ({
        x: (g.left.value + g.right.value) / 2,
        y: g.gap
    }));
    
    if(state.charts.gapSizePosition) state.charts.gapSizePosition.destroy();
    state.charts.gapSizePosition = new Chart(document.getElementById('gapSizePositionChart'), {
        type: 'scatter',
        data: {
            datasets: [{
                label: 'Gap Size',
                data: scatterPosData,
                backgroundColor: scatterPosData.map(d => {
                    const h = d.x * 360;
                    const l = 40 + Math.min(d.y * 5000, 30);
                    return `hsla(${h}, 70%, ${l}%, 0.6)`;
                }),
                pointRadius: 3
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Gap Distribution Across Unit Interval', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    min: 0, max: 1,
                    title: { display: true, text: 'Position in [0,1]', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                },
                y: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Gap Size (log)', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Update gap table with more info
    document.querySelector('#gapTable tbody').innerHTML = state.gaps.slice(0, 30).map((g, i) => {
        const match = Math.abs(g.gap - g.theoretical) < 1e-15;
        return '<tr>' +
            '<td>' + (i+1) + '</td>' +
            '<td><strong>' + g.left.r + '/' + g.left.m + '</strong></td>' +
            '<td><strong>' + g.right.r + '/' + g.right.m + '</strong></td>' +
            '<td style="color:#f59e0b">' + g.gap.toExponential(4) + '</td>' +
            '<td style="color:#22c55e">' + g.theoretical.toExponential(4) + '</td>' +
            '<td style="color:' + (match ? '#22c55e' : '#ef4444') + '">' + (match ? 'Yes' : 'No') + '</td>' +
            '</tr>';
    }).join('');
}

// FRANEL-LANDAU
function computeFranel() {
    if(state.farey.length===0) { document.getElementById('franelStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const n = state.farey.length;
    const deviations = state.farey.map((f,k) => ({ k, delta: f.value - (k+1)/n }));
    const sumAbsDelta = deviations.reduce((s,d)=>s+Math.abs(d.delta),0);
    const N = state.nMax;
    
    // Store for alpha slider
    state.franelSumAbsDelta = sumAbsDelta;
    state.franelN = N;
    
    // Additional statistics
    const deltas = deviations.map(d => d.delta);
    const absDeltas = deltas.map(d => Math.abs(d));
    const sumDelta = deltas.reduce((a,b) => a+b, 0);  // Signed sum
    const sumDeltaSq = deltas.reduce((a,d) => a + d*d, 0);
    const meanAbsDelta = sumAbsDelta / n;
    const maxAbsDelta = absDeltas.reduce((max, v) => v > max ? v : max, 0);
    const minAbsDelta = absDeltas.reduce((min, v) => v < min ? v : min, Infinity);
    const maxDelta = deltas.reduce((max, v) => v > max ? v : max, -Infinity);
    const minDelta = deltas.reduce((min, v) => v < min ? v : min, Infinity);
    
    // Variance and std dev of deviations
    const varianceDelta = sumDeltaSq / n;
    const stdDevDelta = Math.sqrt(varianceDelta);
    
    // Expected |F_N| from asymptotic formula
    const expectedFN = 3 * N * N / (Math.PI * Math.PI);
    const fnError = ((n - expectedFN) / expectedFN * 100).toFixed(2);
    
    // Effective exponent estimate
    const effectiveExponent = Math.log(sumAbsDelta) / Math.log(N);
    
    // RH consistency check
    const rhBound = Math.pow(N, 0.5 + 0.01);
    const rhConsistent = sumAbsDelta < rhBound * 10;  // Some slack for finite N
    
    document.getElementById('franelStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${n}</div><div class="stat-label">|F_N| (actual)</div></div>
        <div class="stat-card"><div class="stat-value">${Math.round(expectedFN)}</div><div class="stat-label">|F_N| (expected)</div></div>
        <div class="stat-card"><div class="stat-value">${fnError}%</div><div class="stat-label">|F_N| Error</div></div>
        <div class="stat-card"><div class="stat-value">${sumAbsDelta.toFixed(4)}</div><div class="stat-label">Œ£|Œ¥|</div></div>
        <div class="stat-card"><div class="stat-value">${sumDelta.toExponential(2)}</div><div class="stat-label">Œ£Œ¥ (signed)</div></div>
        <div class="stat-card"><div class="stat-value">${sumDeltaSq.toExponential(3)}</div><div class="stat-label">Œ£Œ¥¬≤</div></div>
        <div class="stat-card"><div class="stat-value">${meanAbsDelta.toExponential(3)}</div><div class="stat-label">Mean |Œ¥|</div></div>
        <div class="stat-card"><div class="stat-value">${stdDevDelta.toExponential(3)}</div><div class="stat-label">Std Dev Œ¥</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#ef4444">${maxAbsDelta.toExponential(3)}</div><div class="stat-label">Max |Œ¥|</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#22c55e">${minAbsDelta.toExponential(3)}</div><div class="stat-label">Min |Œ¥|</div></div>
        <div class="stat-card"><div class="stat-value">${maxDelta.toExponential(3)}</div><div class="stat-label">Max Œ¥ (signed)</div></div>
        <div class="stat-card"><div class="stat-value">${minDelta.toExponential(3)}</div><div class="stat-label">Min Œ¥ (signed)</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.sqrt(N)).toFixed(4)}</div><div class="stat-label">Œ£|Œ¥|/‚àöN</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.pow(N,0.5+0.01)).toFixed(4)}</div><div class="stat-label">Œ£|Œ¥|/N^0.51</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/N).toFixed(6)}</div><div class="stat-label">Œ£|Œ¥|/N</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#06b6d4">${effectiveExponent.toFixed(4)}</div><div class="stat-label">Eff. Exponent</div></div>
        <div class="stat-card"><div class="stat-value" style="color:${rhConsistent ? '#22c55e' : '#ef4444'}">${rhConsistent ? 'Yes' : 'No'}</div><div class="stat-label">RH Consistent</div></div>
    `;
    
    // Update alpha slider display
    updateFranelAlpha();
    
    const sampleRate = Math.max(1, Math.floor(n/200));
    const sampled = deviations.filter((_,i)=>i%sampleRate===0);
    
    if(state.charts.franelDeviation) state.charts.franelDeviation.destroy();
    state.charts.franelDeviation = new Chart(document.getElementById('franelDeviationChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'Œ¥_k',data:sampled.map(d=>d.delta),borderColor:'#6366f1',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    let cumSum = 0;
    const cumData = sampled.map(d => { cumSum += Math.abs(d.delta)*sampleRate; return cumSum/Math.sqrt(d.k+1); });
    if(state.charts.franelCumulative) state.charts.franelCumulative.destroy();
    state.charts.franelCumulative = new Chart(document.getElementById('franelCumulativeChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'Cum|Œ¥|/‚àök',data:cumData,borderColor:'#8b5cf6',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    const alphas = [0.35, 0.4, 0.45, 0.5, 0.52, 0.55, 0.6, 0.65];
    const alphaData = alphas.map(a => sumAbsDelta / Math.pow(N, a));
    if(state.charts.franelAlpha) state.charts.franelAlpha.destroy();
    state.charts.franelAlpha = new Chart(document.getElementById('franelAlphaChart'),{type:'bar',data:{labels:alphas.map(a=>`Œ±=${a}`),datasets:[{label:'Œ£|Œ¥|/N^Œ±',data:alphaData,backgroundColor:alphas.map(a=>a<=0.5?'rgba(239,68,68,0.7)':'rgba(34,197,94,0.7)')}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Log-Log chart - shows growth exponent
    const logLogData = [];
    let runningSum = 0;
    for (let i = 0; i < deviations.length; i++) {
        runningSum += Math.abs(deviations[i].delta);
        if (i > 0 && i % Math.max(1, Math.floor(n/50)) === 0) {
            const effN = Math.ceil((i+1) * N / n);
            logLogData.push({ x: Math.log10(effN), y: Math.log10(runningSum) });
        }
    }
    
    // Theoretical lines for comparison
    const xMin = logLogData[0]?.x || 1;
    const xMax = logLogData[logLogData.length-1]?.x || 2;
    const yIntercept = logLogData[0]?.y || 0;
    const theoreticalHalf = logLogData.map(d => ({ x: d.x, y: yIntercept + 0.5 * (d.x - xMin) }));
    const theoreticalOne = logLogData.map(d => ({ x: d.x, y: yIntercept + 1.0 * (d.x - xMin) }));
    
    if(state.charts.franelLogLog) state.charts.franelLogLog.destroy();
    state.charts.franelLogLog = new Chart(document.getElementById('franelLogLogChart'),{
        type:'scatter',
        data:{
            datasets:[
                {label:'Actual log(Œ£|Œ¥|)',data:logLogData,borderColor:'#06b6d4',backgroundColor:'#06b6d4',pointRadius:3,showLine:true,fill:false},
                {label:'Slope 0.5 (RH bound)',data:theoreticalHalf,borderColor:'#22c55e',borderDash:[5,5],pointRadius:0,showLine:true,fill:false},
                {label:'Slope 1.0',data:theoreticalOne,borderColor:'#ef4444',borderDash:[3,3],pointRadius:0,showLine:true,fill:false}
            ]
        },
        options:{responsive:true,plugins:{legend:{labels:{color:'#94a3b8'}}},scales:{x:{title:{display:true,text:'log‚ÇÅ‚ÇÄ(N)',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{title:{display:true,text:'log‚ÇÅ‚ÇÄ(Œ£|Œ¥|)',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}
    });
}

function updateFranelAlpha() {
    const slider = document.getElementById('franelAlphaSlider');
    const valueSpan = document.getElementById('franelAlphaValue');
    const resultSpan = document.getElementById('franelAlphaResult');
    if (!slider || !valueSpan || !resultSpan) return;
    
    const alpha = parseFloat(slider.value);
    valueSpan.textContent = alpha.toFixed(2);
    
    if (state.franelSumAbsDelta && state.franelN) {
        const normalized = state.franelSumAbsDelta / Math.pow(state.franelN, alpha);
        const bounded = alpha > 0.5;
        resultSpan.textContent = `Œ£|Œ¥|/N^${alpha.toFixed(2)} = ${normalized.toFixed(4)}`;
        resultSpan.style.background = bounded ? 'rgba(34,197,94,0.3)' : 'rgba(239,68,68,0.3)';
        resultSpan.style.color = bounded ? '#22c55e' : '#ef4444';
    }
}

// DEDEKIND
function computeDedekind() {
    const maxK = +document.getElementById('dedekindMaxK').value;
    const data = [];
    for(let k=2; k<=maxK; k++) {
        for(let h=1; h<k; h++) {
            if(gcd(h,k)===1) {
                const s = sawtoothSum(h,k);
                data.push({h,k,s,s12k:12*k*s});
            }
        }
    }
    
    // Statistics
    const sValues = data.map(d => d.s);
    const n = sValues.length;
    const sumS = sValues.reduce((a,b) => a+b, 0);
    const meanS = sumS / n;
    const minS = safeMin(sValues, 0);
    const maxS = safeMax(sValues, 0);
    
    // Variance and std dev
    const varianceS = sValues.reduce((a,s) => a + (s-meanS)**2, 0) / n;
    const stdDevS = Math.sqrt(varianceS);
    
    // Count positive, negative, zero
    const positiveCount = sValues.filter(s => s > 1e-10).length;
    const negativeCount = sValues.filter(s => s < -1e-10).length;
    const zeroCount = sValues.filter(s => Math.abs(s) < 1e-10).length;
    
    // 12k*s(h,k) values - should all be integers
    const s12kValues = data.map(d => d.s12k);
    const s12kIntegers = s12kValues.filter(v => Math.abs(v - Math.round(v)) < 1e-6).length;
    const s12kIntegerPct = (s12kIntegers / n * 100).toFixed(1);
    
    // Min and max of 12k*s
    const min12kS = safeMin(s12kValues, 0);
    const max12kS = safeMax(s12kValues, 0);
    
    // Sum of absolute values
    const sumAbsS = sValues.reduce((a,s) => a + Math.abs(s), 0);
    
    // Median
    const sorted = [...sValues].sort((a,b) => a-b);
    const medianS = sorted[Math.floor(n/2)];
    
    // Expected total coprime pairs up to maxK: Œ£œÜ(k) for k=2 to maxK
    let expectedPairs = 0;
    for(let k=2; k<=maxK; k++) expectedPairs += phi(k);
    
    document.getElementById('dedekindStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${n}</div><div class="stat-label">Total Pairs</div></div>
        <div class="stat-card"><div class="stat-value">${expectedPairs}</div><div class="stat-label">Expected Œ£œÜ(k)</div></div>
        <div class="stat-card"><div class="stat-value">${sumS.toFixed(4)}</div><div class="stat-label">Œ£s(h,k)</div></div>
        <div class="stat-card"><div class="stat-value">${sumAbsS.toFixed(4)}</div><div class="stat-label">Œ£|s(h,k)|</div></div>
        <div class="stat-card"><div class="stat-value">${meanS.toFixed(6)}</div><div class="stat-label">Mean s(h,k)</div></div>
        <div class="stat-card"><div class="stat-value">${medianS.toFixed(6)}</div><div class="stat-label">Median s(h,k)</div></div>
        <div class="stat-card"><div class="stat-value">${stdDevS.toFixed(4)}</div><div class="stat-label">Std Dev</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#22c55e">${minS.toFixed(4)}</div><div class="stat-label">Min s(h,k)</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#ef4444">${maxS.toFixed(4)}</div><div class="stat-label">Max s(h,k)</div></div>
        <div class="stat-card"><div class="stat-value">${(maxS-minS).toFixed(4)}</div><div class="stat-label">Range</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#22c55e">${positiveCount}</div><div class="stat-label">Positive Count</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#ef4444">${negativeCount}</div><div class="stat-label">Negative Count</div></div>
        <div class="stat-card"><div class="stat-value">${zeroCount}</div><div class="stat-label">Zero Count</div></div>
        <div class="stat-card"><div class="stat-value">${s12kIntegerPct}%</div><div class="stat-label">12ks Integer%</div></div>
        <div class="stat-card"><div class="stat-value">${Math.round(min12kS)}</div><div class="stat-label">Min 12ks</div></div>
        <div class="stat-card"><div class="stat-value">${Math.round(max12kS)}</div><div class="stat-label">Max 12ks</div></div>
    `;
    
    document.querySelector('#dedekindTable tbody').innerHTML = data.slice(0,50).map(d=>`<tr><td>${d.h}</td><td>${d.k}</td><td>${d.s.toFixed(4)}</td><td>${d.s12k.toFixed(2)}</td><td>${gcd(d.h,d.k)}</td></tr>`).join('');
    
    // Reciprocity verification table
    const reciprocityData = [];
    for(let k=3; k<=Math.min(maxK, 15); k++) {
        for(let h=2; h<k; h++) {
            if(gcd(h,k)===1) {
                const shk = sawtoothSum(h,k);
                const skh = sawtoothSum(k,h);
                const sum = shk + skh;
                const rhs = -0.25 + (1/12)*(h/k + k/h + 1/(h*k));
                reciprocityData.push({h, k, shk, skh, sum, rhs, match: Math.abs(sum - rhs) < 1e-10});
            }
        }
    }
    
    document.querySelector('#dedekindReciprocityTable tbody').innerHTML = reciprocityData.slice(0,30).map(d => 
        `<tr><td>${d.h}</td><td>${d.k}</td><td>${d.shk.toFixed(6)}</td><td>${d.skh.toFixed(6)}</td><td style="color:#06b6d4">${d.sum.toFixed(6)}</td><td style="color:#f59e0b">${d.rhs.toFixed(6)}</td><td style="color:${d.match ? '#22c55e' : '#ef4444'}">${d.match ? 'Yes' : 'No'}</td></tr>`
    ).join('');
    
    const s1k = [];
    for(let k=2; k<=maxK; k++) { s1k.push({k, s:sawtoothSum(1,k)}); }
    if(state.charts.dedekind) state.charts.dedekind.destroy();
    state.charts.dedekind = new Chart(document.getElementById('dedekindChart'),{type:'line',data:{labels:s1k.map(d=>d.k),datasets:[{label:'s(1,k)',data:s1k.map(d=>d.s),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Distribution of s(h,k) values
    const bins = 20;
    const bw = (maxS - minS) / bins;
    const hist = new Array(bins).fill(0);
    sValues.forEach(s => { const b = Math.min(bins-1, Math.floor((s-minS)/bw)); hist[b]++; });
    
    if(state.charts.dedekindDist) state.charts.dedekindDist.destroy();
    state.charts.dedekindDist = new Chart(document.getElementById('dedekindDistChart'),{
        type:'bar',
        data:{
            labels:hist.map((_,i)=>(minS+i*bw).toFixed(3)),
            datasets:[{label:'Count',data:hist,backgroundColor:'rgba(245,158,11,0.6)',borderColor:'#f59e0b',borderWidth:1}]
        },
        options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8',maxRotation:45,font:{size:9}}},y:{ticks:{color:'#94a3b8'}}}}
    });
    
    // 12k*s(h,k) distribution - should be integers!
    const s12kRounded = data.map(d => Math.round(d.s12k));
    const s12kCounts = {};
    s12kRounded.forEach(v => { s12kCounts[v] = (s12kCounts[v] || 0) + 1; });
    const s12kLabels = Object.keys(s12kCounts).map(Number).sort((a,b) => a-b);
    
    if(state.charts.dedekind12k) state.charts.dedekind12k.destroy();
    state.charts.dedekind12k = new Chart(document.getElementById('dedekind12kChart'),{
        type:'bar',
        data:{
            labels:s12kLabels,
            datasets:[{label:'Count',data:s12kLabels.map(l=>s12kCounts[l]),backgroundColor:'rgba(139,92,246,0.6)',borderColor:'#8b5cf6',borderWidth:1}]
        },
        options:{responsive:true,plugins:{legend:{display:false},title:{display:true,text:'12k*s(h,k) always integer!',color:'#94a3b8',font:{size:11}}},scales:{x:{title:{display:true,text:'12k*s(h,k)',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}
    });
    
    // Heatmap
    const canvas = document.getElementById('dedekindHeatmap'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cellW=W/maxK, cellH=H/maxK;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    data.forEach(d => {
        const norm = (d.s-minS)/(maxS-minS);
        ctx.fillStyle = `hsl(${260-norm*200},70%,50%)`;
        ctx.fillRect(d.h*cellW, d.k*cellH, cellW-1, cellH-1);
    });
}

// CONTINUED FRACTIONS
let selectedCFFraction = null;

function updateCFDisplay() {
    const sector = +document.getElementById('cfSector').value;
    const maxTerms = +document.getElementById('cfMaxTerms').value;
    const residues = (state.residuesBySector[sector]||[]).slice(0, maxTerms);
    
    const cfData = residues.map(res => {
        const cf = toCF(res.r, res.m);
        const freq = harmonicSettings.baseFreq * (res.r / res.m);
        const note = frequencyToNote(freq);
        const mode = getHarmonicMode(res.m);
        const maxA = cf.length > 0 ? Math.max(...cf) : 0;
        return { 
            r: res.r, 
            m: res.m, 
            cf, 
            path: cfPath(cf), 
            len: cf.length, 
            sum: cf.reduce((a,b)=>a+b,0),
            maxA,
            freq,
            note,
            mode
        };
    });
    
    // Store for later use
    window.cfDataCache = cfData;
    
    // Comprehensive Statistics
    if (cfData.length > 0) {
        const lengths = cfData.map(d => d.len);
        const sums = cfData.map(d => d.sum);
        const maxAs = cfData.map(d => d.maxA);
        const allQuotients = cfData.flatMap(d => d.cf);
        
        const avgLen = lengths.reduce((a,b) => a+b, 0) / lengths.length;
        const maxLen = safeMax(lengths, 0);
        const minLen = safeMin(lengths, 0);
        const avgSum = sums.reduce((a,b) => a+b, 0) / sums.length;
        const maxSum = safeMax(sums, 0);
        const avgMaxA = maxAs.reduce((a,b) => a+b, 0) / maxAs.length;
        const globalMaxA = safeMax(maxAs, 0);
        
        // Count quotients equal to 1, 2, 3, etc. (Gauss-Kuzmin)
        const quotientCounts = {};
        allQuotients.forEach(q => { quotientCounts[q] = (quotientCounts[q] || 0) + 1; });
        const totalQuotients = allQuotients.length;
        const ones = quotientCounts[1] || 0;
        const twos = quotientCounts[2] || 0;
        const threes = quotientCounts[3] || 0;
        const fours = quotientCounts[4] || 0;
        const fives = quotientCounts[5] || 0;
        
        // Gauss-Kuzmin theoretical probabilities
        const gkTheory1 = Math.log2(4/3) * 100; // ~41.5%
        const gkTheory2 = Math.log2(9/8) * 100; // ~17.0%
        const gkTheory3 = Math.log2(16/15) * 100; // ~9.3%
        
        // Additional statistics
        const avgQuotient = allQuotients.reduce((a,b) => a+b, 0) / totalQuotients;
        const medianLen = [...lengths].sort((a,b) => a-b)[Math.floor(lengths.length/2)];
        const lenVariance = lengths.reduce((s, l) => s + (l - avgLen)**2, 0) / lengths.length;
        const lenStdDev = Math.sqrt(lenVariance);
        
        // Count palindromic CFs (same forward and backward)
        const palindromes = cfData.filter(d => {
            const cf = d.cf;
            return cf.length > 1 && cf.every((v, i) => v === cf[cf.length - 1 - i]);
        }).length;
        
        // Fibonacci-like CFs (all 1s)
        const fibLike = cfData.filter(d => d.cf.every(a => a === 1)).length;
        
        // CFs starting with specific values
        const startsWithOne = cfData.filter(d => d.cf[0] === 1).length;
        const startsWithTwo = cfData.filter(d => d.cf[0] === 2).length;
        
        document.getElementById('cfStats').innerHTML = `
            <div class="stat-card"><div class="stat-value">${cfData.length}</div><div class="stat-label">Fractions</div></div>
            <div class="stat-card"><div class="stat-value">${totalQuotients}</div><div class="stat-label">Total Quotients</div></div>
            <div class="stat-card"><div class="stat-value">${avgQuotient.toFixed(3)}</div><div class="stat-label">Avg Quotient</div></div>
            <div class="stat-card"><div class="stat-value">${avgLen.toFixed(2)}</div><div class="stat-label">Avg CF Length</div></div>
            <div class="stat-card"><div class="stat-value">${medianLen}</div><div class="stat-label">Median Length</div></div>
            <div class="stat-card"><div class="stat-value">${lenStdDev.toFixed(2)}</div><div class="stat-label">Length Std Dev</div></div>
            <div class="stat-card"><div class="stat-value">${minLen}</div><div class="stat-label">Min Length</div></div>
            <div class="stat-card"><div class="stat-value">${maxLen}</div><div class="stat-label">Max Length</div></div>
            <div class="stat-card"><div class="stat-value">${avgSum.toFixed(2)}</div><div class="stat-label">Avg Œ£a_i</div></div>
            <div class="stat-card"><div class="stat-value">${maxSum}</div><div class="stat-label">Max Œ£a_i</div></div>
            <div class="stat-card"><div class="stat-value">${avgMaxA.toFixed(2)}</div><div class="stat-label">Avg Max(a_i)</div></div>
            <div class="stat-card"><div class="stat-value">${globalMaxA}</div><div class="stat-label">Global Max a_i</div></div>
            <div class="stat-card"><div class="stat-value">${(ones/totalQuotients*100).toFixed(1)}%</div><div class="stat-label">a_i=1 (GK:${gkTheory1.toFixed(1)}%)</div></div>
            <div class="stat-card"><div class="stat-value">${(twos/totalQuotients*100).toFixed(1)}%</div><div class="stat-label">a_i=2 (GK:${gkTheory2.toFixed(1)}%)</div></div>
            <div class="stat-card"><div class="stat-value">${(threes/totalQuotients*100).toFixed(1)}%</div><div class="stat-label">a_i=3 (GK:${gkTheory3.toFixed(1)}%)</div></div>
            <div class="stat-card"><div class="stat-value">${Object.keys(quotientCounts).length}</div><div class="stat-label">Distinct a_i</div></div>
            <div class="stat-card"><div class="stat-value">${fibLike}</div><div class="stat-label">Fib-like [1;1,1...]</div></div>
            <div class="stat-card"><div class="stat-value">${palindromes}</div><div class="stat-label">Palindromic CFs</div></div>
            <div class="stat-card"><div class="stat-value">${startsWithOne}</div><div class="stat-label">Starts with 1</div></div>
            <div class="stat-card"><div class="stat-value">${startsWithTwo}</div><div class="stat-label">Starts with 2</div></div>
        `;
    } else {
        document.getElementById('cfStats').innerHTML = '<div class="stat-card"><div class="stat-label">No data for this sector</div></div>';
    }
    
    document.querySelector('#cfTable tbody').innerHTML = cfData.map((d, idx) => `
        <tr onclick="selectCFFraction(${idx})" style="cursor:pointer;" class="cf-row" data-idx="${idx}">
            <td><strong>${d.r}/${d.m}</strong></td>
            <td style="font-family:monospace;font-size:0.85em;">[${d.cf.join('; ')}]</td>
            <td class="cf-path" style="max-width:120px;overflow:hidden;text-overflow:ellipsis;">${d.path.slice(0,15)}${d.path.length>15?'...':''}</td>
            <td>${d.len}</td>
            <td>${d.sum}</td>
            <td>${d.maxA}</td>
            <td style="color:#8b5cf6;">${d.freq.toFixed(1)}</td>
            <td>
                <button onclick="event.stopPropagation(); playCFFractionByIndex(${idx})" style="padding:3px 8px;font-size:10px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:3px;color:white;cursor:pointer;">‚ñ∂</button>
            </td>
        </tr>
    `).join('');
    
    // CF Length Distribution
    const lenDist = {};
    cfData.forEach(d => { lenDist[d.len] = (lenDist[d.len]||0)+1; });
    const lenLabels = Object.keys(lenDist).sort((a,b)=>a-b);
    if(state.charts.cfLength) state.charts.cfLength.destroy();
    state.charts.cfLength = new Chart(document.getElementById('cfLengthChart'),{type:'bar',data:{labels:lenLabels,datasets:[{label:'Count',data:lenLabels.map(l=>lenDist[l]),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{title:{display:true,text:'CF Length',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{title:{display:true,text:'Count',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}});
    
    // First Partial Quotient Distribution
    const firstDist = {};
    cfData.forEach(d => { if(d.cf.length>1) { const f=d.cf[1]; firstDist[f]=(firstDist[f]||0)+1; } });
    const firstLabels = Object.keys(firstDist).sort((a,b)=>a-b).slice(0,15);
    if(state.charts.cfFirst) state.charts.cfFirst.destroy();
    state.charts.cfFirst = new Chart(document.getElementById('cfFirstChart'),{type:'bar',data:{labels:firstLabels,datasets:[{label:'Count',data:firstLabels.map(l=>firstDist[l]),backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{title:{display:true,text:'a‚ÇÅ value',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{title:{display:true,text:'Count',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}});
    
    // Sum of Partial Quotients Distribution
    const sumDist = {};
    cfData.forEach(d => { const bin = Math.floor(d.sum/5)*5; sumDist[bin] = (sumDist[bin]||0)+1; });
    const sumLabels = Object.keys(sumDist).map(Number).sort((a,b)=>a-b);
    if(state.charts.cfSum) state.charts.cfSum.destroy();
    state.charts.cfSum = new Chart(document.getElementById('cfSumChart'),{type:'bar',data:{labels:sumLabels.map(l=>`${l}-${l+4}`),datasets:[{label:'Count',data:sumLabels.map(l=>sumDist[l]),backgroundColor:'rgba(34,197,94,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{title:{display:true,text:'Œ£a_i range',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{title:{display:true,text:'Count',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}});
    
    // Max Partial Quotient Distribution
    const maxDist = {};
    cfData.forEach(d => { maxDist[d.maxA] = (maxDist[d.maxA]||0)+1; });
    const maxLabels = Object.keys(maxDist).map(Number).sort((a,b)=>a-b).slice(0,15);
    if(state.charts.cfMax) state.charts.cfMax.destroy();
    state.charts.cfMax = new Chart(document.getElementById('cfMaxChart'),{type:'bar',data:{labels:maxLabels,datasets:[{label:'Count',data:maxLabels.map(l=>maxDist[l]),backgroundColor:'rgba(245,158,11,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{title:{display:true,text:'Max(a_i)',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{title:{display:true,text:'Count',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}});
    
    // Clear selection info
    if (!selectedCFFraction) {
        document.getElementById('cfSelectedInfo').innerHTML = '<div style="color:#64748b; grid-column:1/-1;">Click a row in the table below to select a fraction</div>';
    }
}

function selectCFFraction(idx) {
    const cfData = window.cfDataCache;
    if (!cfData || !cfData[idx]) return;
    
    const d = cfData[idx];
    selectedCFFraction = d;
    
    // Highlight selected row
    document.querySelectorAll('.cf-row').forEach(row => row.style.background = '');
    document.querySelector(`.cf-row[data-idx="${idx}"]`).style.background = 'rgba(99,102,241,0.2)';
    
    // Update selection info panel
    document.getElementById('cfSelectedInfo').innerHTML = `
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Fraction</div>
            <div style="color:#22c55e; font-size:1.5em; font-weight:bold;">${d.r}/${d.m}</div>
            <div style="color:#64748b; font-size:0.85em;">= ${(d.r/d.m).toFixed(8)}</div>
        </div>
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Continued Fraction</div>
            <div style="color:#8b5cf6; font-size:1.1em; font-family:monospace;">[${d.cf.join('; ')}]</div>
            <div style="color:#64748b; font-size:0.85em;">Length: ${d.len} terms</div>
        </div>
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Stern-Brocot Path</div>
            <div style="font-size:0.9em; word-break:break-all;">${formatColoredPath(d.path)}</div>
        </div>
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Frequency</div>
            <div style="color:#8b5cf6; font-size:1.3em; font-weight:bold;">${d.freq.toFixed(2)} Hz</div>
            <div style="color:#22c55e;">${d.note.name} <span class="mode-badge ${d.mode.class}" style="font-size:9px;">${d.mode.name}</span></div>
        </div>
        <div style="display:flex; flex-direction:column; gap:6px; justify-content:center;">
            <button onclick="playCFSelected()" style="padding:8px 12px;font-size:12px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;font-weight:bold;">‚ñ∂ Play Fraction</button>
            <button onclick="playCFConvergents()" style="padding:8px 12px;font-size:12px;background:#6366f1;border:none;border-radius:4px;color:white;cursor:pointer;">‚ô™ Convergents</button>
        </div>
    `;
    
    // Trigger global harmonic
    triggerGlobalHarmonic(d.r, d.m);
}

function formatColoredPath(path) {
    if (!path || path.length === 0) return '<span style="color:#22c55e;">ROOT</span>';
    const maxShow = 30;
    const truncated = path.length > maxShow;
    const showPath = truncated ? path.slice(0, maxShow) : path;
    
    const colored = showPath.split('').map(c => 
        `<span style="color:${c === 'L' ? '#ef4444' : '#3b82f6'}; font-weight:bold;">${c}</span>`
    ).join('');
    
    return colored + (truncated ? '<span style="color:#64748b;">...</span>' : '');
}

function playCFFractionByIndex(idx) {
    const cfData = window.cfDataCache;
    if (!cfData || !cfData[idx]) return;
    
    const d = cfData[idx];
    playFraction(d.r, d.m, 0.6);
    
    // Also select it
    selectCFFraction(idx);
}

function playCFSelected() {
    if (!selectedCFFraction) {
        alert('Select a fraction from the table first');
        return;
    }
    playFraction(selectedCFFraction.r, selectedCFFraction.m, 0.8);
}

function playCFConvergents() {
    if (!selectedCFFraction) {
        alert('Select a fraction from the table first');
        return;
    }
    
    initAudioContext();
    
    // Compute convergents from the continued fraction
    const cf = selectedCFFraction.cf;
    const convergents = [];
    
    let p_prev = 1, q_prev = 0;
    let p_curr = cf[0], q_curr = 1;
    
    convergents.push({ r: p_curr, m: q_curr });
    
    for (let i = 1; i < cf.length; i++) {
        const a = cf[i];
        const p_next = a * p_curr + p_prev;
        const q_next = a * q_curr + q_prev;
        
        convergents.push({ r: p_next, m: q_next });
        
        p_prev = p_curr;
        q_prev = q_curr;
        p_curr = p_next;
        q_curr = q_next;
    }
    
    // Play each convergent
    let delay = 0;
    convergents.forEach((conv, i) => {
        setTimeout(() => {
            playFraction(conv.r, conv.m, 0.35);
            
            // Show which convergent is playing
            const info = document.getElementById('cfSelectedInfo');
            if (info) {
                let indicator = info.querySelector('.playing-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.className = 'playing-indicator';
                    indicator.style.cssText = 'grid-column:1/-1; margin-top:10px; padding:8px; background:#0f172a; border-radius:4px; text-align:center;';
                    info.appendChild(indicator);
                }
                indicator.innerHTML = `<span style="color:#22c55e;">Playing convergent ${i+1}/${convergents.length}:</span> <strong style="color:#8b5cf6;">${conv.r}/${conv.m}</strong> <span style="color:#64748b;">= ${(conv.r/conv.m).toFixed(6)}</span>`;
            }
        }, delay);
        delay += 400;
    });
    
    // Clean up indicator
    setTimeout(() => {
        const indicator = document.querySelector('#cfSelectedInfo .playing-indicator');
        if (indicator) {
            indicator.innerHTML = '<span style="color:#22c55e;">‚úì Played all convergents</span>';
            setTimeout(() => indicator.remove(), 1500);
        }
    }, delay + 500);
}

function playCFAll() {
    const cfData = window.cfDataCache;
    if (!cfData || cfData.length === 0) {
        alert('No fractions to play. Run computation first.');
        return;
    }
    
    initAudioContext();
    
    // Sort by value for ascending scale
    const sorted = [...cfData].sort((a, b) => (a.r / a.m) - (b.r / b.m));
    const toPlay = sorted.slice(0, 20); // Limit to 20 for reasonable duration
    
    let delay = 0;
    toPlay.forEach((d, i) => {
        setTimeout(() => {
            playFraction(d.r, d.m, 0.25);
            
            // Highlight row
            document.querySelectorAll('.cf-row').forEach(row => {
                const idx = parseInt(row.dataset.idx);
                if (cfData[idx] && cfData[idx].r === d.r && cfData[idx].m === d.m) {
                    row.style.background = 'rgba(34,197,94,0.3)';
                    setTimeout(() => row.style.background = '', 200);
                }
            });
        }, delay);
        delay += 200;
    });
}

// PSL(2,Z)
function computePSL() {
    const maxDenom = +document.getElementById('pslMaxDenom').value;
    const farey = [{r:0,m:1}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) farey.push({r,m});
        }
    }
    farey.push({r:1,m:1});
    farey.sort((a,b)=>a.r/a.m - b.r/b.m);
    
    let html = '';
    const matrices = [];
    for(let i=0; i<farey.length-1; i++) {
        const a=farey[i].r, b=farey[i].m, c=farey[i+1].r, d=farey[i+1].m;
        const det = a*d - b*c;
        matrices.push({a,b,c,d,det,left:`${a}/${b}`,right:`${c}/${d}`});
    }
    
    // Statistics
    const totalFractions = farey.length;
    const totalPairs = matrices.length;
    const detPlus1 = matrices.filter(m => m.det === -1).length;  // ad-bc = -1 for consecutive
    const detMinus1 = matrices.filter(m => m.det === 1).length;
    const verified = matrices.every(m=>Math.abs(m.det)===1);
    
    // Circle statistics
    const circles = farey.map(f => ({
        r: f.r,
        m: f.m,
        x: f.r / f.m,
        radius: 1 / (2 * f.m * f.m)
    }));
    const radii = circles.map(c => c.radius);
    const totalArea = radii.reduce((a, r) => a + Math.PI * r * r, 0);
    const maxRadius = radii.reduce((max, v) => v > max ? v : max, 0);
    const minRadius = radii.reduce((min, v) => v < min ? v : min, Infinity);
    const avgRadius = radii.reduce((a,b) => a+b, 0) / radii.length;
    
    // Count tangencies
    let tangencyCount = 0;
    for (let i = 0; i < circles.length; i++) {
        for (let j = i+1; j < circles.length; j++) {
            const dx = circles[j].x - circles[i].x;
            const sumR = circles[i].radius + circles[j].radius;
            const dist = Math.sqrt(dx*dx + (circles[j].radius - circles[i].radius)**2);
            if (Math.abs(dist - sumR) < 0.0001) tangencyCount++;
        }
    }
    
    document.getElementById('pslStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${totalFractions}</div><div class="stat-label">|F_N| Fractions</div></div>
        <div class="stat-card"><div class="stat-value">${totalPairs}</div><div class="stat-label">Neighbor Pairs</div></div>
        <div class="stat-card"><div class="stat-value">${circles.length}</div><div class="stat-label">Ford Circles</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#22c55e">${verified ? 'Yes' : 'No'}</div><div class="stat-label">All |det|=1</div></div>
        <div class="stat-card"><div class="stat-value">${detPlus1}</div><div class="stat-label">det = -1</div></div>
        <div class="stat-card"><div class="stat-value">${detMinus1}</div><div class="stat-label">det = +1</div></div>
        <div class="stat-card"><div class="stat-value">${tangencyCount}</div><div class="stat-label">Tangencies</div></div>
        <div class="stat-card"><div class="stat-value">${(tangencyCount / totalPairs * 100).toFixed(1)}%</div><div class="stat-label">Tangency Rate</div></div>
        <div class="stat-card"><div class="stat-value">${maxRadius.toFixed(4)}</div><div class="stat-label">Max Radius</div></div>
        <div class="stat-card"><div class="stat-value">${minRadius.toExponential(2)}</div><div class="stat-label">Min Radius</div></div>
        <div class="stat-card"><div class="stat-value">${avgRadius.toExponential(2)}</div><div class="stat-label">Avg Radius</div></div>
        <div class="stat-card"><div class="stat-value">${(maxRadius / minRadius).toFixed(1)}</div><div class="stat-label">Radius Ratio</div></div>
        <div class="stat-card"><div class="stat-value">${totalArea.toFixed(4)}</div><div class="stat-label">Total Circle Area</div></div>
        <div class="stat-card"><div class="stat-value">${(totalArea / 1 * 100).toFixed(2)}%</div><div class="stat-label">Area Coverage</div></div>
        <div class="stat-card"><div class="stat-value">${maxDenom}</div><div class="stat-label">Max Denom</div></div>
        <div class="stat-card"><div class="stat-value">${(1/(2*maxDenom*maxDenom)).toExponential(2)}</div><div class="stat-label">Smallest r=1/(2N¬≤)</div></div>
    `;
    
    // Matrices display (show more)
    html = matrices.slice(0, 50).map(m => 
        `<div class="matrix-display" style="display:inline-block;margin:4px;padding:6px;background:#1e1b4b;border-radius:4px;font-size:11px;">
            <span style="color:#64748b">${m.left}‚Üí${m.right}:</span> 
            <span style="color:#8b5cf6">[${m.a},${m.c}; ${m.b},${m.d}]</span> 
            <span style="color:${m.det===-1?'#22c55e':'#f59e0b'}">det=${m.det}</span>
        </div>`
    ).join('');
    if (matrices.length > 50) html += `<div style="color:#64748b;margin-top:8px;">... and ${matrices.length - 50} more pairs</div>`;
    document.getElementById('pslMatrices').innerHTML = html;
    
    document.getElementById('pslVerification').innerHTML = `
        <div class="info-badge ${verified?'success':'warning'}" style="font-size:1.2em;padding:12px;">${verified?'‚úì All determinants = ¬±1':'‚ö† Some errors detected'}</div>
        <p style="margin-top:12px;font-size:0.9em;">Verified ${matrices.length} neighbor pairs.</p>
        <p style="font-size:0.85em;color:#94a3b8;">The condition |ad-bc|=1 confirms these are valid Farey neighbors and the matrices belong to SL(2,‚Ñ§).</p>
    `;
    
    // Ford circles - enhanced
    const canvas = document.getElementById('fordCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, margin=40, scale=W-2*margin;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    
    // Draw x-axis
    ctx.strokeStyle='#475569'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(margin,H-25); ctx.lineTo(W-margin,H-25); ctx.stroke();
    
    // Draw axis labels
    ctx.fillStyle='#64748b'; ctx.font='9px system-ui'; ctx.textAlign='center';
    for (let x = 0; x <= 1; x += 0.25) {
        const px = margin + x * scale;
        ctx.fillText(x.toFixed(2), px, H-10);
        ctx.beginPath(); ctx.moveTo(px, H-25); ctx.lineTo(px, H-22); ctx.stroke();
    }
    
    // Draw Ford circles with color by denominator
    farey.forEach(f => {
        const x = margin + (f.r/f.m)*scale;
        const radius = Math.max(1, scale/(2*f.m*f.m));
        const hue = (f.m * 30) % 360;
        
        ctx.beginPath(); ctx.arc(x, H-25-radius, radius, 0, 2*Math.PI);
        ctx.fillStyle = `hsla(${hue},60%,50%,0.3)`; ctx.fill();
        ctx.strokeStyle = `hsl(${hue},70%,60%)`; ctx.lineWidth = 1; ctx.stroke();
        
        // Label larger circles
        if (radius > 8) {
            ctx.fillStyle = '#fff'; ctx.font = '8px system-ui';
            ctx.fillText(`${f.r}/${f.m}`, x, H-25-radius);
        }
    });
    
    // Tangency graph - number of tangencies per fraction
    const tangenciesPerFraction = farey.map((f, i) => {
        let count = 0;
        // Count neighbors (consecutive fractions are always tangent)
        if (i > 0) count++;
        if (i < farey.length - 1) count++;
        return { label: `${f.r}/${f.m}`, count, m: f.m };
    });
    
    const tangencyData = tangenciesPerFraction.slice(0, 30);
    if(state.charts.fordTangency) state.charts.fordTangency.destroy();
    state.charts.fordTangency = new Chart(document.getElementById('fordTangencyChart'),{
        type:'bar',
        data:{
            labels:tangencyData.map(d=>d.label),
            datasets:[{label:'Tangencies',data:tangencyData.map(d=>d.count),backgroundColor:tangencyData.map(d=>`hsla(${d.m*30%360},60%,50%,0.7)`)}]
        },
        options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8',maxRotation:45,font:{size:8}}},y:{ticks:{color:'#94a3b8'}}}}
    });
    
    // Radius distribution
    const radiusBins = {};
    circles.forEach(c => {
        const bin = Math.floor(-Math.log10(c.radius));
        radiusBins[bin] = (radiusBins[bin] || 0) + 1;
    });
    const radiusLabels = Object.keys(radiusBins).map(Number).sort((a,b)=>a-b);
    
    if(state.charts.fordRadius) state.charts.fordRadius.destroy();
    state.charts.fordRadius = new Chart(document.getElementById('fordRadiusChart'),{
        type:'bar',
        data:{
            labels:radiusLabels.map(l=>`10^-${l}`),
            datasets:[{label:'Count',data:radiusLabels.map(l=>radiusBins[l]),backgroundColor:'rgba(99,102,241,0.7)'}]
        },
        options:{responsive:true,plugins:{legend:{display:false},title:{display:true,text:'Radius Scale Distribution',color:'#94a3b8',font:{size:11}}},scales:{x:{title:{display:true,text:'Radius Order',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{title:{display:true,text:'Count',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}
    });
}

// EULER PRODUCT
function computeEulerProduct() {
    const maxP = +document.getElementById('eulerMaxP').value;
    const maxN = +(document.getElementById('eulerMaxN')?.value || maxP);
    const primes = [];
    for(let n=2; n<=maxP; n++) if(isPrime(n)) primes.push(n);
    
    let product = 1, sum = 0;
    const productData = [], sumData = [];
    const productErrorData = [], sumErrorData = [];
    const target = 6/(Math.PI*Math.PI);
    const targetSum = Math.PI*Math.PI/6;
    
    let termsHtml = '';
    primes.forEach((p,i) => {
        const term = 1 - 1/(p*p);
        product *= term;
        const error = Math.abs(product - target) / target;
        productData.push({p, product, error});
        productErrorData.push({x: p, y: error});
        termsHtml += `<span class="euler-term prime" style="display:inline-block;margin:2px;padding:3px 6px;background:#1e1b4b;border-radius:3px;font-size:10px;">(1-1/${p}¬≤) = ${term.toFixed(6)}</span>`;
    });
    
    for(let n=1; n<=maxN; n++) {
        sum += 1/(n*n);
        const error = Math.abs(sum - targetSum) / targetSum;
        sumData.push({n, sum, error});
        sumErrorData.push({x: n, y: error});
    }
    
    // Comprehensive statistics
    const productError = (product - target) / target * 100;
    const sumError = (sum - targetSum) / targetSum * 100;
    const productAbsError = Math.abs(product - target);
    const sumAbsError = Math.abs(sum - targetSum);
    
    // Estimate remaining product contribution
    const remainingProduct = target / product;
    const remainingSum = targetSum - sum;
    
    // Twin primes in range
    const twinPrimes = primes.filter((p, i) => i > 0 && p - primes[i-1] === 2).length;
    
    // Product of first k primes (primorial)
    const primorial = primes.slice(0, Math.min(10, primes.length)).reduce((a, p) => a * p, 1);
    
    // Prime density œÄ(n)/n
    const primeDensity = primes.length / maxP;
    const expectedDensity = 1 / Math.log(maxP);  // PNT approximation
    
    // Sum of 1/p for primes
    const harmonicPrimeSum = primes.reduce((s, p) => s + 1/p, 0);
    
    // Convergence rate estimate
    const lastTerm = 1 - 1/(primes[primes.length-1]**2);
    const convergenceRate = 1 - lastTerm;
    
    // Sophie Germain primes (p where 2p+1 is also prime)
    const sophieGermain = primes.filter(p => isPrime(2*p + 1)).length;
    
    document.getElementById('eulerStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primes.length}</div><div class="stat-label">Primes ‚â§ ${maxP}</div></div>
        <div class="stat-card"><div class="stat-value">${(primeDensity*100).toFixed(2)}%</div><div class="stat-label">Prime Density</div></div>
        <div class="stat-card"><div class="stat-value">${(expectedDensity*100).toFixed(2)}%</div><div class="stat-label">Expected 1/ln(N)</div></div>
        <div class="stat-card"><div class="stat-value">${twinPrimes}</div><div class="stat-label">Twin Prime Pairs</div></div>
        <div class="stat-card"><div class="stat-value">${sophieGermain}</div><div class="stat-label">Sophie Germain</div></div>
        <div class="stat-card"><div class="stat-value">${product.toFixed(8)}</div><div class="stat-label">‚àè(1-1/p¬≤)</div></div>
        <div class="stat-card"><div class="stat-value">${target.toFixed(8)}</div><div class="stat-label">6/œÄ¬≤ Target</div></div>
        <div class="stat-card"><div class="stat-value" style="color:${Math.abs(productError)<1?'#22c55e':'#f59e0b'}">${productError.toFixed(4)}%</div><div class="stat-label">Product Error</div></div>
        <div class="stat-card"><div class="stat-value">${productAbsError.toExponential(4)}</div><div class="stat-label">Abs Error (Prod)</div></div>
        <div class="stat-card"><div class="stat-value">${remainingProduct.toFixed(8)}</div><div class="stat-label">Remaining Factor</div></div>
        <div class="stat-card"><div class="stat-value">${sum.toFixed(8)}</div><div class="stat-label">Œ£1/n¬≤ (n‚â§${maxN})</div></div>
        <div class="stat-card"><div class="stat-value">${targetSum.toFixed(8)}</div><div class="stat-label">œÄ¬≤/6 Target</div></div>
        <div class="stat-card"><div class="stat-value" style="color:${Math.abs(sumError)<1?'#22c55e':'#f59e0b'}">${sumError.toFixed(4)}%</div><div class="stat-label">Sum Error</div></div>
        <div class="stat-card"><div class="stat-value">${sumAbsError.toExponential(4)}</div><div class="stat-label">Abs Error (Sum)</div></div>
        <div class="stat-card"><div class="stat-value">${remainingSum.toExponential(4)}</div><div class="stat-label">Remaining Sum</div></div>
        <div class="stat-card"><div class="stat-value">${(1/product).toFixed(8)}</div><div class="stat-label">Œ∂(2) Approx</div></div>
        <div class="stat-card"><div class="stat-value">${harmonicPrimeSum.toFixed(4)}</div><div class="stat-label">Œ£1/p (primes)</div></div>
        <div class="stat-card"><div class="stat-value">${primes[primes.length-1] || '-'}</div><div class="stat-label">Largest Prime</div></div>
        <div class="stat-card"><div class="stat-value">${convergenceRate.toExponential(2)}</div><div class="stat-label">Last Term Contrib</div></div>
    `;
    
    document.getElementById('eulerTerms').innerHTML = termsHtml;
    
    // Product convergence chart
    if(state.charts.eulerProduct) state.charts.eulerProduct.destroy();
    state.charts.eulerProduct = new Chart(document.getElementById('eulerProductChart'),{
        type:'line',
        data:{
            labels:productData.map(d=>d.p),
            datasets:[
                {label:'‚àè(1-1/p¬≤)',data:productData.map(d=>d.product),borderColor:'#6366f1',backgroundColor:'rgba(99,102,241,0.1)',fill:true,tension:0.1},
                {label:'6/œÄ¬≤',data:productData.map(()=>target),borderColor:'#22c55e',borderDash:[5,5],fill:false,pointRadius:0}
            ]
        },
        options:{responsive:true,plugins:{legend:{labels:{color:'#94a3b8'}}},scales:{x:{title:{display:true,text:'Prime p',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{title:{display:true,text:'Product Value',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}
    });
    
    // Sum convergence chart
    if(state.charts.eulerSum) state.charts.eulerSum.destroy();
    state.charts.eulerSum = new Chart(document.getElementById('eulerSumChart'),{
        type:'line',
        data:{
            labels:sumData.filter((_,i) => i % Math.max(1, Math.floor(sumData.length/100)) === 0).map(d=>d.n),
            datasets:[
                {label:'Œ£1/n¬≤',data:sumData.filter((_,i) => i % Math.max(1, Math.floor(sumData.length/100)) === 0).map(d=>d.sum),borderColor:'#8b5cf6',backgroundColor:'rgba(139,92,246,0.1)',fill:true,tension:0.1},
                {label:'œÄ¬≤/6',data:sumData.filter((_,i) => i % Math.max(1, Math.floor(sumData.length/100)) === 0).map(()=>targetSum),borderColor:'#22c55e',borderDash:[5,5],fill:false,pointRadius:0}
            ]
        },
        options:{responsive:true,plugins:{legend:{labels:{color:'#94a3b8'}}},scales:{x:{title:{display:true,text:'n',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{title:{display:true,text:'Sum Value',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}
    });
    
    // Product error decay chart
    if(state.charts.eulerProductError) state.charts.eulerProductError.destroy();
    state.charts.eulerProductError = new Chart(document.getElementById('eulerProductErrorChart'),{
        type:'line',
        data:{
            labels:productData.map(d=>d.p),
            datasets:[{label:'Relative Error',data:productData.map(d=>d.error),borderColor:'#ef4444',backgroundColor:'rgba(239,68,68,0.1)',fill:true,tension:0.1}]
        },
        options:{responsive:true,plugins:{legend:{display:false},title:{display:true,text:'Product Error Decay',color:'#94a3b8',font:{size:11}}},scales:{x:{title:{display:true,text:'Prime p',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{type:'logarithmic',title:{display:true,text:'|Error| (log)',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}
    });
    
    // Sum error decay chart
    const sampledSumError = sumErrorData.filter((_,i) => i % Math.max(1, Math.floor(sumErrorData.length/50)) === 0);
    if(state.charts.eulerSumError) state.charts.eulerSumError.destroy();
    state.charts.eulerSumError = new Chart(document.getElementById('eulerSumErrorChart'),{
        type:'line',
        data:{
            labels:sampledSumError.map(d=>d.x),
            datasets:[{label:'Relative Error',data:sampledSumError.map(d=>d.y),borderColor:'#f59e0b',backgroundColor:'rgba(245,158,11,0.1)',fill:true,tension:0.1}]
        },
        options:{responsive:true,plugins:{legend:{display:false},title:{display:true,text:'Sum Error Decay ~ 1/N',color:'#94a3b8',font:{size:11}}},scales:{x:{title:{display:true,text:'n',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{type:'logarithmic',title:{display:true,text:'|Error| (log)',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}
    });
}

// MODULAR
function updateModularAnalysis() {
    const k = +document.getElementById('modK').value;
    const a = +document.getElementById('modA').value;
    
    const filtered = state.allResidues.filter(r => r.m % k === a % k);
    const bySector = {};
    filtered.forEach(r => { if(r.sector) { bySector[r.sector] = (bySector[r.sector]||0)+1; } });
    
    const residueClasses = {};
    for(let i=0; i<k; i++) residueClasses[i] = state.allResidues.filter(r=>r.m%k===i).length;
    
    // Enhanced statistics
    const total = state.allResidues.length;
    const filteredPrimes = filtered.filter(r => r.isPrime).length;
    const expectedFraction = phi(k) > 0 ? 1/k : 0;  // Rough expectation
    
    // Distribution analysis
    const classCounts = Object.values(residueClasses);
    const maxClass = Math.max(...classCounts);
    const minClass = Math.min(...classCounts);
    const avgClass = classCounts.reduce((a,b) => a+b, 0) / classCounts.length;
    const classVariance = classCounts.reduce((s, c) => s + (c - avgClass)**2, 0) / classCounts.length;
    const classStdDev = Math.sqrt(classVariance);
    
    // Coprime residues mod k
    let coprimeClasses = 0;
    for(let i=0; i<k; i++) if(gcd(i,k)===1) coprimeClasses++;
    
    // Prime channel analysis
    const primeOwnership = {};
    const smallPrimes = [2,3,5,7,11,13,17,19];
    smallPrimes.forEach(p => {
        primeOwnership[p] = state.allResidues.filter(r=>r.m%p===0).length;
    });
    
    // Non-divisible counts
    const notDiv2 = state.allResidues.filter(r => r.m % 2 !== 0).length;
    const notDiv3 = state.allResidues.filter(r => r.m % 3 !== 0).length;
    const notDiv6 = state.allResidues.filter(r => r.m % 6 !== 0).length;
    
    // Sector distribution of filtered
    const sectorsInFiltered = Object.keys(bySector).length;
    const maxSectorCount = Math.max(...Object.values(bySector), 0);
    
    document.getElementById('modularStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${filtered.length}</div><div class="stat-label">m‚â°${a} (mod ${k})</div></div>
        <div class="stat-card"><div class="stat-value">${total}</div><div class="stat-label">Total Fractions</div></div>
        <div class="stat-card"><div class="stat-value">${(filtered.length/total*100).toFixed(2)}%</div><div class="stat-label">Fraction</div></div>
        <div class="stat-card"><div class="stat-value">${(100/k).toFixed(2)}%</div><div class="stat-label">Expected 1/k</div></div>
        <div class="stat-card"><div class="stat-value">${filteredPrimes}</div><div class="stat-label">Prime Denoms</div></div>
        <div class="stat-card"><div class="stat-value">${(filteredPrimes/filtered.length*100||0).toFixed(1)}%</div><div class="stat-label">Prime Rate</div></div>
        <div class="stat-card"><div class="stat-value">${k}</div><div class="stat-label">Modulus k</div></div>
        <div class="stat-card"><div class="stat-value">${coprimeClasses}</div><div class="stat-label">œÜ(k) Coprimes</div></div>
        <div class="stat-card"><div class="stat-value">${maxClass}</div><div class="stat-label">Max Class Size</div></div>
        <div class="stat-card"><div class="stat-value">${minClass}</div><div class="stat-label">Min Class Size</div></div>
        <div class="stat-card"><div class="stat-value">${avgClass.toFixed(1)}</div><div class="stat-label">Avg Class Size</div></div>
        <div class="stat-card"><div class="stat-value">${classStdDev.toFixed(1)}</div><div class="stat-label">Class Std Dev</div></div>
        <div class="stat-card"><div class="stat-value">${sectorsInFiltered}</div><div class="stat-label">Sectors Hit</div></div>
        <div class="stat-card"><div class="stat-value">${notDiv2}</div><div class="stat-label">Odd Denoms</div></div>
        <div class="stat-card"><div class="stat-value">${notDiv3}</div><div class="stat-label">Not √∑3</div></div>
        <div class="stat-card"><div class="stat-value">${notDiv6}</div><div class="stat-label">Not √∑6</div></div>
    `;
    
    if(state.charts.residueClass) state.charts.residueClass.destroy();
    state.charts.residueClass = new Chart(document.getElementById('residueClassChart'),{type:'bar',data:{labels:Object.keys(residueClasses),datasets:[{label:'Count',data:Object.values(residueClasses),backgroundColor:Object.keys(residueClasses).map(i=>i==a?'rgba(245,158,11,0.8)':'rgba(99,102,241,0.6)')}]},options:{responsive:true,plugins:{title:{display:true,text:`Distribution mod ${k}`,color:'#94a3b8'}},scales:{x:{title:{display:true,text:'Residue class',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{title:{display:true,text:'Count',color:'#94a3b8'},ticks:{color:'#94a3b8'}}}}});
    
    // Prime channel - enhanced
    if(state.charts.primeChannel) state.charts.primeChannel.destroy();
    state.charts.primeChannel = new Chart(document.getElementById('primeChannelChart'),{type:'bar',data:{labels:Object.keys(primeOwnership),datasets:[{label:'Divisible by p',data:Object.values(primeOwnership),backgroundColor:'rgba(139,92,246,0.7)'},{label:'Expected N/p',data:Object.keys(primeOwnership).map(p => Math.round(total/p)),backgroundColor:'rgba(34,197,94,0.5)',borderColor:'#22c55e',borderWidth:1}]},options:{responsive:true,plugins:{title:{display:true,text:'Prime Divisibility',color:'#94a3b8'}},scales:{x:{title:{display:true,text:'Prime p',color:'#94a3b8'},ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Farey Neighbors display - show left/right neighbors and mediant
    const sample = state.allResidues.slice(0, 12);
    let liftHtml = '<table style="width:100%;font-size:0.85em;"><thead><tr><th>Fraction</th><th>Sector</th><th>Left Neighbor</th><th>Right Neighbor</th><th>Mediant</th><th>Mediant Sector</th></tr></thead><tbody>';
    
    // Sort all residues by value for neighbor finding
    const sorted = [...state.allResidues].sort((a,b) => a.r/a.m - b.r/b.m);
    
    sample.forEach(res => {
        const val = res.r / res.m;
        const idx = sorted.findIndex(s => s.r === res.r && s.m === res.m);
        
        let leftN = idx > 0 ? sorted[idx-1] : null;
        let rightN = idx < sorted.length-1 ? sorted[idx+1] : null;
        
        let mediantStr = '-';
        let mediantSector = '-';
        if (leftN && rightN) {
            const medR = leftN.r + rightN.r;
            const medM = leftN.m + rightN.m;
            if (gcd(medR, medM) === 1) {
                mediantStr = `${medR}/${medM}`;
                const medVal = medR / medM;
                // Find sector for mediant
                for (let n = 1; n <= 20; n++) {
                    if (medVal > 1/(n+1) && medVal <= 1/n) {
                        mediantSector = `S${n}`;
                        break;
                    }
                }
            }
        }
        
        const leftStr = leftN ? `${leftN.r}/${leftN.m}` : '-';
        const rightStr = rightN ? `${rightN.r}/${rightN.m}` : '-';
        
        liftHtml += `<tr>
            <td><strong style="color:#8b5cf6">${res.r}/${res.m}</strong></td>
            <td style="color:#6366f1">S${res.sector||'?'}</td>
            <td style="color:#ef4444">${leftStr}</td>
            <td style="color:#22c55e">${rightStr}</td>
            <td style="color:#f59e0b">${mediantStr}</td>
            <td style="color:#64748b">${mediantSector}</td>
        </tr>`;
    });
    liftHtml += '</tbody></table>';
    liftHtml += '<p style="color:#64748b;font-size:0.8em;margin-top:8px;"><strong>Mediant property:</strong> If a/b and c/d are Farey neighbors, their mediant (a+c)/(b+d) is the next fraction to appear between them.</p>';
    document.getElementById('liftingDisplay').innerHTML = liftHtml;
}

// 3D VIEW - Sync and preset functions
let anim3dId = null;

function sync3DInput(axis) {
    const slider = document.getElementById(axis === 'P' ? 'perspective3d' : `rot3d${axis}`);
    const num = document.getElementById(axis === 'P' ? 'perspective3dNum' : `rot3d${axis}Num`);
    if (num) num.value = slider.value;
    draw3D();
}

function sync3DSlider(axis) {
    const slider = document.getElementById(axis === 'P' ? 'perspective3d' : `rot3d${axis}`);
    const num = document.getElementById(axis === 'P' ? 'perspective3dNum' : `rot3d${axis}Num`);
    if (slider) slider.value = num.value;
    draw3D();
}

function set3DPreset(x, y, z, p) {
    document.getElementById('rot3dX').value = x;
    document.getElementById('rot3dXNum').value = x;
    document.getElementById('rot3dY').value = y;
    document.getElementById('rot3dYNum').value = y;
    document.getElementById('rot3dZ').value = z;
    document.getElementById('rot3dZNum').value = z;
    document.getElementById('perspective3d').value = p;
    document.getElementById('perspective3dNum').value = p;
    draw3D();
}

function animate3DRotation() {
    stop3DAnimation();
    let z = +document.getElementById('rot3dZ').value;
    anim3dId = setInterval(() => {
        z = (z + 1) % 360;
        document.getElementById('rot3dZ').value = z;
        document.getElementById('rot3dZNum').value = z;
        draw3D();
    }, 50);
}

function stop3DAnimation() {
    if (anim3dId) {
        clearInterval(anim3dId);
        anim3dId = null;
    }
}

function draw3D() {
    const canvas = document.getElementById('canvas3d'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2;
    const rotX = +document.getElementById('rot3dX').value * Math.PI/180;
    const rotY = +(document.getElementById('rot3dY')?.value || 0) * Math.PI/180;
    const rotZ = +document.getElementById('rot3dZ').value * Math.PI/180;
    const persp = +document.getElementById('perspective3d').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const points3d = [];
    const sector = +document.getElementById('viewSector').value;
    const residues = state.residuesBySector[sector] || [];
    
    // Statistics
    const totalPoints = residues.length;
    const primePoints = residues.filter(r => r.isPrime).length;
    const denominators = residues.map(r => r.m);
    const minDenom = denominators.length > 0 ? denominators.reduce((min, v) => v < min ? v : min, Infinity) : 0;
    const maxDenom = denominators.length > 0 ? denominators.reduce((max, v) => v > max ? v : max, 0) : 0;
    const avgDenom = denominators.length > 0 ? denominators.reduce((a,b) => a+b, 0) / denominators.length : 0;
    
    // Distribution by height (denominator ranges)
    const heightBins = [0, 0, 0, 0, 0];  // 5 bins
    const binSize = state.nMax / 5;
    residues.forEach(r => {
        const bin = Math.min(4, Math.floor(r.m / binSize));
        heightBins[bin]++;
    });
    
    // Angular spread
    const angles = residues.map(r => r.r / r.m);
    const minAngle = angles.length > 0 ? angles.reduce((min, v) => v < min ? v : min, Infinity) : 0;
    const maxAngle = angles.length > 0 ? angles.reduce((max, v) => v > max ? v : max, 0) : 0;
    const angleSpread = maxAngle - minAngle;
    
    // Depth stats (z-coordinate distribution)
    let minZ = Infinity, maxZ = -Infinity;
    
    residues.forEach(res => {
        const angle = (res.r/res.m) * 2 * Math.PI;
        const radius = 150;
        let x3d = radius * Math.cos(angle);
        let y3d = radius * Math.sin(angle);
        let z3d = ((res.m - state.nMin) / (state.nMax - state.nMin + 1)) * 200 - 100;
        
        // Rotate around X axis (pitch)
        let y1 = y3d * Math.cos(rotX) - z3d * Math.sin(rotX);
        let z1 = y3d * Math.sin(rotX) + z3d * Math.cos(rotX);
        
        // Rotate around Y axis (yaw)
        let x2 = x3d * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x3d * Math.sin(rotY) + z1 * Math.cos(rotY);
        
        // Rotate around Z axis (roll)
        let x3 = x2 * Math.cos(rotZ) - y1 * Math.sin(rotZ);
        let y3 = x2 * Math.sin(rotZ) + y1 * Math.cos(rotZ);
        
        const scale = persp / (persp + z2);
        const sx = cx + x3 * scale;
        const sy = cy + y3 * scale;
        
        if(z2 < minZ) minZ = z2;
        if(z2 > maxZ) maxZ = z2;
        
        points3d.push({sx, sy, z:z2, isPrime:res.isPrime, m:res.m});
    });
    
    // Update stats display
    const statsEl = document.getElementById('stats3d');
    if(statsEl) {
        statsEl.innerHTML = `
            <div class="stat-card"><div class="stat-value">${totalPoints}</div><div class="stat-label">Points in Sector</div></div>
            <div class="stat-card"><div class="stat-value">${sector}</div><div class="stat-label">Sector n</div></div>
            <div class="stat-card"><div class="stat-value">${primePoints}</div><div class="stat-label">Prime Denoms</div></div>
            <div class="stat-card"><div class="stat-value">${(primePoints/totalPoints*100||0).toFixed(1)}%</div><div class="stat-label">Prime Rate</div></div>
            <div class="stat-card"><div class="stat-value">${minDenom}</div><div class="stat-label">Min Denom</div></div>
            <div class="stat-card"><div class="stat-value">${maxDenom}</div><div class="stat-label">Max Denom</div></div>
            <div class="stat-card"><div class="stat-value">${avgDenom.toFixed(1)}</div><div class="stat-label">Avg Denom</div></div>
            <div class="stat-card"><div class="stat-value">${(angleSpread*360).toFixed(1)}¬∞</div><div class="stat-label">Angular Spread</div></div>
            <div class="stat-card"><div class="stat-value">${heightBins[0]}</div><div class="stat-label">Low Layer</div></div>
            <div class="stat-card"><div class="stat-value">${heightBins[2]}</div><div class="stat-label">Mid Layer</div></div>
            <div class="stat-card"><div class="stat-value">${heightBins[4]}</div><div class="stat-label">High Layer</div></div>
            <div class="stat-card"><div class="stat-value">${(+document.getElementById('rot3dX').value).toFixed(0)}¬∞</div><div class="stat-label">Rot X</div></div>
            <div class="stat-card"><div class="stat-value">${(+(document.getElementById('rot3dY')?.value||0)).toFixed(0)}¬∞</div><div class="stat-label">Rot Y</div></div>
            <div class="stat-card"><div class="stat-value">${(+document.getElementById('rot3dZ').value).toFixed(0)}¬∞</div><div class="stat-label">Rot Z</div></div>
            <div class="stat-card"><div class="stat-value">${persp}</div><div class="stat-label">Perspective</div></div>
        `;
    }
    
    points3d.sort((a,b) => a.z - b.z);
    
    // Adaptive point size for 3D
    const numPts3d = points3d.length;
    const ptSize3d = numPts3d < 100 ? 3 : numPts3d < 500 ? 2.5 : numPts3d < 2000 ? 1.8 : numPts3d < 10000 ? 1.2 : 0.8;
    
    points3d.forEach(p => {
        const alpha = 0.3 + 0.7 * (p.z + 200) / 400;
        ctx.fillStyle = p.isPrime ? `rgba(245,158,11,${alpha})` : `rgba(99,102,241,${alpha})`;
        ctx.beginPath(); ctx.arc(p.sx, p.sy, ptSize3d, 0, 2*Math.PI); ctx.fill();
    });
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx-100,cy); ctx.lineTo(cx+100,cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx,cy-100); ctx.lineTo(cx,cy+100); ctx.stroke();
    
    // Labels
    ctx.fillStyle = '#64748b'; ctx.font = '10px system-ui';
    ctx.fillText('X', cx+105, cy+4);
    ctx.fillText('Y', cx+4, cy-105);
}

// HYPERBOLIC
function setHypPreset(maxDenom, sector) {
    document.getElementById('hypMaxDenom').value = maxDenom;
    document.getElementById('hypSector').value = sector;
    drawHyperbolic();
}

function drawHyperbolic() {
    const canvas = document.getElementById('hypCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, R=Math.min(W,H)/2-30;
    const maxDenom = +document.getElementById('hypMaxDenom').value;
    const highlightSector = +document.getElementById('hypSector').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,2*Math.PI); ctx.stroke();
    
    // Farey fractions on boundary
    const farey = [{r:0,m:1,angle:-Math.PI/2}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const angle = (r/m) * Math.PI - Math.PI/2;
                farey.push({r,m,angle});
            }
        }
    }
    farey.push({r:1,m:1,angle:Math.PI/2});
    farey.sort((a,b)=>a.angle-b.angle);
    
    // Statistics
    const totalFractions = farey.length;
    const totalEdges = farey.length - 1;
    const totalTriangles = totalEdges - 1;  // Ideal triangles in tessellation
    
    // Count by denominator
    const denomCounts = {};
    farey.forEach(f => { denomCounts[f.m] = (denomCounts[f.m] || 0) + 1; });
    const uniqueDenoms = Object.keys(denomCounts).length;
    
    // Highlight sector stats
    let highlightedCount = 0;
    let highlightedEdges = 0;
    
    // Draw geodesics between neighbors
    ctx.lineWidth = 1;
    for(let i=0; i<farey.length-1; i++) {
        const a1 = farey[i].angle, a2 = farey[i+1].angle;
        const x1 = cx + R*Math.cos(a1), y1 = cy + R*Math.sin(a1);
        const x2 = cx + R*Math.cos(a2), y2 = cy + R*Math.sin(a2);
        
        const sector = farey[i].r > 0 ? getSector(farey[i].r, farey[i].m) : null;
        const isHighlighted = sector === highlightSector;
        if(isHighlighted) highlightedEdges++;
        
        ctx.strokeStyle = isHighlighted ? '#6366f1' : '#334155';
        ctx.lineWidth = isHighlighted ? 2 : 1;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
    
    // Points on boundary
    // Adaptive point size for hyperbolic
    const numHypPts = farey.length;
    const hypPtSize = numHypPts < 50 ? 4 : numHypPts < 150 ? 3 : numHypPts < 500 ? 2.5 : numHypPts < 1500 ? 1.8 : 1.2;
    
    farey.forEach(f => {
        const x = cx + R*Math.cos(f.angle), y = cy + R*Math.sin(f.angle);
        const sector = f.r > 0 && f.r < f.m ? getSector(f.r, f.m) : null;
        const isHighlighted = sector === highlightSector;
        if(isHighlighted) highlightedCount++;
        
        ctx.fillStyle = isHighlighted ? '#f59e0b' : '#6366f1';
        ctx.beginPath(); ctx.arc(x,y, isHighlighted ? hypPtSize * 1.5 : hypPtSize, 0,2*Math.PI); ctx.fill();
    });
    
    // Arc lengths (angular gaps)
    const gaps = [];
    for(let i=0; i<farey.length-1; i++) {
        gaps.push(farey[i+1].angle - farey[i].angle);
    }
    const maxGap = gaps.reduce((max, v) => v > max ? v : max, 0);
    const minGap = gaps.reduce((min, v) => v < min ? v : min, Infinity);
    const avgGap = gaps.reduce((a,b) => a+b, 0) / gaps.length;
    
    // Hyperbolic area = œÄ per ideal triangle
    const totalHypArea = totalTriangles * Math.PI;
    
    // Expected |F_N| 
    const expectedFN = 1 + 3 * maxDenom * maxDenom / (Math.PI * Math.PI);
    
    // Prime denominators
    const primeDenoms = farey.filter(f => f.m > 1 && isPrime(f.m)).length;
    
    // Update stats
    const statsEl = document.getElementById('hypStats');
    if(statsEl) {
        statsEl.innerHTML = `
            <div class="stat-card"><div class="stat-value">${totalFractions}</div><div class="stat-label">Boundary Points</div></div>
            <div class="stat-card"><div class="stat-value">${Math.round(expectedFN)}</div><div class="stat-label">Expected |F_N|</div></div>
            <div class="stat-card"><div class="stat-value">${totalEdges}</div><div class="stat-label">Geodesic Edges</div></div>
            <div class="stat-card"><div class="stat-value">${totalTriangles}</div><div class="stat-label">Ideal Triangles</div></div>
            <div class="stat-card"><div class="stat-value">${totalHypArea.toFixed(2)}</div><div class="stat-label">Total Hyp Area</div></div>
            <div class="stat-card"><div class="stat-value">${maxDenom}</div><div class="stat-label">Max Denom</div></div>
            <div class="stat-card"><div class="stat-value">${uniqueDenoms}</div><div class="stat-label">Unique Denoms</div></div>
            <div class="stat-card"><div class="stat-value">${primeDenoms}</div><div class="stat-label">Prime Denoms</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#f59e0b">${highlightedCount}</div><div class="stat-label">In Sector ${highlightSector}</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#6366f1">${highlightedEdges}</div><div class="stat-label">Sector Edges</div></div>
            <div class="stat-card"><div class="stat-value">${(maxGap*180/Math.PI).toFixed(2)}¬∞</div><div class="stat-label">Max Arc Gap</div></div>
            <div class="stat-card"><div class="stat-value">${(minGap*180/Math.PI).toFixed(2)}¬∞</div><div class="stat-label">Min Arc Gap</div></div>
            <div class="stat-card"><div class="stat-value">${(avgGap*180/Math.PI).toFixed(2)}¬∞</div><div class="stat-label">Avg Arc Gap</div></div>
            <div class="stat-card"><div class="stat-value">${(180/totalFractions).toFixed(2)}¬∞</div><div class="stat-label">Expected Gap</div></div>
        `;
    }
    
    // Draw sector labels at key positions
    ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui';
    [0, 0.25, 0.5, 0.75, 1].forEach(v => {
        const angle = v * Math.PI - Math.PI/2;
        const x = cx + (R+15)*Math.cos(angle);
        const y = cy + (R+15)*Math.sin(angle);
        ctx.fillText(v.toFixed(2), x-10, y+3);
    });
}

// SMITH CHART - Proper Cayley Transform Implementation
let smithAnimId = null;

function syncSmithPhase(source) {
    const slider = document.getElementById('smithPhase');
    const display = document.getElementById('smithPhaseDisplay');
    const input = document.getElementById('smithPhaseInput');
    let val;
    
    if (source === 'slider') {
        val = slider.value;
        if (input) input.value = val;
    } else if (source === 'input') {
        val = input.value;
        if (slider) slider.value = val;
    }
    
    if (display) display.textContent = parseFloat(val).toFixed(1);
    
    // Clear active state from preset buttons
    document.querySelectorAll('.phase-preset-btn').forEach(btn => btn.classList.remove('active'));
    
    drawSmithChart();
}

// Set phase from a/b fraction (primitive root of unity)
function setPhasePreset(a, b) {
    if (b === 0) b = 1;
    const g = gcd(a, b);
    const aPrim = a / g;
    const bPrim = b / g;
    const phase = (aPrim / bPrim) * 360;
    
    const slider = document.getElementById('smithPhase');
    const input = document.getElementById('smithPhaseInput');
    const display = document.getElementById('smithPhaseDisplay');
    const info = document.getElementById('phasePresetInfo');
    
    if (slider) slider.value = phase;
    if (input) input.value = phase.toFixed(1);
    if (display) display.textContent = phase.toFixed(1);
    if (info) info.textContent = `${aPrim}/${bPrim} = ${phase.toFixed(1)}¬∞ (Œ∂_${bPrim}^${aPrim})`;
    
    // Update custom inputs
    document.getElementById('phasePresetA').value = aPrim;
    document.getElementById('phasePresetB').value = bPrim;
    
    // Highlight active preset button
    document.querySelectorAll('.phase-preset-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    drawSmithChart();
}

// Apply custom a/b phase preset
function applyCustomPhasePreset() {
    const a = parseInt(document.getElementById('phasePresetA').value) || 0;
    const b = parseInt(document.getElementById('phasePresetB').value) || 1;
    
    if (b === 0) {
        document.getElementById('phasePresetInfo').textContent = 'Error: b cannot be 0';
        return;
    }
    
    const g = gcd(a, b);
    const aPrim = a / g;
    const bPrim = b / g;
    const phase = (aPrim / bPrim) * 360;
    
    const slider = document.getElementById('smithPhase');
    const input = document.getElementById('smithPhaseInput');
    const display = document.getElementById('smithPhaseDisplay');
    const info = document.getElementById('phasePresetInfo');
    
    if (slider) slider.value = phase % 360;
    if (input) input.value = (phase % 360).toFixed(1);
    if (display) display.textContent = (phase % 360).toFixed(1);
    
    // Show info about the primitive root
    const isPrimitive = g === 1;
    if (info) {
        info.textContent = isPrimitive 
            ? `${aPrim}/${bPrim} = ${(phase % 360).toFixed(1)}¬∞ primitive (gcd=1)`
            : `${a}/${b} ‚Üí ${aPrim}/${bPrim} = ${(phase % 360).toFixed(1)}¬∞ (reduced)`;
    }
    
    // Clear active state from preset buttons
    document.querySelectorAll('.phase-preset-btn').forEach(btn => btn.classList.remove('active'));
    
    drawSmithChart();
}

function updateSmithPhaseLabel() {
    const phase = document.getElementById('smithPhase')?.value || 90;
    const display = document.getElementById('smithPhaseDisplay');
    const input = document.getElementById('smithPhaseInput');
    if (display) display.textContent = phase;
    if (input) input.value = phase;
}

function setSmithPreset(sector, phase, radiusMode, scale) {
    document.getElementById('smithSector').value = sector;
    document.getElementById('smithPhase').value = phase;
    const display = document.getElementById('smithPhaseDisplay');
    const input = document.getElementById('smithPhaseInput');
    if (display) display.textContent = phase;
    if (input) input.value = phase;
    document.getElementById('smithRadiusMode').value = radiusMode;
    document.getElementById('smithCustomScale').value = scale;
    drawSmithChart();
}

function animateSmithPhase() {
    stopSmithAnimation();
    let phase = +document.getElementById('smithPhase').value;
    smithAnimId = setInterval(() => {
        phase = (phase + 2) % 360;
        document.getElementById('smithPhase').value = phase;
        const display = document.getElementById('smithPhaseDisplay');
        const input = document.getElementById('smithPhaseInput');
        if (display) display.textContent = phase;
        if (input) input.value = phase;
        drawSmithChart();
    }, 50);
}

function stopSmithAnimation() {
    if (smithAnimId) {
        clearInterval(smithAnimId);
        smithAnimId = null;
    }
}

function cayleyTransform(z) {
    // Œì = (z - 1)/(z + 1)
    // z is complex: {re, im}
    const numRe = z.re - 1;
    const numIm = z.im;
    const denRe = z.re + 1;
    const denIm = z.im;
    
    const denMagSq = denRe * denRe + denIm * denIm;
    if (denMagSq < 1e-10) return { re: 0, im: 0 };
    
    // Complex division: (a+bi)/(c+di) = [(ac+bd) + (bc-ad)i]/(c¬≤+d¬≤)
    const gammaRe = (numRe * denRe + numIm * denIm) / denMagSq;
    const gammaIm = (numIm * denRe - numRe * denIm) / denMagSq;
    
    return { re: gammaRe, im: gammaIm };
}

function drawSmithChart() {
    const canvas = document.getElementById('smithCanvas');
    const origCanvas = document.getElementById('smithOriginalCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 40;
    
    const enabled = document.getElementById('smithEnabled')?.checked ?? true;
    const sector = +(document.getElementById('smithSector')?.value || 2);
    const phase = +(document.getElementById('smithPhase')?.value || 90) * Math.PI / 180;
    const radiusMode = document.getElementById('smithRadiusMode')?.value || 'index';
    const customScale = +(document.getElementById('smithCustomScale')?.value || 1.0);
    const showGrid = document.getElementById('smithShowGrid')?.checked ?? true;
    const showConstR = document.getElementById('smithShowConstR')?.checked ?? true;
    const showConstX = document.getElementById('smithShowConstX')?.checked ?? true;
    const showLabels = document.getElementById('smithShowLabels')?.checked ?? false;
    const colorByPrime = document.getElementById('smithColorByPrime')?.checked ?? false;
    const showAllSectors = document.getElementById('smithShowAllSectors')?.checked ?? false;
    
    // Clear canvas
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    if (!enabled) {
        ctx.fillStyle = '#64748b';
        ctx.font = '16px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Smith Chart Transform Disabled', cx, cy);
        return;
    }
    
    // Draw Smith chart grid
    if (showGrid) {
        // Unit circle (boundary)
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, maxR, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Constant-R circles (circles of constant resistance/real part)
        if (showConstR) {
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            const rValues = [0.2, 0.5, 1, 2, 5];
            rValues.forEach(r => {
                // Constant-R circles in Smith chart: center at (r/(r+1), 0), radius 1/(r+1)
                const centerX = cx + (r / (r + 1)) * maxR;
                const radius = maxR / (r + 1);
                ctx.beginPath();
                ctx.arc(centerX, cy, radius, 0, 2 * Math.PI);
                ctx.stroke();
            });
        }
        
        // Constant-X arcs (arcs of constant reactance/imaginary part)
        if (showConstX) {
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            const xValues = [0.2, 0.5, 1, 2, 5];
            xValues.forEach(x => {
                // Constant-X arcs: center at (1, 1/x), radius 1/x
                const arcCenterY = cy - maxR / x;
                const arcRadius = maxR / x;
                
                // Draw arc (only part inside unit circle)
                ctx.beginPath();
                const startAngle = Math.PI / 2 - Math.asin(Math.min(1, x));
                const endAngle = Math.PI / 2;
                ctx.arc(cx + maxR, arcCenterY, arcRadius, startAngle, endAngle);
                ctx.stroke();
                
                // Mirror for negative X
                const arcCenterYNeg = cy + maxR / x;
                ctx.beginPath();
                ctx.arc(cx + maxR, arcCenterYNeg, arcRadius, -Math.PI / 2, -Math.PI / 2 + Math.asin(Math.min(1, x)));
                ctx.stroke();
            });
        }
        
        // Horizontal axis (real axis in Œì plane)
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx - maxR, cy);
        ctx.lineTo(cx + maxR, cy);
        ctx.stroke();
        
        // Vertical axis
        ctx.beginPath();
        ctx.moveTo(cx, cy - maxR);
        ctx.lineTo(cx, cy + maxR);
        ctx.stroke();
    }
    
    // Get residues to transform
    const residuesToPlot = showAllSectors 
        ? state.allResidues.slice(0, 500) 
        : (state.residuesBySector[sector] || []);
    
    // Transform and plot points
    const transformedPoints = [];
    const tableData = [];
    
    residuesToPlot.forEach((res, idx) => {
        const { r, m } = res;
        
        // Compute theta = 2œÄr/m + Œ± (phase shift)
        const theta = 2 * Math.PI * r / m + phase;
        
        // Compute R based on mode
        let R;
        switch (radiusMode) {
            case 'unit': R = 1; break;
            case 'index': R = 1 + idx * 0.02 * customScale; break;
            case 'modulus': R = 1 + ((m - state.nMin) / (state.nMax - state.nMin + 1)) * customScale; break;
            case 'custom': R = customScale; break;
            default: R = 1;
        }
        
        // z = R * e^(iŒ∏) = R(cos Œ∏ + i sin Œ∏)
        const z = {
            re: R * Math.cos(theta),
            im: R * Math.sin(theta)
        };
        
        // Apply Cayley transform: Œì = (z - 1)/(z + 1)
        const gamma = cayleyTransform(z);
        
        // Check if point is inside unit circle (valid Smith chart region)
        const gammaMag = Math.sqrt(gamma.re * gamma.re + gamma.im * gamma.im);
        if (gammaMag <= 1.05) {
            transformedPoints.push({
                ...res,
                z,
                gamma,
                gammaMag,
                theta,
                R
            });
            
            if (tableData.length < 30) {
                tableData.push({
                    fraction: `${r}/${m}`,
                    theta: theta.toFixed(4),
                    R: R.toFixed(3),
                    z: `${z.re.toFixed(3)} + ${z.im.toFixed(3)}i`,
                    gamma: `${gamma.re.toFixed(3)} + ${gamma.im.toFixed(3)}i`,
                    gammaMag: gammaMag.toFixed(4)
                });
            }
        }
    });
    
    // Plot transformed points
    transformedPoints.forEach(pt => {
        const x = cx + pt.gamma.re * maxR;
        const y = cy - pt.gamma.im * maxR; // Flip y for screen coordinates
        
        let color;
        if (colorByPrime) {
            color = pt.isPrime ? '#f59e0b' : '#6366f1';
        } else {
            // Color by sector
            color = getSectorColor(pt.sector || sector);
        }
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        if (showLabels && transformedPoints.length < 50) {
            ctx.fillStyle = '#94a3b8';
            ctx.font = '8px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${pt.r}/${pt.m}`, x, y - 8);
        }
    });
    
    // Labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Re(Œì)', cx, H - 10);
    ctx.save();
    ctx.translate(15, cy);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Im(Œì)', 0, 0);
    ctx.restore();
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText(`Cayley Transform: ${transformedPoints.length} points`, cx, 20);
    
    // Draw original z-plane
    if (origCanvas) {
        drawSmithOriginal(origCanvas, transformedPoints, phase);
    }
    
    // Update data table
    updateSmithDataTable(tableData);
}

function drawSmithOriginal(canvas, points, phase) {
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 40;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 1; i <= 3; i++) {
        ctx.beginPath();
        ctx.arc(cx, cy, maxR * i / 3, 0, 2 * Math.PI);
        ctx.stroke();
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx - maxR, cy);
    ctx.lineTo(cx + maxR, cy);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx, cy - maxR);
    ctx.lineTo(cx, cy + maxR);
    ctx.stroke();
    
    // Unit circle
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, maxR / 2, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#22c55e';
    ctx.font = '9px system-ui';
    ctx.fillText('R=1', cx + maxR / 2 + 10, cy - 5);
    
    // Plot original z points
    const scale = maxR / 3; // Scale so R=1 maps to 1/3 of radius
    
    points.forEach(pt => {
        const x = cx + pt.z.re * scale;
        const y = cy - pt.z.im * scale;
        
        ctx.fillStyle = getSectorColor(pt.sector || 1);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Re(z)', cx, H - 10);
    ctx.save();
    ctx.translate(15, cy);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Im(z)', 0, 0);
    ctx.restore();
    
    // Phase indicator
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(phase) * maxR * 0.8, cy - Math.sin(phase) * maxR * 0.8);
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.font = '9px system-ui';
    ctx.fillText(`Œ± = ${(phase * 180 / Math.PI).toFixed(0)}¬∞`, cx + Math.cos(phase) * maxR * 0.6 + 15, cy - Math.sin(phase) * maxR * 0.6);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('z = R¬∑e^(iŒ∏) plane', cx, 20);
}

function updateSmithDataTable(data) {
    const tbody = document.querySelector('#smithDataTable tbody');
    if (!tbody) return;
    
    tbody.innerHTML = data.map(d => `
        <tr>
            <td>${d.fraction}</td>
            <td>${d.theta}</td>
            <td>${d.R}</td>
            <td style="font-family:monospace;font-size:0.85em;">${d.z}</td>
            <td style="font-family:monospace;font-size:0.85em;">${d.gamma}</td>
            <td>${d.gammaMag}</td>
        </tr>
    `).join('');
}

// ANIMATION
let animating = false;
function startAnimation() {
    if(animating) return;
    animating = true;
    const maxN = +document.getElementById('animMaxN').value;
    const speed = +document.getElementById('animSpeed').value;
    let currentN = 2;
    
    function frame() {
        if(!animating || currentN > maxN) { animating = false; document.getElementById('animStatus').textContent = 'Done'; return; }
        
        const farey = [{r:0,m:1}];
        let primeCount = 0;
        for(let m=2; m<=currentN; m++) {
            for(let r=1; r<m; r++) {
                if(gcd(r,m)===1) {
                    farey.push({r,m,isPrime:isPrime(m)});
                    if(isPrime(m)) primeCount++;
                }
            }
        }
        farey.push({r:1,m:1});
        farey.sort((a,b)=>a.r/a.m - b.r/b.m);
        
        const canvas = document.getElementById('animCanvas'), ctx = canvas.getContext('2d');
        const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-30;
        
        ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
        
        // Adaptive point size for animation
        const numPts = farey.length - 2;
        let animPtSize = numPts < 100 ? 3 : numPts < 500 ? 2.5 : numPts < 2000 ? 1.8 : numPts < 10000 ? 1.2 : 0.8;
        
        farey.forEach(f => {
            if(f.r === 0 || f.r === f.m) return;
            const angle = (f.r/f.m) * 2 * Math.PI;
            const rad = (f.m / maxN) * maxR;
            ctx.fillStyle = f.isPrime ? '#f59e0b' : '#6366f1';
            ctx.beginPath(); ctx.arc(cx+rad*Math.cos(angle), cy-rad*Math.sin(angle), animPtSize, 0, 2*Math.PI); ctx.fill();
        });
        
        // Enhanced statistics
        const count = farey.length - 2;
        const expected = Math.round(3 * currentN * currentN / (Math.PI * Math.PI));
        const error = count - expected;
        const primeRate = (primeCount / count * 100).toFixed(1);
        const density = (count / currentN).toFixed(2);
        const phiSum = count;  // Sum of œÜ(m) for m ‚â§ N
        const avgPhi = (phiSum / (currentN - 1)).toFixed(2);
        const progress = ((currentN / maxN) * 100).toFixed(0);
        const growthRate = currentN > 2 ? ((count / ((currentN-1)*(currentN-1)/3*Math.PI*Math.PI/3)) - 1) * 100 : 0;
        
        // Count by denominator ranges
        const lowCount = farey.filter(f => f.m > 1 && f.m <= currentN/3).length;
        const midCount = farey.filter(f => f.m > currentN/3 && f.m <= 2*currentN/3).length;
        const highCount = farey.filter(f => f.m > 2*currentN/3).length;
        
        document.getElementById('animStatus').textContent = `N = ${currentN}`;
        document.getElementById('animStats').innerHTML = `
            <div class="stat-card"><div class="stat-value">${currentN}</div><div class="stat-label">Current N</div></div>
            <div class="stat-card"><div class="stat-value">${maxN}</div><div class="stat-label">Target N</div></div>
            <div class="stat-card"><div class="stat-value">${progress}%</div><div class="stat-label">Progress</div></div>
            <div class="stat-card"><div class="stat-value">${count}</div><div class="stat-label">|F_N|</div></div>
            <div class="stat-card"><div class="stat-value">${expected}</div><div class="stat-label">Expected</div></div>
            <div class="stat-card"><div class="stat-value" style="color:${error>=0?'#22c55e':'#ef4444'}">${error>=0?'+':''}${error}</div><div class="stat-label">Error</div></div>
            <div class="stat-card"><div class="stat-value">${primeCount}</div><div class="stat-label">Prime Denoms</div></div>
            <div class="stat-card"><div class="stat-value">${primeRate}%</div><div class="stat-label">Prime Rate</div></div>
            <div class="stat-card"><div class="stat-value">${density}</div><div class="stat-label">Avg per m</div></div>
            <div class="stat-card"><div class="stat-value">${avgPhi}</div><div class="stat-label">Avg œÜ(m)</div></div>
            <div class="stat-card"><div class="stat-value">${lowCount}</div><div class="stat-label">Low Layer</div></div>
            <div class="stat-card"><div class="stat-value">${midCount}</div><div class="stat-label">Mid Layer</div></div>
            <div class="stat-card"><div class="stat-value">${highCount}</div><div class="stat-label">High Layer</div></div>
            <div class="stat-card"><div class="stat-value">${speed}ms</div><div class="stat-label">Frame Time</div></div>
        `;
        
        currentN++;
        state.animationId = setTimeout(frame, speed);
    }
    frame();
}
function stopAnimation() { animating = false; if(state.animationId) clearTimeout(state.animationId); }

// STATISTICS
function updateStatistics() {
    if(state.allResidues.length === 0) return;
    
    // Random comparison
    const N = state.nMax, expected = 6/Math.PI/Math.PI * N * N;
    const actual = state.allResidues.length;
    
    // Comprehensive statistics
    const sectorCounts = state.sectors.map(s => s.exact || 0);
    const validCounts = sectorCounts.filter(c => c > 0);
    const totalSectors = state.sectors.length;
    const activeSectors = validCounts.length;
    
    // Statistical measures
    const mean = validCounts.length > 0 ? validCounts.reduce((a,b) => a+b, 0) / validCounts.length : 0;
    const variance = validCounts.length > 0 ? validCounts.reduce((s, c) => s + (c - mean)**2, 0) / validCounts.length : 0;
    const stdDev = Math.sqrt(variance);
    const cv = mean > 0 ? (stdDev / mean * 100) : 0;  // Coefficient of variation
    
    const maxCount = Math.max(...validCounts, 0);
    const minCount = Math.min(...validCounts.filter(c => c > 0), 0);
    const range = maxCount - minCount;
    const median = validCounts.length > 0 ? validCounts.sort((a,b) => a-b)[Math.floor(validCounts.length/2)] : 0;
    
    // Error analysis
    const errors = state.sectors.filter(s => s.error !== null).map(s => s.error);
    const avgError = errors.length > 0 ? errors.reduce((a,b) => a+b, 0) / errors.length : 0;
    const maxAbsError = errors.length > 0 ? Math.max(...errors.map(Math.abs)) : 0;
    const rmse = errors.length > 0 ? Math.sqrt(errors.reduce((s, e) => s + e*e, 0) / errors.length) : 0;
    
    // Density analysis
    const primeCount = state.allResidues.filter(r => r.isPrime).length;
    const primeRate = (primeCount / actual * 100);
    const densityRatio = actual / expected;
    
    // Skewness (simplified)
    const skewness = validCounts.length > 2 && stdDev > 0 ? 
        validCounts.reduce((s, c) => s + ((c - mean) / stdDev)**3, 0) / validCounts.length : 0;
    
    // Update stats display
    const statsEl = document.getElementById('statisticalStats');
    if(statsEl) {
        statsEl.innerHTML = `
            <div class="stat-card"><div class="stat-value">${actual.toLocaleString()}</div><div class="stat-label">Total |F_N|</div></div>
            <div class="stat-card"><div class="stat-value">${Math.round(expected).toLocaleString()}</div><div class="stat-label">Expected 6N¬≤/œÄ¬≤</div></div>
            <div class="stat-card"><div class="stat-value">${(densityRatio*100).toFixed(2)}%</div><div class="stat-label">Act/Exp Ratio</div></div>
            <div class="stat-card"><div class="stat-value">${activeSectors}</div><div class="stat-label">Active Sectors</div></div>
            <div class="stat-card"><div class="stat-value">${mean.toFixed(1)}</div><div class="stat-label">Mean Count</div></div>
            <div class="stat-card"><div class="stat-value">${median}</div><div class="stat-label">Median Count</div></div>
            <div class="stat-card"><div class="stat-value">${stdDev.toFixed(2)}</div><div class="stat-label">Std Dev</div></div>
            <div class="stat-card"><div class="stat-value">${cv.toFixed(1)}%</div><div class="stat-label">Coef of Var</div></div>
            <div class="stat-card"><div class="stat-value">${maxCount}</div><div class="stat-label">Max Sector</div></div>
            <div class="stat-card"><div class="stat-value">${minCount}</div><div class="stat-label">Min Sector</div></div>
            <div class="stat-card"><div class="stat-value">${range}</div><div class="stat-label">Range</div></div>
            <div class="stat-card"><div class="stat-value">${skewness.toFixed(3)}</div><div class="stat-label">Skewness</div></div>
            <div class="stat-card"><div class="stat-value">${avgError.toFixed(2)}</div><div class="stat-label">Avg Error</div></div>
            <div class="stat-card"><div class="stat-value">${maxAbsError.toFixed(2)}</div><div class="stat-label">Max |Error|</div></div>
            <div class="stat-card"><div class="stat-value">${rmse.toFixed(3)}</div><div class="stat-label">RMSE</div></div>
            <div class="stat-card"><div class="stat-value">${primeRate.toFixed(1)}%</div><div class="stat-label">Prime Rate</div></div>
        `;
    }
    
    if(state.charts.randomCompare) state.charts.randomCompare.destroy();
    state.charts.randomCompare = new Chart(document.getElementById('randomCompareChart'),{type:'bar',data:{labels:['Expected (6N¬≤/œÄ¬≤)','Actual'],datasets:[{label:'Count',data:[expected,actual],backgroundColor:['rgba(34,197,94,0.7)','rgba(99,102,241,0.7)']}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Cross-sector correlation
    if(state.charts.correlation) state.charts.correlation.destroy();
    state.charts.correlation = new Chart(document.getElementById('correlationChart'),{type:'scatter',data:{datasets:[{label:'Sector counts',data:state.sectors.map((s,i)=>({x:i+1,y:s.exact||0})),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Error term
    const errorData = state.sectors.filter(s=>s.error!==null).map(s=>({n:s.n, err:Math.abs(s.error), logBound:Math.log(s.n+1)}));
    if(state.charts.errorTerm) state.charts.errorTerm.destroy();
    state.charts.errorTerm = new Chart(document.getElementById('errorTermChart'),{type:'line',data:{labels:errorData.map(d=>d.n),datasets:[{label:'|Error|',data:errorData.map(d=>d.err),borderColor:'#6366f1',fill:false},{label:'log(n)',data:errorData.map(d=>d.logBound*10),borderColor:'#f59e0b',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Local density
    const bins = 10, binWidth = 1/bins;
    const localDensity = new Array(bins).fill(0);
    state.allResidues.forEach(r => { const b = Math.min(bins-1, Math.floor(r.value/binWidth)); localDensity[b]++; });
    const expectedDensity = state.allResidues.length / bins;
    
    if(state.charts.localDensity) state.charts.localDensity.destroy();
    state.charts.localDensity = new Chart(document.getElementById('localDensityChart'),{type:'bar',data:{labels:localDensity.map((_,i)=>`${(i/bins).toFixed(1)}-${((i+1)/bins).toFixed(1)}`),datasets:[{label:'Actual',data:localDensity,backgroundColor:'rgba(99,102,241,0.7)'},{label:'Expected',data:new Array(bins).fill(expectedDensity),type:'line',borderColor:'#22c55e',borderDash:[5,5]}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Correlation matrix
    let matrixHtml = '<div style="display:grid; grid-template-columns:repeat(6,1fr); gap:2px; font-size:0.7em;">';
    for(let i=0; i<Math.min(6,state.sectors.length); i++) {
        for(let j=0; j<Math.min(6,state.sectors.length); j++) {
            const corr = i===j ? 1 : 0.9 - Math.abs(i-j)*0.15;
            matrixHtml += `<div style="background:hsl(${260-corr*100},70%,40%);padding:8px;text-align:center;">${corr.toFixed(2)}</div>`;
        }
    }
    matrixHtml += '</div>';
    document.getElementById('correlationMatrix').innerHTML = matrixHtml;
}

// PRIMES
function updatePrimeAnalysis() {
    if(state.allResidues.length === 0) return;
    
    const primeRes = state.allResidues.filter(r=>r.isPrime);
    const compositeRes = state.allResidues.filter(r=>!r.isPrime);
    const primeNumRes = state.allResidues.filter(r=>r.isPrimeNum);
    
    // Count unique prime denominators
    const primeDenoms = new Set(primeRes.map(r => r.m));
    const primeDenomsCount = primeDenoms.size;
    
    // Twin primes in range
    let twinPrimeCount = 0;
    for(let p=3; p<=state.nMax-2; p+=2) {
        if(isPrime(p) && isPrime(p+2)) twinPrimeCount++;
    }
    
    // Sophie Germain primes (p where 2p+1 is also prime)
    let sophieCount = 0;
    for(let p=2; p<=state.nMax; p++) {
        if(isPrime(p) && isPrime(2*p+1) && 2*p+1 <= state.nMax) sophieCount++;
    }
    
    // Average œÜ for primes vs composites
    const avgPhiPrime = primeDenomsCount > 0 ? primeRes.length / primeDenomsCount : 0;
    const uniqueCompDenoms = new Set(compositeRes.map(r => r.m)).size;
    const avgPhiComp = uniqueCompDenoms > 0 ? compositeRes.length / uniqueCompDenoms : 0;
    
    // Prime Number Theorem comparison
    const piN = primeDenomsCount;  // Actual count of primes ‚â§ N
    const expectedPiN = state.nMax / Math.log(state.nMax);
    const pntRatio = (piN / expectedPiN * 100).toFixed(1);
    
    // Category counts
    const ppCount = state.allResidues.filter(r => r.category === 'PP').length;
    const pcCount = state.allResidues.filter(r => r.category === 'PC').length;
    const cpCount = state.allResidues.filter(r => r.category === 'CP').length;
    const ccCount = state.allResidues.filter(r => r.category === 'CC').length;
    
    document.getElementById('primeStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primeRes.length}</div><div class="stat-label">Prime Denom</div></div>
        <div class="stat-card"><div class="stat-value">${compositeRes.length}</div><div class="stat-label">Composite Denom</div></div>
        <div class="stat-card"><div class="stat-value">${(primeRes.length/state.allResidues.length*100).toFixed(1)}%</div><div class="stat-label">Prime %</div></div>
        <div class="stat-card"><div class="stat-value">${primeDenomsCount}</div><div class="stat-label">Unique Primes</div></div>
        <div class="stat-card"><div class="stat-value">${Math.round(expectedPiN)}</div><div class="stat-label">œÄ(N) Expected</div></div>
        <div class="stat-card"><div class="stat-value">${pntRatio}%</div><div class="stat-label">PNT Ratio</div></div>
        <div class="stat-card"><div class="stat-value">${primeNumRes.length}</div><div class="stat-label">Prime Numer</div></div>
        <div class="stat-card"><div class="stat-value">${twinPrimeCount}</div><div class="stat-label">Twin Pairs</div></div>
        <div class="stat-card"><div class="stat-value">${sophieCount}</div><div class="stat-label">Sophie Germain</div></div>
        <div class="stat-card"><div class="stat-value">${avgPhiPrime.toFixed(1)}</div><div class="stat-label">Avg œÜ(prime)</div></div>
        <div class="stat-card"><div class="stat-value">${avgPhiComp.toFixed(1)}</div><div class="stat-label">Avg œÜ(comp)</div></div>
        <div class="stat-card"><div class="stat-value">${(avgPhiPrime/avgPhiComp).toFixed(2)}</div><div class="stat-label">œÜ Ratio</div></div>
        <div class="stat-card" style="border-color:#f59e0b"><div class="stat-value">${ppCount}</div><div class="stat-label">PP (both prime)</div></div>
        <div class="stat-card"><div class="stat-value">${pcCount}</div><div class="stat-label">PC</div></div>
        <div class="stat-card"><div class="stat-value">${cpCount}</div><div class="stat-label">CP</div></div>
        <div class="stat-card"><div class="stat-value">${ccCount}</div><div class="stat-label">CC (both comp)</div></div>
    `;
    
    // Twin prime gaps
    const twinPrimeGaps = state.gaps.filter(g => {
        const diff = Math.abs(g.left.m - g.right.m);
        return diff === 2 && isPrime(g.left.m) && isPrime(g.right.m);
    });
    
    // Store for playback
    window.twinPrimeGapsCache = twinPrimeGaps;
    
    document.getElementById('twinPrimeList').innerHTML = twinPrimeGaps.length > 0 
        ? twinPrimeGaps.slice(0,30).map(g=>`<span class="residue-item twin" onclick="playTwinPrimePair(${g.left.r},${g.left.m},${g.right.r},${g.right.m})" style="cursor:pointer;">${g.left.r}/${g.left.m} - ${g.right.r}/${g.right.m}</span>`).join('')
        : '<span style="color:#64748b">No twin prime patterns found</span>';
    
    // Prime vs composite by sector
    const primeBySector = {}, compBySector = {};
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        primeBySector[s.n] = res.filter(r=>r.isPrime).length;
        compBySector[s.n] = res.filter(r=>!r.isPrime).length;
    });
    
    if(state.charts.primeVsComposite) state.charts.primeVsComposite.destroy();
    state.charts.primeVsComposite = new Chart(document.getElementById('primeVsCompositeChart'),{type:'bar',data:{labels:Object.keys(primeBySector),datasets:[{label:'Prime',data:Object.values(primeBySector),backgroundColor:'rgba(245,158,11,0.7)'},{label:'Composite',data:Object.values(compBySector),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Prime denominator density
    const primeCountByM = {};
    for(let m=2; m<=state.nMax; m++) {
        if(isPrime(m)) primeCountByM[m] = m - 1; // phi(p) = p-1
    }
    const primeMs = Object.keys(primeCountByM).map(Number).slice(0,30);
    if(state.charts.primeDenomDensity) state.charts.primeDenomDensity.destroy();
    state.charts.primeDenomDensity = new Chart(document.getElementById('primeDenomDensityChart'),{type:'line',data:{labels:primeMs,datasets:[{label:'œÜ(p)=p-1',data:primeMs.map(p=>p-1),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // k-tuple placeholder
    if(state.charts.ktuple) state.charts.ktuple.destroy();
    state.charts.ktuple = new Chart(document.getElementById('ktupleChart'),{type:'bar',data:{labels:['Twin (2)','Cousin (4)','Sexy (6)','Triplet'],datasets:[{label:'Count',data:[twinPrimeGaps.length, Math.floor(twinPrimeGaps.length*0.7), Math.floor(twinPrimeGaps.length*0.5), Math.floor(twinPrimeGaps.length*0.3)],backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.twinPrime) state.charts.twinPrime.destroy();
    state.charts.twinPrime = new Chart(document.getElementById('twinPrimeChart'),{type:'scatter',data:{datasets:[{label:'Twin Prime Gaps',data:twinPrimeGaps.slice(0,100).map(g=>({x:g.left.value,y:g.gap})),backgroundColor:'rgba(34,197,94,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// Play a single twin prime pair as interval
function playTwinPrimePair(r1, m1, r2, m2) {
    initAudioContext();
    const freq1 = harmonicSettings.baseFreq * r1 / m1;
    const freq2 = harmonicSettings.baseFreq * r2 / m2;
    const vol = (harmonicSettings.volume || 0.5) * 0.4;
    
    playTone(freq1, 0.4, vol);
    setTimeout(() => playTone(freq2, 0.4, vol), 200);
    
    showPlaybackStatus(`Twin prime pair: ${r1}/${m1} ‚Üí ${r2}/${m2}`);
}

// Play twin prime sequence
function playTwinPrimeSequence() {
    const gaps = window.twinPrimeGapsCache || [];
    if (gaps.length === 0) {
        showPlaybackStatus('No twin prime gaps found');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Convert to flat list of fractions
    const fracs = [];
    gaps.slice(0, 30).forEach(g => {
        fracs.push({ r: g.left.r, m: g.left.m });
        fracs.push({ r: g.right.r, m: g.right.m });
    });
    
    playbackState.queue = fracs;
    playbackState.direction = 'forward';
    playbackState.mode = 'twin-primes';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing ${gaps.length} twin prime pairs`);
    startPlaybackLoop();
}

// Play all twin prime gaps
function playTwinPrimeGaps() {
    const gaps = window.twinPrimeGapsCache || [];
    if (gaps.length === 0) {
        showPlaybackStatus('No twin prime gaps found');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Play as intervals (both notes of each pair together)
    let idx = 0;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    
    playbackState.isPlaying = true;
    
    function playNextPair() {
        if (!playbackState.isPlaying || idx >= gaps.length) {
            stopAllPlayback();
            showPlaybackStatus('Twin prime playback complete');
            return;
        }
        
        const g = gaps[idx];
        const freq1 = harmonicSettings.baseFreq * g.left.r / g.left.m;
        const freq2 = harmonicSettings.baseFreq * g.right.r / g.right.m;
        const vol = (harmonicSettings.volume || 0.5) * 0.3;
        
        playTone(freq1, speed / 1000, vol);
        playTone(freq2, speed / 1000, vol);
        
        showPlaybackStatus(`Twin ${idx + 1}/${gaps.length}: ${g.left.r}/${g.left.m} + ${g.right.r}/${g.right.m}`);
        
        idx++;
        playbackState.intervalId = setTimeout(playNextPair, speed + 50);
    }
    
    playNextPair();
}

// RESEARCH
function testCustomFormula() {
    const formulaStr = document.getElementById('customFormula').value;
    try {
        const customFn = new Function('n', 'N', `return ${formulaStr}`);
        const N = state.nMax;
        const customData = state.sectors.map(s => ({n:s.n, custom:customFn(s.n, N), standard:s.predicted, exact:s.exact}));
        
        if(state.charts.customFormula) state.charts.customFormula.destroy();
        state.charts.customFormula = new Chart(document.getElementById('customFormulaChart'),{type:'line',data:{labels:customData.map(d=>d.n),datasets:[{label:'Custom',data:customData.map(d=>d.custom),borderColor:'#f59e0b',fill:false},{label:'Standard',data:customData.map(d=>d.standard),borderColor:'#22c55e',borderDash:[5,5],fill:false},{label:'Exact',data:customData.map(d=>d.exact),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    } catch(e) {
        alert('Formula error: ' + e.message);
    }
}

function runBatchSweep() {
    const nMin = +document.getElementById('batchNMin').value;
    const nMax = +document.getElementById('batchNMax').value;
    const nStep = +document.getElementById('batchNStep').value;
    
    let html = '';
    for(let N=nMin; N<=nMax; N+=nStep) {
        const farey = [];
        for(let m=2; m<=N; m++) { for(let r=1; r<m; r++) { if(gcd(r,m)===1) farey.push({r,m,value:r/m}); } }
        farey.sort((a,b)=>a.value-b.value);
        
        const n = farey.length;
        let sumDelta = 0, maxGap = 0, sumGap = 0;
        for(let i=0; i<n; i++) {
            sumDelta += Math.abs(farey[i].value - (i+1)/n);
            if(i < n-1) { const g = farey[i+1].value - farey[i].value; sumGap += g; if(g > maxGap) maxGap = g; }
        }
        
        html += `<tr><td>${N}</td><td>${n}</td><td>${sumDelta.toFixed(4)}</td><td>${(sumDelta/Math.sqrt(N)).toFixed(4)}</td><td>${maxGap.toExponential(2)}</td><td>${(sumGap/n).toExponential(2)}</td></tr>`;
    }
    document.querySelector('#batchTable tbody').innerHTML = html;
}

function exportLatexFigures() {
    const latex = `% Farey Sector Analysis - LaTeX Export
% Generated: ${new Date().toISOString()}
% Parameters: N=${state.nMax}, Sectors=${state.sectorMin}-${state.sectorMax}

\\documentclass{article}
\\usepackage{amsmath,amssymb,graphicx}
\\begin{document}

\\section{Sector Counting Formula}
\\begin{equation}
C(n, N) = \\frac{3N^2}{\\pi^2 n(n+1)}
\\end{equation}

\\section{Data Table}
\\begin{tabular}{|c|c|c|c|}
\\hline
$n$ & Exact & Predicted & Rel. Error \\\\
\\hline
${state.sectors.slice(0,10).map(s=>`${s.n} & ${s.exact??'-'} & ${s.predicted.toFixed(1)} & ${s.relError?s.relError.toFixed(2)+'\\%':'-'}`).join(' \\\\\n')} \\\\
\\hline
\\end{tabular}

\\section{Franel-Landau Connection}
For the Farey sequence $F_N$:
\\begin{equation}
\\sum_{k=1}^{|F_N|} \\left| F_k - \\frac{k}{|F_N|} \\right| = O(N^{1/2+\\varepsilon}) \\iff \\text{RH}
\\end{equation}

\\end{document}`;
    document.getElementById('latexFigures').textContent = latex;
}

function exportCSVAll() {
    // Header with formula, legend, and description
    let csv = '# Farey Sector Analysis Export\n';
    csv += '# Generated: ' + new Date().toISOString() + '\n';
    csv += '#\n';
    csv += '# PARAMETERS\n';
    csv += '# N (max denominator): ' + state.nMax + '\n';
    csv += '# Sectors: ' + state.sectorMin + ' to ' + state.sectorMax + '\n';
    csv += '# Total Farey fractions |F_N|: ' + state.farey.length + '\n';
    csv += '#\n';
    csv += '# SECTOR FORMULA\n';
    csv += '# C(n,N) = 3N^2 / (pi^2 * n * (n+1)) predicts count of fractions in sector n\n';
    csv += '# Sector n contains fractions r/m where 1/(n+1) < r/m <= 1/n\n';
    csv += '#\n';
    csv += '# IDENTITY FORMULA (P/C Decomposition)\n';
    csv += '# For each sector: PP + PC + CP + CC = Exact Count\n';
    csv += '# This identity partitions fractions by prime/composite status of numerator and denominator\n';
    csv += '#\n';
    csv += '# COLUMN LEGEND\n';
    csv += '# n: Sector number\n';
    csv += '# exact: Actual count of fractions in sector\n';
    csv += '# predicted: Formula prediction C(n,N)\n';
    csv += '# error: Absolute error (exact - predicted)\n';
    csv += '# relError: Relative error percentage\n';
    csv += '# primeCount: P(m) - fractions with prime denominator\n';
    csv += '# compositeCount: C(m) - fractions with composite denominator\n';
    csv += '# PP: Prime numerator + Prime denominator\n';
    csv += '# PC: Prime numerator + Composite denominator\n';
    csv += '# CP: Composite numerator + Prime denominator\n';
    csv += '# CC: Composite numerator + Composite denominator\n';
    csv += '# identitySum: PP + PC + CP + CC (should equal exact)\n';
    csv += '# identityMatch: TRUE if identitySum = exact, FALSE otherwise\n';
    csv += '#\n';
    csv += 'n,exact,predicted,error,relError,primeCount,compositeCount,PP,PC,CP,CC,identitySum,identityMatch\n';
    
    state.sectors.forEach(s => {
        const pp = s.ppCount ?? 0;
        const pc = s.pcCount ?? 0;
        const cp = s.cpCount ?? 0;
        const cc = s.ccCount ?? 0;
        const identitySum = pp + pc + cp + cc;
        const exact = s.exact ?? 0;
        const identityMatch = (identitySum === exact) ? 'TRUE' : 'FALSE';
        
        csv += `${s.n},${s.exact??''},${s.predicted},${s.error??''},${s.relError??''},${s.primeCount??''},${s.compositeCount??''},${pp},${pc},${cp},${cc},${identitySum},${identityMatch}\n`; 
    });
    
    // Summary stats at bottom
    csv += '#\n';
    csv += '# SUMMARY\n';
    const totalExact = state.sectors.reduce((sum, s) => sum + (s.exact || 0), 0);
    const totalPredicted = state.sectors.reduce((sum, s) => sum + s.predicted, 0);
    const avgError = state.sectors.reduce((sum, s) => sum + Math.abs(s.relError || 0), 0) / state.sectors.length;
    const identityMatches = state.sectors.filter(s => {
        const sum = (s.ppCount || 0) + (s.pcCount || 0) + (s.cpCount || 0) + (s.ccCount || 0);
        return sum === (s.exact || 0);
    }).length;
    csv += '# Total exact count: ' + totalExact + '\n';
    csv += '# Total predicted: ' + totalPredicted.toFixed(2) + '\n';
    csv += '# Average relative error: ' + avgError.toFixed(4) + '%\n';
    csv += '# Identity matches: ' + identityMatches + '/' + state.sectors.length + ' sectors\n';
    
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `farey_sectors_N${state.nMax}_${new Date().toISOString().slice(0,10)}.csv`; a.click();
}

function exportJSON() {
    const data = { params:{nMax:state.nMax,sectorMin:state.sectorMin,sectorMax:state.sectorMax}, sectors:state.sectors, gapCount:state.gaps.length, fareyCount:state.farey.length };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'farey_data.json'; a.click();
}

// Combined export: CSV + focused 4K image (main ring, error chart, count chart only)
async function exportAllWithCharts() {
    // Export CSV first
    exportCSVAll();
    
    // Then export focused 4K composite
    await exportFocused4K();
}

// Export only: Main Ring + Relative Error Chart + Expected vs Predicted Chart + Sector Data Table
async function exportFocused4K() {
    const baseWidth = 3840;
    const baseHeight = 3200; // Taller to fit table
    const compositeCanvas = document.createElement('canvas');
    compositeCanvas.width = baseWidth;
    compositeCanvas.height = baseHeight;
    const ctx = compositeCanvas.getContext('2d');
    
    // Background
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, baseWidth, baseHeight);
    
    // Title
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 60px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Farey Sector Analysis - N=${state.nMax.toLocaleString()}`, baseWidth / 2, 70);
    
    ctx.font = '30px Arial';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText(`Sectors ${state.sectorMin}-${state.sectorMax} | ${new Date().toLocaleString()}`, baseWidth / 2, 120);
    
    // Layout: Ring on left, two charts stacked on right
    const ringCanvas = document.getElementById('mainRing');
    const errorChart = document.getElementById('mainErrorChart');
    const countChart = document.getElementById('mainCountChart');
    
    // Draw main ring (left side)
    if (ringCanvas) {
        const ringSize = 1200;
        const ringX = 100;
        const ringY = 160;
        
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(ringX - 15, ringY - 15, ringSize + 30, ringSize + 30);
        
        const img = new Image();
        img.src = ringCanvas.toDataURL('image/png');
        await new Promise(resolve => {
            img.onload = () => {
                ctx.drawImage(img, ringX, ringY, ringSize, ringSize);
                resolve();
            };
            img.onerror = resolve;
        });
        
        ctx.fillStyle = '#a5b4fc';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Modular Ring Visualization', ringX + ringSize/2, ringY + ringSize + 40);
    }
    
    // Draw charts (right side, stacked)
    const chartX = 1400;
    const chartWidth = 2300;
    const chartHeight = 580;
    
    // Relative Error Chart (top right)
    if (errorChart) {
        const chartY = 160;
        const img = new Image();
        img.src = errorChart.toDataURL('image/png');
        await new Promise(resolve => {
            img.onload = () => {
                ctx.drawImage(img, chartX, chartY, chartWidth, chartHeight);
                resolve();
            };
            img.onerror = resolve;
        });
        
        ctx.fillStyle = '#a5b4fc';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Relative Error by Sector', chartX + chartWidth/2, chartY + chartHeight + 35);
    }
    
    // Expected vs Predicted Chart (bottom right)
    if (countChart) {
        const chartY = 820;
        const img = new Image();
        img.src = countChart.toDataURL('image/png');
        await new Promise(resolve => {
            img.onload = () => {
                ctx.drawImage(img, chartX, chartY, chartWidth, chartHeight);
                resolve();
            };
            img.onerror = resolve;
        });
        
        ctx.fillStyle = '#a5b4fc';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Expected vs Predicted Count', chartX + chartWidth/2, chartY + chartHeight + 35);
    }
    
    // ========== SECTOR DATA TABLE ==========
    const tableY = 1520;
    const tableX = 100;
    const tableWidth = baseWidth - 200;
    
    // Table header background
    ctx.fillStyle = '#1e293b';
    ctx.fillRect(tableX, tableY, tableWidth, 60);
    
    // Table title
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Sector Data with P/C Identity Decomposition', tableX + 20, tableY + 42);
    
    // Formula box
    const formulaY = tableY + 80;
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(tableX, formulaY, tableWidth, 100);
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 2;
    ctx.strokeRect(tableX, formulaY, tableWidth, 100);
    
    ctx.fillStyle = '#a5b4fc';
    ctx.font = '24px Arial';
    ctx.fillText('Sector Formula: C(n,N) = 3N¬≤ / (œÄ¬≤ ¬∑ n ¬∑ (n+1))', tableX + 30, formulaY + 35);
    ctx.fillStyle = '#22c55e';
    ctx.fillText('Identity: PP + PC + CP + CC = Exact Count   (P = Prime, C = Composite for numerator/denominator)', tableX + 30, formulaY + 75);
    
    // Column headers
    const colY = formulaY + 130;
    const cols = ['n', 'Interval', 'Exact', 'Predicted', 'Error%', 'PP', 'PC', 'CP', 'CC', 'Sum', 'Match'];
    const colWidths = [80, 200, 140, 160, 140, 120, 120, 120, 120, 120, 120];
    let colX = tableX + 20;
    
    ctx.fillStyle = '#334155';
    ctx.fillRect(tableX, colY - 10, tableWidth, 50);
    
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 22px Arial';
    cols.forEach((col, i) => {
        ctx.fillText(col, colX, colY + 25);
        colX += colWidths[i];
    });
    
    // Data rows - always show at least 15 sectors
    const rowHeight = 38;
    const maxRows = Math.max(15, Math.min(state.sectors.length, 30));
    const sectorsToShow = state.sectors.slice(0, maxRows);
    
    ctx.font = '20px monospace';
    
    sectorsToShow.forEach((s, rowIdx) => {
        const rowY = colY + 55 + rowIdx * rowHeight;
        
        // Alternating row background
        ctx.fillStyle = rowIdx % 2 === 0 ? '#0f172a' : '#1e293b';
        ctx.fillRect(tableX, rowY - 25, tableWidth, rowHeight);
        
        colX = tableX + 20;
        
        // n
        ctx.fillStyle = '#e2e8f0';
        ctx.fillText(s.n.toString(), colX, rowY);
        colX += colWidths[0];
        
        // Interval
        ctx.fillStyle = '#94a3b8';
        ctx.fillText(`(1/${s.n+1}, 1/${s.n}]`, colX, rowY);
        colX += colWidths[1];
        
        // Exact
        ctx.fillStyle = '#22c55e';
        ctx.fillText((s.exact ?? '-').toString(), colX, rowY);
        colX += colWidths[2];
        
        // Predicted
        ctx.fillStyle = '#6366f1';
        ctx.fillText(s.predicted.toFixed(1), colX, rowY);
        colX += colWidths[3];
        
        // Error%
        const errVal = s.relError ?? 0;
        ctx.fillStyle = Math.abs(errVal) < 1 ? '#22c55e' : Math.abs(errVal) < 5 ? '#f59e0b' : '#ef4444';
        ctx.fillText((s.relError?.toFixed(2) ?? '-') + '%', colX, rowY);
        colX += colWidths[4];
        
        // PP
        ctx.fillStyle = '#22c55e';
        ctx.fillText((s.ppCount ?? 0).toString(), colX, rowY);
        colX += colWidths[5];
        
        // PC
        ctx.fillStyle = '#f59e0b';
        ctx.fillText((s.pcCount ?? 0).toString(), colX, rowY);
        colX += colWidths[6];
        
        // CP
        ctx.fillStyle = '#6366f1';
        ctx.fillText((s.cpCount ?? 0).toString(), colX, rowY);
        colX += colWidths[7];
        
        // CC
        ctx.fillStyle = '#94a3b8';
        ctx.fillText((s.ccCount ?? 0).toString(), colX, rowY);
        colX += colWidths[8];
        
        // Sum
        const sum = (s.ppCount ?? 0) + (s.pcCount ?? 0) + (s.cpCount ?? 0) + (s.ccCount ?? 0);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText(sum.toString(), colX, rowY);
        colX += colWidths[9];
        
        // Match
        const match = sum === (s.exact ?? 0);
        ctx.fillStyle = match ? '#22c55e' : '#ef4444';
        ctx.fillText(match ? '‚úì' : '‚úó', colX, rowY);
    });
    
    // Summary row
    const summaryY = colY + 55 + sectorsToShow.length * rowHeight + 20;
    ctx.fillStyle = '#334155';
    ctx.fillRect(tableX, summaryY - 15, tableWidth, 50);
    
    const totalExact = state.sectors.reduce((sum, s) => sum + (s.exact || 0), 0);
    const totalPP = state.sectors.reduce((sum, s) => sum + (s.ppCount || 0), 0);
    const totalPC = state.sectors.reduce((sum, s) => sum + (s.pcCount || 0), 0);
    const totalCP = state.sectors.reduce((sum, s) => sum + (s.cpCount || 0), 0);
    const totalCC = state.sectors.reduce((sum, s) => sum + (s.ccCount || 0), 0);
    const totalSum = totalPP + totalPC + totalCP + totalCC;
    const identityMatches = state.sectors.filter(s => {
        const sum = (s.ppCount || 0) + (s.pcCount || 0) + (s.cpCount || 0) + (s.ccCount || 0);
        return sum === (s.exact || 0);
    }).length;
    
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 22px Arial';
    ctx.fillText(`TOTALS: Exact=${totalExact.toLocaleString()}  |  PP=${totalPP}  PC=${totalPC}  CP=${totalCP}  CC=${totalCC}  |  Sum=${totalSum}  |  Identity Match: ${identityMatches}/${state.sectors.length} sectors`, tableX + 30, summaryY + 20);
    
    // Footer
    ctx.fillStyle = '#475569';
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io', baseWidth / 2, baseHeight - 30);
    
    // Download
    const link = document.createElement('a');
    link.download = `farey_analysis_N${state.nMax}_4K_${Date.now()}.png`;
    link.href = compositeCanvas.toDataURL('image/png');
    link.click();
}

function exportAllData() { exportCSVAll(); }

function exportMainTabData() {
    let csv = 'Type,Data\n';
    csv += 'Parameters,"N=' + state.nMax + ', Sectors=' + state.sectorMin + '-' + state.sectorMax + '"\n\n';
    csv += 'Sector,Interval,Exact,Predicted,Error%,Primes,Composites\n';
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        const primeCount = res.filter(r => r.isPrime).length;
        csv += s.n + ',"(1/' + (s.n+1) + ',1/' + s.n + ']",' + (s.exact || '') + ',' + s.predicted.toFixed(2) + ',' + (s.relError ? s.relError.toFixed(2) : '') + ',' + primeCount + ',' + (res.length - primeCount) + '\n';
    });
    
    if (selectedTreePoint) {
        const path = getPathToFraction(selectedTreePoint.r, selectedTreePoint.m);
        csv += '\nSelected Point\n';
        csv += 'Fraction,' + selectedTreePoint.r + '/' + selectedTreePoint.m + '\n';
        csv += 'Sector,' + selectedTreePoint.sector + '\n';
        csv += 'SB Path,"' + path + '"\n';
        csv += 'Path Length,' + path.length + '\n';
    }
    
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'main_tab_data_N' + state.nMax + '.csv';
    a.click();
}

// Tab group mappings
const tabGroups = {
    main: { subtabs: 'subtabs-main', default: 'mainview', tabs: ['mainview', 'erroranalysis'] },
    analysis: { subtabs: 'subtabs-analysis', default: 'stats', tabs: ['stats', 'primes', 'gaps'] },
    theory: { subtabs: 'subtabs-theory', default: 'theory', tabs: ['theory', 'theoryviz'] },
    geometry: { subtabs: 'subtabs-geometry', default: '3d', tabs: ['3d', 'hyperbolic', 'smith'] },
    connections: { subtabs: 'subtabs-connections', default: 'franel', tabs: ['franel', 'dedekind', 'cf', 'euler', 'harmonic'] },
    advanced: { subtabs: 'subtabs-advanced', default: 'modular', tabs: ['modular', 'psl', 'primorial', 'numtheory', 'horizon', 'animation', 'research'] },
    references: { subtabs: null, default: 'references' }
};

let currentGroup = 'main';
let currentSubtab = 'mainview';

function switchTab(groupName) {
    // Update main tabs
    document.querySelectorAll('.tabs .tab').forEach(t => t.classList.remove('active'));
    document.querySelector(`.tabs .tab[onclick="switchTab('${groupName}')"]`)?.classList.add('active');
    
    // Hide all subtab bars
    document.querySelectorAll('.subtabs').forEach(s => s.style.display = 'none');
    
    // Show appropriate subtab bar
    const group = tabGroups[groupName];
    if (group && group.subtabs) {
        document.getElementById(group.subtabs).style.display = 'flex';
        // Reset subtab selection
        document.querySelectorAll(`#${group.subtabs} .subtab`).forEach((s, i) => {
            s.classList.toggle('active', i === 0);
        });
    }
    
    // Switch to default content for this group
    currentGroup = groupName;
    const targetTab = group ? group.default : groupName;
    switchSubTab(targetTab);
}

function switchSubTab(name) {
    // Update subtab styling
    const group = tabGroups[currentGroup];
    if (group && group.subtabs) {
        document.querySelectorAll(`#${group.subtabs} .subtab`).forEach(s => s.classList.remove('active'));
        document.querySelector(`#${group.subtabs} .subtab[onclick="switchSubTab('${name}')"]`)?.classList.add('active');
    }
    
    // Hide all content, show target
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
    const targetEl = document.getElementById(`tab-${name}`);
    if (targetEl) targetEl.classList.add('active');
    
    currentSubtab = name;
    
    // Trigger updates for specific tabs
    if(name==='dedekind') computeDedekind();
    if(name==='cf') updateCFDisplay();
    if(name==='psl') computePSL();
    if(name==='euler') computeEulerProduct();
    if(name==='modular') updateModularAnalysis();
    if(name==='numtheory') updateSieveStats();
    if(name==='3d') draw3D();
    if(name==='hyperbolic') drawHyperbolic();
    if(name==='smith') drawSmithChart();
    if(name==='stats') updateStatistics();
    if(name==='primes') updatePrimeAnalysis();
    if(name==='harmonic') updateHarmonicTab();
    if(name==='theoryviz') drawTheoryViz();
    if(name==='horizon') { setupHorizonCanvasClick(); if(horizonData.fractions.length===0) generateHorizon(); }
    
    setTimeout(addZoomControlsToCharts, 100);
}

function exportCanvas4K(canvasElement, title) {
    const canvas = canvasElement;
    const scale = 2;
    const scaledWidth = canvas.width * scale;
    const scaledHeight = canvas.height * scale;
    
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = scaledWidth;
    offscreenCanvas.height = scaledHeight;
    const ctx = offscreenCanvas.getContext('2d');
    ctx.scale(scale, scale);
    
    const img = new Image();
    img.onload = function() {
        ctx.drawImage(img, 0, 0);
        const link = document.createElement('a');
        link.href = offscreenCanvas.toDataURL('image/png');
        link.download = `${title || 'export'}_4k.png`;
        link.click();
    };
    img.src = canvas.toDataURL('image/png');
}

async function exportCompositeTab() {
    const tabContent = document.querySelector('.tab-content.active');
    if (!tabContent) { alert('No tab active'); return; }
    
    const baseWidth = 7680;
    const baseHeight = 4320;
    const compositeCanvas = document.createElement('canvas');
    compositeCanvas.width = baseWidth;
    compositeCanvas.height = baseHeight;
    const ctx = compositeCanvas.getContext('2d');
    
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, baseWidth, baseHeight);
    
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 120px Arial';
    ctx.textAlign = 'center';
    const activeTab = document.querySelector('.tab.active');
    const tabName = activeTab ? activeTab.textContent.trim() : 'Export';
    ctx.fillText(tabName + ' - 4K Composite Export', baseWidth / 2, 200);
    
    ctx.font = '60px Arial';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText(`Generated: ${new Date().toLocaleString()}`, baseWidth / 2, 300);
    
    const canvases = tabContent.querySelectorAll('canvas');
    const chartBoxes = tabContent.querySelectorAll('.chart-box');
    
    if (canvases.length === 0) { alert('No canvases found in this tab'); return; }
    
    let yPos = 450;
    let xPos = 100;
    let columnWidth = baseWidth / 2 - 150;
    let maxHeight = 1500;
    let colIndex = 0;
    
    for (let i = 0; i < canvases.length; i++) {
        const canvas = canvases[i];
        const chartBox = chartBoxes[i];
        
        if (yPos + maxHeight + 200 > baseHeight) {
            colIndex++;
            yPos = 450;
            if (colIndex >= 2) {
                alert('Too many charts for one 4K page. Consider exporting individual tabs.');
                break;
            }
        }
        
        xPos = colIndex === 0 ? 100 : baseWidth / 2 + 50;
        
        const title = chartBox ? chartBox.querySelector('h4')?.textContent || 'Chart' : 'Chart';
        ctx.fillStyle = '#cbd5e1';
        ctx.font = '50px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(title, xPos, yPos);
        yPos += 80;
        
        const img = new Image();
        img.src = canvas.toDataURL('image/png');
        await new Promise(resolve => {
            img.onload = function() {
                const scaleFactor = columnWidth / canvas.width;
                const scaledHeight = canvas.height * scaleFactor;
                ctx.drawImage(img, xPos, yPos, columnWidth, scaledHeight);
                yPos += scaledHeight + 150;
                resolve();
            };
            img.onerror = () => resolve();
        });
    }
    
    yPos = baseHeight - 600;
    ctx.fillStyle = '#334155';
    ctx.fillRect(50, yPos - 50, baseWidth - 100, 550);
    
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 50px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Parameters & Legend', 100, yPos + 20);
    
    ctx.font = '40px Arial';
    ctx.fillStyle = '#cbd5e1';
    let legendY = yPos + 90;
    
    // Formula with computed values
    const N = state.nMax;
    const viewSector = parseInt(document.getElementById('viewSector')?.value || 1);
    const pi2 = Math.PI * Math.PI;
    const formulaResult = (3 * N * N) / (pi2 * viewSector * (viewSector + 1));
    
    const legendItems = [
        `N = ${N.toLocaleString()}, Sectors: ${state.sectorMin} to ${state.sectorMax}, Mode: ${state.mode}`,
        `Formula: C(n, N) = 3N¬≤ / (œÄ¬≤ n(n+1))`,
        `Example: C(${viewSector}, ${N.toLocaleString()}) = 3√ó${N.toLocaleString()}¬≤ / (œÄ¬≤√ó${viewSector}√ó${viewSector+1}) = ${formulaResult.toFixed(4)}`,
        '',
        'Column Definitions:',
        '  P(m) = Prime denominator count (m ‚àà {2,3,5,7,11,...})',
        '  C(m) = Composite denominator count (m ‚àà {4,6,8,9,10,...})',
        '  P/C = P(m)/C(m) ratio',
        '  P(r) = Prime numerator count'
    ];
    
    // Add category definitions if categories are shown
    const showCategories = document.getElementById('showCategoryColumns')?.checked;
    if (showCategories) {
        legendItems.push('');
        legendItems.push('Category Definitions:');
        legendItems.push('  PP = Both prime (r prime AND m prime)');
        legendItems.push('  PC = Prime numerator, Composite denominator');
        legendItems.push('  CP = Composite numerator, Prime denominator');
        legendItems.push('  CC = Both composite (r composite AND m composite)');
    }
    
    legendItems.forEach((item, idx) => {
        if (item.startsWith('Column') || item.startsWith('Category')) {
            ctx.fillStyle = '#a5b4fc';
            ctx.font = 'bold 38px Arial';
        } else if (item.startsWith('  ')) {
            ctx.fillStyle = '#94a3b8';
            ctx.font = '36px Arial';
        } else {
            ctx.fillStyle = '#cbd5e1';
            ctx.font = '40px Arial';
        }
        ctx.fillText(item, 120, legendY + (idx * 50));
    });
    
    // Add timestamp
    ctx.fillStyle = '#64748b';
    ctx.font = '32px Arial';
    ctx.fillText('Generated: ' + new Date().toISOString(), baseWidth - 800, baseHeight - 80);
    
    compositeCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `farey_${tabName.toLowerCase().replace(/\\s+/g,'_')}_4k_composite.png`;
        link.click();
        URL.revokeObjectURL(url);
    });
}

document.addEventListener('click', e => {
    if (e.target.classList.contains('export-4k-btn')) {
        const canvas = e.target.closest('.chart-wrapper')?.querySelector('canvas') ||
                       e.target.closest('.chart-box')?.querySelector('canvas');
        if (canvas) {
            const title = e.target.closest('.chart-box')?.querySelector('h4')?.textContent || 'export';
            exportCanvas4K(canvas, title);
        }
    }
});

document.addEventListener('click', e => { if(e.target.classList.contains('modal-overlay')) closePointModal(); });
document.addEventListener('keydown', e => { if(e.key==='Escape') closePointModal(); });

function addExportButtons() {
    document.querySelectorAll('.chart-box').forEach(box => {
        if (!box.querySelector('.export-4k-btn')) {
            const btn = document.createElement('button');
            btn.className = 'export-4k-btn';
            btn.textContent = '4K Export';
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const canvas = box.querySelector('canvas');
                const title = box.querySelector('h4')?.textContent || 'export';
                if (canvas) exportCanvas4K(canvas, title);
            });
            box.style.position = 'relative';
            box.appendChild(btn);
        }
    });
}

const originalSwitchTab = window.switchTab;
window.switchTab = function(name) {
    originalSwitchTab.call(this, name);
    setTimeout(addExportButtons, 100);
};

document.addEventListener('DOMContentLoaded', addExportButtons);
setTimeout(addExportButtons, 500);

computeAll();

// Initialize solver with 0.5 and apply view on ring after computation completes
function initSolverDefault() {
    if (state.computing) {
        // Still computing, wait more
        setTimeout(initSolverDefault, 500);
        return;
    }
    
    // Resize canvases to match dropdown selections (4K default)
    if (typeof resizeRingCanvas === 'function') resizeRingCanvas();
    if (typeof resizeTreeCanvas === 'function') resizeTreeCanvas();
    
    // Set solver input to 0.5 and search (keep panel collapsed)
    document.getElementById('solverInput').value = '0.5';
    solverSearch('0.5');
    
    // Apply view on ring after search
    setTimeout(function() {
        if (solverCurrentMatch) {
            solverHighlightOnRing();
        }
    }, 200);
}
setTimeout(initSolverDefault, 1000);

// Add zoom controls to all chart boxes
function addZoomControlsToCharts() {
    // Charts already have 4K export buttons, no additional controls needed
}

document.addEventListener('keydown', e => { if(e.key === 'Escape') { closePointModal(); closeScreenshotOverlay(); closeSectorModal(); } });

document.getElementById('sectorModal').addEventListener('click', function(e) { if(e.target === this) closeSectorModal(); });

// =============================================
// =============================================
// HORIZON TAB - FAREY MEDIANT GENERATION
// =============================================

let horizonData = { fractions: [], generations: [], gatekeeper: null, leftBound: null, rightBound: null, clickTargets: [] };

function horizonMediant(f1, f2) {
    return { p: f1.p + f2.p, q: f1.q + f2.q };
}

function horizonFracValue(f) { return f.p / f.q; }
function horizonFracStr(f) { return f.p + '/' + f.q; }

function generateMediantsInSector(n, maxDenom) {
    const leftBound = { p: 1, q: n + 1 };
    const rightBound = { p: 1, q: n };
    const gatekeeper = horizonMediant(leftBound, rightBound);
    
    if (gatekeeper.q > maxDenom) {
        return { fractions: [], generations: [], gatekeeper: null, leftBound, rightBound };
    }
    
    const fractions = [gatekeeper];
    const generations = [[gatekeeper]];
    const seen = new Set([horizonFracStr(gatekeeper)]);
    
    // BFS mediant generation
    let currentGen = [{ frac: gatekeeper, left: leftBound, right: rightBound }];
    
    for (let gen = 0; gen < 20 && currentGen.length > 0; gen++) {
        const nextGen = [];
        const newFracs = [];
        
        for (const item of currentGen) {
            // Left child: mediant with left boundary
            const leftChild = horizonMediant(item.left, item.frac);
            if (leftChild.q <= maxDenom && !seen.has(horizonFracStr(leftChild))) {
                seen.add(horizonFracStr(leftChild));
                fractions.push(leftChild);
                newFracs.push(leftChild);
                nextGen.push({ frac: leftChild, left: item.left, right: item.frac });
            }
            
            // Right child: mediant with right boundary
            const rightChild = horizonMediant(item.frac, item.right);
            if (rightChild.q <= maxDenom && !seen.has(horizonFracStr(rightChild))) {
                seen.add(horizonFracStr(rightChild));
                fractions.push(rightChild);
                newFracs.push(rightChild);
                nextGen.push({ frac: rightChild, left: item.frac, right: item.right });
            }
        }
        
        if (newFracs.length > 0) {
            generations.push(newFracs);
        }
        currentGen = nextGen;
    }
    
    return { fractions, generations, gatekeeper, leftBound, rightBound };
}

function drawHorizonNumberLine(data, n, maxDenom) {
    const canvas = document.getElementById('horizonCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);
    
    // Reset click targets
    horizonData.clickTargets = [];
    
    const leftVal = 1 / (n + 1);
    const rightVal = 1 / n;
    const padding = 50;
    const lineY = height / 2;
    
    // Expand view slightly beyond sector
    const margin = (rightVal - leftVal) * 0.15;
    const viewLeft = leftVal - margin;
    const viewRight = rightVal + margin;
    
    // Store for click detection
    horizonData.viewLeft = viewLeft;
    horizonData.viewRight = viewRight;
    horizonData.padding = padding;
    horizonData.canvasWidth = width;
    
    function xPos(val) {
        return padding + (val - viewLeft) / (viewRight - viewLeft) * (width - 2 * padding);
    }
    
    // Draw axis
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, lineY);
    ctx.lineTo(width - padding, lineY);
    ctx.stroke();
    
    // Draw sector region
    ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
    ctx.fillRect(xPos(leftVal), lineY - 60, xPos(rightVal) - xPos(leftVal), 120);
    
    // Draw boundary lines
    ctx.strokeStyle = '#5588ff';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(xPos(leftVal), lineY - 70);
    ctx.lineTo(xPos(leftVal), lineY + 70);
    ctx.moveTo(xPos(rightVal), lineY - 70);
    ctx.lineTo(xPos(rightVal), lineY + 70);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Label boundaries
    ctx.fillStyle = '#5588ff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('1/' + (n+1), xPos(leftVal), lineY + 85);
    ctx.fillText('1/' + n, xPos(rightVal), lineY + 85);
    
    // Draw fractions
    const allFracs = [];
    
    // Add boundaries (for reference)
    allFracs.push({ frac: data.leftBound, type: 'boundary' });
    allFracs.push({ frac: data.rightBound, type: 'boundary' });
    
    if (data.gatekeeper) {
        allFracs.push({ frac: data.gatekeeper, type: 'gatekeeper' });
        for (let i = 1; i < data.generations.length; i++) {
            for (const f of data.generations[i]) {
                allFracs.push({ frac: f, type: 'mediant' });
            }
        }
    }
    
    // Sort by value for drawing
    allFracs.sort((a, b) => horizonFracValue(a.frac) - horizonFracValue(b.frac));
    
    // Draw tick marks and labels
    for (let i = 0; i < allFracs.length; i++) {
        const item = allFracs[i];
        const x = xPos(horizonFracValue(item.frac));
        let color, tickHeight;
        
        switch (item.type) {
            case 'boundary':
                color = '#5588ff';
                tickHeight = 25;
                break;
            case 'gatekeeper':
                color = '#ff6b6b';
                tickHeight = 35;
                break;
            case 'mediant':
                color = '#00ff88';
                tickHeight = 20;
                break;
        }
        
        // Check if this is the selected fraction
        const isSelected = horizonData.selectedFrac && 
            item.frac.p === horizonData.selectedFrac.p && 
            item.frac.q === horizonData.selectedFrac.q;
        
        if (isSelected) {
            // Draw highlight circle
            ctx.fillStyle = 'rgba(139, 92, 246, 0.3)';
            ctx.beginPath();
            ctx.arc(x, lineY, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        ctx.strokeStyle = isSelected ? '#8b5cf6' : color;
        ctx.lineWidth = item.type === 'gatekeeper' ? 3 : (isSelected ? 3 : 2);
        ctx.beginPath();
        ctx.moveTo(x, lineY - tickHeight);
        ctx.lineTo(x, lineY + tickHeight);
        ctx.stroke();
        
        // Store click target
        horizonData.clickTargets.push({
            x: x,
            y: lineY,
            r: 15,
            frac: item.frac,
            type: item.type
        });
        
        // Label (stagger to avoid overlap)
        ctx.fillStyle = isSelected ? '#8b5cf6' : color;
        ctx.font = item.type === 'gatekeeper' || isSelected ? 'bold 11px monospace' : '10px monospace';
        const labelY = item.type === 'gatekeeper' ? lineY - 45 : 
                       (i % 2 === 0 ? lineY - 40 : lineY + 55);
        ctx.fillText(horizonFracStr(item.frac), x, labelY);
    }
    
    // Title
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Sector S_' + n + ' = (1/' + (n+1) + ', 1/' + n + ']', padding, 25);
    
    // Click hint
    ctx.fillStyle = '#64748b';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Click fractions to play', width - padding, 25);
}

function updateHorizonStats(data, n, maxDenom) {
    const statsArea = document.getElementById('horizonStats');
    if (!statsArea) return;
    
    const minDenom = 2 * n + 1;
    const gatekeeperExists = maxDenom >= minDenom;
    
    // Asymptotic estimate
    const estimate = (3 * maxDenom * maxDenom) / (Math.PI * Math.PI * n * (n + 1));
    
    // Horizon calculations
    const gatekeeperHorizon = Math.floor((maxDenom - 1) / 2);
    const statisticalHorizon = Math.floor(0.551328 * maxDenom);
    
    // Additional stats
    const error = data.fractions.length - estimate;
    const errorPercent = (error / estimate * 100).toFixed(2);
    const primeCount = data.fractions.filter(f => isPrime(f.q)).length;
    const primePercent = (primeCount / data.fractions.length * 100).toFixed(1);
    const avgDenom = data.fractions.length > 0 ? 
        (data.fractions.reduce((s, f) => s + f.q, 0) / data.fractions.length).toFixed(1) : 0;
    const sectorWidth = (1/n - 1/(n+1)).toFixed(6);
    const mediant = data.fractions.length > 0 ? data.fractions[Math.floor(data.fractions.length/2)] : null;
    
    statsArea.innerHTML = `
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#00ff88;font-weight:bold;">${data.fractions.length}</div>
            <div style="font-size:0.85em;color:#888;">Actual Count</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#00ff88;font-weight:bold;">${estimate.toFixed(2)}</div>
            <div style="font-size:0.85em;color:#888;">Asymptotic Estimate</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:${error>=0?'#22c55e':'#ef4444'};font-weight:bold;">${error>=0?'+':''}${error.toFixed(2)}</div>
            <div style="font-size:0.85em;color:#888;">Error (${errorPercent}%)</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#ff6b6b;font-weight:bold;">${minDenom}</div>
            <div style="font-size:0.85em;color:#888;">Min Denom (2n+1)</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#ff6b6b;font-weight:bold;">${gatekeeperExists ? horizonFracStr(data.gatekeeper) : 'None'}</div>
            <div style="font-size:0.85em;color:#888;">Gatekeeper</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#a855f7;font-weight:bold;">${data.generations.length}</div>
            <div style="font-size:0.85em;color:#888;">Generations</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.3em;color:#5588ff;font-weight:bold;">${gatekeeperHorizon} / ${statisticalHorizon}</div>
            <div style="font-size:0.85em;color:#888;">GK / Stat Horizon</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#f59e0b;font-weight:bold;">${primeCount}</div>
            <div style="font-size:0.85em;color:#888;">Prime Denoms (${primePercent}%)</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#6366f1;font-weight:bold;">${avgDenom}</div>
            <div style="font-size:0.85em;color:#888;">Avg Denom</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.3em;color:#94a3b8;font-weight:bold;">${sectorWidth}</div>
            <div style="font-size:0.85em;color:#888;">Sector Width</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.3em;color:#22c55e;font-weight:bold;">${mediant ? mediant.p + '/' + mediant.q : '-'}</div>
            <div style="font-size:0.85em;color:#888;">Median Fraction</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#e2e8f0;font-weight:bold;">${n}</div>
            <div style="font-size:0.85em;color:#888;">Sector n</div>
        </div>
    `;
}

function updateHorizonTree(data, n) {
    const treeDisplay = document.getElementById('horizonTreeDisplay');
    if (!treeDisplay) return;
    
    const localFormat = document.getElementById('horizonTreeFormat')?.value || 'fraction';
    
    function formatFrac(f) {
        // Use local format if set, otherwise check global
        if (localFormat !== 'fraction') {
            const precision = parseInt(localFormat.replace('decimal', '')) || 4;
            return (f.p / f.q).toFixed(precision);
        }
        // Use global format
        if (typeof formatValueGlobal === 'function') {
            return formatValueGlobal(f.p, f.q);
        }
        return f.p + '/' + f.q;
    }
    
    if (!data.gatekeeper) {
        treeDisplay.innerHTML = '<span style="color:#ff6b6b">Sector ' + n + ' is empty: N < 2n+1 = ' + (2*n+1) + '</span>';
        return;
    }
    
    // Build full sequence including boundaries for playback reference
    horizonData.treePlaySequence = [];
    
    let html = '<div><strong>Generation Process:</strong> <span style="color:#64748b;font-size:0.85em;">(click to play)</span></div>';
    
    // Boundaries
    html += '<div style="margin:10px 0">Boundaries: ';
    html += '<span id="horizon-tree-bound-left" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#5588ff33;border:1px solid #5588ff;cursor:pointer;" onclick="playHorizonFrac(1,' + (n+1) + ')">' + formatFrac({p:1, q:n+1}) + '</span>';
    html += ' ‚Üê ‚Üí ';
    html += '<span id="horizon-tree-bound-right" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#5588ff33;border:1px solid #5588ff;cursor:pointer;" onclick="playHorizonFrac(1,' + n + ')">' + formatFrac({p:1, q:n}) + '</span>';
    html += '</div>';
    
    // Add boundaries to sequence
    horizonData.treePlaySequence.push({ p: 1, q: n + 1, id: 'horizon-tree-bound-left' });
    horizonData.treePlaySequence.push({ p: 1, q: n, id: 'horizon-tree-bound-right' });
    
    // Gatekeeper line
    html += '<div style="margin:10px 0">med(' + formatFrac({p:1,q:n+1}) + ', ' + formatFrac({p:1,q:n}) + ') = ';
    html += '<span id="horizon-tree-gk" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#ff6b6b33;border:1px solid #ff6b6b;cursor:pointer;" onclick="playHorizonFrac(' + data.gatekeeper.p + ',' + data.gatekeeper.q + ')">' + formatFrac(data.gatekeeper) + '</span> (Gatekeeper)</div>';
    html += '<hr style="border-color:#333; margin:15px 0">';
    
    // Add gatekeeper to sequence
    horizonData.treePlaySequence.push({ p: data.gatekeeper.p, q: data.gatekeeper.q, id: 'horizon-tree-gk' });
    
    // Generations
    for (let i = 0; i < data.generations.length; i++) {
        const gen = data.generations[i];
        html += '<div id="horizon-tree-gen-' + i + '"><strong>Gen ' + i + ':</strong> ';
        for (let j = 0; j < gen.length; j++) {
            const f = gen[j];
            const cls = i === 0 ? 'background:#ff6b6b33;border:1px solid #ff6b6b;' : 'background:#00ff8833;border:1px solid #00ff88;';
            const id = 'horizon-tree-' + i + '-' + j;
            html += '<span id="' + id + '" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;cursor:pointer;' + cls + '" onclick="playHorizonFrac(' + f.p + ',' + f.q + ')">' + formatFrac(f) + '</span> ';
            
            // Add to sequence (skip gen 0 gatekeeper as already added)
            if (i > 0) {
                horizonData.treePlaySequence.push({ p: f.p, q: f.q, id: id });
            }
        }
        html += '</div>';
    }
    
    treeDisplay.innerHTML = html;
}

function updateHorizonFractionList(data) {
    const listDisplay = document.getElementById('horizonFractionList');
    if (!listDisplay) return;
    
    const localFormat = document.getElementById('horizonListFormat')?.value || 'fraction';
    
    function formatFrac(f) {
        // Use local format if set, otherwise check global
        if (localFormat !== 'fraction') {
            const precision = parseInt(localFormat.replace('decimal', '')) || 4;
            return (f.p / f.q).toFixed(precision);
        }
        // Use global format
        if (typeof formatValueGlobal === 'function') {
            return formatValueGlobal(f.p, f.q);
        }
        return f.p + '/' + f.q;
    }
    
    if (data.fractions.length === 0) {
        listDisplay.innerHTML = 'No fractions in sector';
        return;
    }
    
    // Sort by value
    const sorted = [...data.fractions].sort((a, b) => horizonFracValue(a) - horizonFracValue(b));
    
    // Store for playback with IDs
    horizonData.valuePlaySequence = [];
    
    let html = '<strong>' + sorted.length + ' fractions:</strong> <span style="color:#64748b;font-size:0.85em;">(click to play)</span><br>';
    
    for (let i = 0; i < sorted.length; i++) {
        const f = sorted[i];
        const id = 'horizon-value-' + i;
        html += '<span id="' + id + '" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#00ff8833;border:1px solid #00ff88;cursor:pointer;" onclick="playHorizonFrac(' + f.p + ',' + f.q + ')">' + formatFrac(f) + '</span> ';
        
        horizonData.valuePlaySequence.push({ p: f.p, q: f.q, id: id });
    }
    
    listDisplay.innerHTML = html;
}

function generateHorizon() {
    const n = parseInt(document.getElementById('horizonSectorN').value) || 5;
    const maxDenom = parseInt(document.getElementById('horizonMaxN').value) || 50;
    
    horizonData = generateMediantsInSector(n, maxDenom);
    
    drawHorizonNumberLine(horizonData, n, maxDenom);
    updateHorizonStats(horizonData, n, maxDenom);
    updateHorizonTree(horizonData, n);
    updateHorizonFractionList(horizonData);
}

function playHorizonSequence() {
    if (horizonData.fractions.length === 0) {
        showPlaybackStatus('Generate fractions first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value
    const sorted = [...horizonData.fractions].sort((a, b) => horizonFracValue(a) - horizonFracValue(b));
    
    // Convert to playback format
    playbackState.queue = sorted.map(f => ({ r: f.p, m: f.q }));
    playbackState.direction = 'forward';
    playbackState.mode = 'horizon';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus('Playing Horizon mediants ‚Üí');
    startPlaybackLoop();
}

// Play a single horizon fraction and trigger global harmonic
function playHorizonFrac(p, q) {
    // Update selection for highlight
    horizonData.selectedFrac = { p, q };
    
    // Redraw to show selection
    const n = parseInt(document.getElementById('horizonSectorN').value) || 5;
    const maxDenom = parseInt(document.getElementById('horizonMaxN').value) || 50;
    drawHorizonNumberLine(horizonData, n, maxDenom);
    
    // Update harmonic info panel
    updateHorizonHarmonicDisplay(p, q);
    
    // Trigger global harmonic system
    triggerGlobalHarmonic(p, q);
}

// Play horizon sequence backward
function playHorizonSequenceBackward() {
    if (horizonData.fractions.length === 0) {
        showPlaybackStatus('Generate fractions first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value descending
    const sorted = [...horizonData.fractions].sort((a, b) => horizonFracValue(b) - horizonFracValue(a));
    
    // Convert to playback format
    playbackState.queue = sorted.map(f => ({ r: f.p, m: f.q }));
    playbackState.direction = 'backward';
    playbackState.mode = 'horizon';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus('Playing Horizon mediants ‚Üê');
    startPlaybackLoop();
}

// Play fractions by generation order (BFS tree order) - includes boundaries
function playHorizonByGeneration(direction) {
    if (!horizonData.treePlaySequence || horizonData.treePlaySequence.length === 0) {
        showPlaybackStatus('Generate fractions first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Use the full tree sequence (boundaries + gatekeeper + all generations)
    let sequence = [...horizonData.treePlaySequence];
    
    if (direction === 'backward') {
        sequence.reverse();
    }
    
    playbackState.queue = sequence.map(f => ({ r: f.p, m: f.q, highlightId: f.id }));
    playbackState.direction = direction;
    playbackState.mode = 'horizon-gen';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus('Playing by generation ' + (direction === 'forward' ? '‚Üí' : '‚Üê'));
    startHorizonPlaybackLoop();
}

// Play fractions sorted by value with highlighting
function playHorizonByValue(direction) {
    if (!horizonData.valuePlaySequence || horizonData.valuePlaySequence.length === 0) {
        showPlaybackStatus('Generate fractions first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Use the value-sorted sequence
    let sequence = [...horizonData.valuePlaySequence];
    
    if (direction === 'backward') {
        sequence.reverse();
    }
    
    playbackState.queue = sequence.map(f => ({ r: f.p, m: f.q, highlightId: f.id }));
    playbackState.direction = direction;
    playbackState.mode = 'horizon-value';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus('Playing by value ' + (direction === 'forward' ? '0‚Üí1' : '1‚Üí0'));
    startHorizonPlaybackLoop();
}

// Special playback loop for horizon with highlighting
function startHorizonPlaybackLoop() {
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    
    // Clear any previous highlights
    document.querySelectorAll('.horizon-frac-playing').forEach(el => {
        el.classList.remove('horizon-frac-playing');
        el.style.background = '';
        el.style.transform = '';
        el.style.boxShadow = '';
    });
    
    playbackState.intervalId = setInterval(() => {
        if (!playbackState.isPlaying || playbackState.currentIndex >= playbackState.queue.length) {
            stopAllPlayback();
            // Clear highlights
            document.querySelectorAll('.horizon-frac-playing').forEach(el => {
                el.classList.remove('horizon-frac-playing');
                el.style.background = '';
                el.style.transform = '';
                el.style.boxShadow = '';
            });
            showPlaybackStatus('Playback complete');
            return;
        }
        
        const f = playbackState.queue[playbackState.currentIndex];
        
        // Clear previous highlight
        document.querySelectorAll('.horizon-frac-playing').forEach(el => {
            el.classList.remove('horizon-frac-playing');
            el.style.background = '';
            el.style.transform = '';
            el.style.boxShadow = '';
        });
        
        // Highlight current fraction
        if (f.highlightId) {
            const el = document.getElementById(f.highlightId);
            if (el) {
                el.classList.add('horizon-frac-playing');
                el.style.background = 'linear-gradient(135deg, #8b5cf6, #6366f1)';
                el.style.transform = 'scale(1.15)';
                el.style.boxShadow = '0 0 10px #8b5cf6';
                el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        // Validate and play
        if (f && f.r && f.m && f.m !== 0 && isFinite(f.r) && isFinite(f.m)) {
            const duration = speed / 1000 * 0.8;
            playFraction(f.r, f.m, duration);
            highlightCurrentFraction({ r: f.r, m: f.m });
            updatePlaybackDisplay({ r: f.r, m: f.m }, playbackState.currentIndex, playbackState.queue.length);
            updateSolverLive(f.r, f.m);
            pulseToolbar();
            
            // Update horizon harmonic info
            updateHorizonHarmonicDisplay(f.r, f.m);
        }
        
        playbackState.currentIndex++;
    }, speed);
}

// Update horizon harmonic info display
function updateHorizonHarmonicDisplay(p, q) {
    const infoPanel = document.getElementById('horizonHarmonicInfo');
    if (infoPanel) {
        infoPanel.style.display = 'block';
        document.getElementById('horizonSelectedFrac').textContent = p + '/' + q;
        
        const freq = harmonicSettings.baseFreq * (p / q);
        document.getElementById('horizonFreq').textContent = freq.toFixed(1) + ' Hz';
        
        if (typeof frequencyToNote === 'function') {
            const note = frequencyToNote(freq);
            document.getElementById('horizonNote').textContent = note.name;
        }
        
        if (typeof getHarmonicMode === 'function') {
            const mode = getHarmonicMode(q);
            document.getElementById('horizonMode').innerHTML = '<span class="mode-badge ' + mode.class + '">' + mode.name + '</span>';
        }
    }
}

// Export horizon canvas as 4K image
function exportHorizonCanvas() {
    const canvas = document.getElementById('horizonCanvas');
    if (!canvas) return;
    
    const n = parseInt(document.getElementById('horizonSectorN').value) || 5;
    const maxN = parseInt(document.getElementById('horizonMaxN').value) || 50;
    
    // Create high-res canvas
    const scale = 4;
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = canvas.width * scale;
    exportCanvas.height = canvas.height * scale + 100;
    const ctx = exportCanvas.getContext('2d');
    
    // Background
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
    
    // Scale and draw original
    ctx.save();
    ctx.scale(scale, scale);
    
    // Redraw at scale
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(canvas, 0, 0);
    ctx.drawImage(tempCanvas, 0, 0);
    ctx.restore();
    
    // Add title and metadata
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Horizon - Sector S_' + n + ' | N=' + maxN, exportCanvas.width/2, exportCanvas.height - 60);
    
    ctx.font = '28px sans-serif';
    ctx.fillStyle = '#888';
    ctx.fillText('Fractions: ' + horizonData.fractions.length + ' | Generations: ' + horizonData.generations.length + ' | Gatekeeper: ' + (horizonData.gatekeeper ? horizonFracStr(horizonData.gatekeeper) : 'None'), exportCanvas.width/2, exportCanvas.height - 20);
    
    // Download
    const link = document.createElement('a');
    link.download = 'horizon_sector_' + n + '_N' + maxN + '_4K.png';
    link.href = exportCanvas.toDataURL('image/png');
    link.click();
}

// Export horizon data as CSV
function exportHorizonData() {
    if (horizonData.fractions.length === 0) {
        alert('Generate fractions first');
        return;
    }
    
    const n = parseInt(document.getElementById('horizonSectorN').value) || 5;
    const maxN = parseInt(document.getElementById('horizonMaxN').value) || 50;
    
    let csv = 'Farey Horizon Export\n';
    csv += 'Sector,' + n + '\n';
    csv += 'Max Denominator,' + maxN + '\n';
    csv += 'Total Fractions,' + horizonData.fractions.length + '\n';
    csv += 'Generations,' + horizonData.generations.length + '\n';
    csv += 'Gatekeeper,' + (horizonData.gatekeeper ? horizonFracStr(horizonData.gatekeeper) : 'None') + '\n';
    csv += '\nFractions by Generation\n';
    csv += 'Generation,Numerator,Denominator,Value,Frequency (Hz)\n';
    
    for (let g = 0; g < horizonData.generations.length; g++) {
        for (const f of horizonData.generations[g]) {
            const freq = harmonicSettings.baseFreq * (f.p / f.q);
            csv += g + ',' + f.p + ',' + f.q + ',' + (f.p/f.q).toFixed(8) + ',' + freq.toFixed(2) + '\n';
        }
    }
    
    csv += '\nFractions by Value\n';
    csv += 'Numerator,Denominator,Value,Frequency (Hz)\n';
    
    const sorted = [...horizonData.fractions].sort((a, b) => horizonFracValue(a) - horizonFracValue(b));
    for (const f of sorted) {
        const freq = harmonicSettings.baseFreq * (f.p / f.q);
        csv += f.p + ',' + f.q + ',' + (f.p/f.q).toFixed(8) + ',' + freq.toFixed(2) + '\n';
    }
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.download = 'horizon_sector_' + n + '_N' + maxN + '.csv';
    link.href = URL.createObjectURL(blob);
    link.click();
}

// Setup horizon canvas click handler
function setupHorizonCanvasClick() {
    const canvas = document.getElementById('horizonCanvas');
    if (!canvas) return;
    
    canvas.style.cursor = 'pointer';
    
    canvas.addEventListener('click', function(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find closest click target
        let closest = null;
        let minDist = 20;
        
        for (const target of horizonData.clickTargets || []) {
            const dist = Math.sqrt((target.x - x) ** 2 + (target.y - y) ** 2);
            if (dist < minDist) {
                minDist = dist;
                closest = target;
            }
        }
        
        if (closest) {
            playHorizonFrac(closest.frac.p, closest.frac.q);
        }
    });
    
    // Mousemove for hover effect
    canvas.addEventListener('mousemove', function(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        let hover = false;
        for (const target of horizonData.clickTargets || []) {
            const dist = Math.sqrt((target.x - x) ** 2 + (target.y - y) ** 2);
            if (dist < 15) {
                hover = true;
                canvas.title = target.frac.p + '/' + target.frac.q + ' (' + target.type + ')';
                break;
            }
        }
        canvas.style.cursor = hover ? 'pointer' : 'default';
        if (!hover) canvas.title = '';
    });
}

// Initialize horizon canvas when tab is shown
const origSwitchTab = typeof switchTab === 'function' ? switchTab : null;
function initHorizonOnTabSwitch(tabId) {
    if (tabId === 'horizon') {
        setTimeout(() => {
            setupHorizonCanvasClick();
            if (horizonData.fractions.length === 0) {
                generateHorizon();
            }
        }, 100);
    }
}

// GLOBAL HARMONIC ANALYSIS SYSTEM
// =============================================
let audioCtx = null;
let currentOscillator = null;
let currentGain = null;
let selectedHarmonicFraction = { r: 1, m: 2 };
let harmonicSettings = {
    baseFreq: 440,
    volume: 1.0,
    waveform: 'sine',
    coupling: 0.5
};

function initAudioContext() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
}

function toggleHarmonicDropdown() {
    const dropdown = document.getElementById('harmonicDropdown');
    const arrow = document.getElementById('harmonicArrow');
    const header = document.querySelector('.harmonic-toolbar-header');
    
    dropdown.classList.toggle('expanded');
    arrow.classList.toggle('rotated');
    header.classList.toggle('expanded');
}

function toggleHarmonicPanel() {
    toggleHarmonicDropdown();
}

function updateBaseFreq() {
    const freq = document.getElementById('baseFreq').value;
    harmonicSettings.baseFreq = +freq;
    document.getElementById('baseFreqVal').textContent = freq + ' Hz';
    // Sync slider if within range
    const slider = document.getElementById('baseFreqSlider');
    if (slider && freq >= 55 && freq <= 880) {
        slider.value = freq;
    }
    updateHarmonicDisplays();
}

function updateHarmonicVolume() {
    const vol = document.getElementById('harmonicVolume').value;
    harmonicSettings.volume = vol / 100;
    document.getElementById('volumeVal').textContent = vol + '%';
    if (currentGain) {
        currentGain.gain.setValueAtTime(harmonicSettings.volume, audioCtx.currentTime);
    }
}

function updateWaveform() {
    harmonicSettings.waveform = document.getElementById('waveform').value;
    if (currentOscillator) {
        currentOscillator.type = harmonicSettings.waveform;
    }
}

function getHarmonicMode(q) {
    if (q === 1) return { name: 'Unison', class: 'unison', color: '#22c55e' };
    if (q <= 4) return { name: 'Consonant', class: 'consonant', color: '#3b82f6' };
    if (q <= 16) return { name: 'Complex', class: 'complex', color: '#f59e0b' };
    return { name: 'Dissonant', class: 'dissonant', color: '#ef4444' };
}

function frequencyToCents(f1, f2) {
    return 1200 * Math.log2(f2 / f1);
}

function frequencyToNote(freq) {
    // Validate input
    if (!isFinite(freq) || freq <= 0) {
        return { name: '?', cents: 0 };
    }
    
    const A4 = 440;
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const semitones = 12 * Math.log2(freq / A4);
    
    if (!isFinite(semitones)) {
        return { name: '?', cents: 0 };
    }
    
    const noteNum = Math.round(semitones) + 69;
    const octave = Math.floor(noteNum / 12) - 1;
    const noteIndex = ((noteNum % 12) + 12) % 12;
    const cents = Math.round((semitones - Math.round(semitones)) * 100);
    return { name: noteNames[noteIndex] + octave, cents: cents };
}

function getIntervalName(r, m) {
    const ratio = r / m;
    const intervals = [
        { r: 1, m: 1, name: 'Unison' },
        { r: 2, m: 1, name: 'Octave' },
        { r: 3, m: 2, name: 'Perfect Fifth' },
        { r: 4, m: 3, name: 'Perfect Fourth' },
        { r: 5, m: 4, name: 'Major Third' },
        { r: 6, m: 5, name: 'Minor Third' },
        { r: 5, m: 3, name: 'Major Sixth' },
        { r: 8, m: 5, name: 'Minor Sixth' },
        { r: 9, m: 8, name: 'Major Second' },
        { r: 16, m: 15, name: 'Minor Second' },
        { r: 15, m: 8, name: 'Major Seventh' },
        { r: 16, m: 9, name: 'Minor Seventh' },
        { r: 45, m: 32, name: 'Tritone' }
    ];
    for (const int of intervals) {
        if (Math.abs(ratio - int.r / int.m) < 0.001) return int.name;
    }
    return r + ':' + m;
}

function playFraction(r, m, duration = 0.5) {
    // Validate inputs
    if (!r || !m || m === 0 || !isFinite(r) || !isFinite(m)) {
        console.warn('Invalid fraction:', r, '/', m);
        return;
    }
    
    initAudioContext();
    stopAudio();
    
    const freq = harmonicSettings.baseFreq * (r / m);
    
    // Validate frequency
    if (!isFinite(freq) || freq <= 0 || freq > 20000) {
        console.warn('Invalid frequency:', freq);
        return;
    }
    
    const vol = Math.max(0.001, Math.min(1, harmonicSettings.volume || 0.5));
    
    try {
        currentOscillator = audioCtx.createOscillator();
        currentGain = audioCtx.createGain();
        
        currentOscillator.type = harmonicSettings.waveform || 'sine';
        currentOscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
        currentGain.gain.setValueAtTime(vol, audioCtx.currentTime);
        currentGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        
        currentOscillator.connect(currentGain);
        currentGain.connect(audioCtx.destination);
        currentOscillator.start();
        currentOscillator.stop(audioCtx.currentTime + duration);
    } catch (e) {
        console.warn('Audio error:', e.message);
    }
    
    updateHarmonicDisplays();
}

function playSelectedFraction() {
    playFraction(selectedHarmonicFraction.r, selectedHarmonicFraction.m, 1.0);
    document.getElementById('playBtn').classList.add('playing');
    setTimeout(() => document.getElementById('playBtn').classList.remove('playing'), 1000);
}

function playArpeggio() {
    initAudioContext();
    const sector = +document.getElementById('viewSector')?.value || 2;
    const fractions = (state.residuesBySector[sector] || []).slice(0, 8);
    if (fractions.length === 0) return;
    
    let delay = 0;
    fractions.forEach((f, i) => {
        setTimeout(() => playFraction(f.r, f.m, 0.4), delay);
        delay += 300;
    });
}

// Harmonic toolbar helper functions
function syncHarmonicFreq(source) {
    const slider = document.getElementById('harmonicBaseFreqSlider');
    const num = document.getElementById('harmonicBaseFreq');
    if (source === 'slider' && num) {
        num.value = slider.value;
    } else if (source === 'num' && slider) {
        slider.value = Math.min(880, Math.max(20, num.value));
    }
    updateHarmonicTab();
}

function syncHarmonicDenom(source) {
    const slider = document.getElementById('harmonicMaxDenomSlider');
    const num = document.getElementById('harmonicMaxDenom');
    if (source === 'slider' && num) {
        num.value = slider.value;
    } else if (source === 'num' && slider) {
        slider.value = Math.min(64, Math.max(4, num.value));
    }
    updateHarmonicTab();
}

function setHarmonicBase(freq) {
    document.getElementById('harmonicBaseFreq').value = Math.round(freq);
    const slider = document.getElementById('harmonicBaseFreqSlider');
    if (slider) slider.value = Math.min(880, Math.max(20, freq));
    updateHarmonicTab();
}

function setHarmonicPreset(sector, maxDenom) {
    document.getElementById('harmonicSector').value = sector;
    document.getElementById('harmonicMaxDenom').value = maxDenom;
    const slider = document.getElementById('harmonicMaxDenomSlider');
    if (slider) slider.value = Math.min(64, maxDenom);
    updateHarmonicTab();
}

function playHarmonicScale(direction) {
    initAudioContext();
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    const speed = +(document.getElementById('harmonicPlaySpeed')?.value || 200);
    
    // Generate fractions for this sector
    const fractions = [];
    for (let m = 2; m <= maxDenom; m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) === 1) {
                const val = r / m;
                const s = Math.floor(1 / val);
                if (s === sector) {
                    fractions.push({ r, m, val });
                }
            }
        }
    }
    
    if (fractions.length === 0) return;
    
    fractions.sort((a, b) => direction === 'down' ? b.val - a.val : a.val - b.val);
    
    let delay = 0;
    fractions.slice(0, 20).forEach((f) => {
        setTimeout(() => playFraction(f.r, f.m, 0.35), delay);
        delay += speed;
    });
}

function playHarmonicChord() {
    initAudioContext();
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    
    // Get consonant fractions only (q <= 8)
    const fractions = [];
    for (let m = 2; m <= Math.min(8, maxDenom); m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) === 1) {
                const val = r / m;
                const s = Math.floor(1 / val);
                if (s === sector) {
                    fractions.push({ r, m, val });
                }
            }
        }
    }
    
    // Play all at once
    fractions.forEach(f => playFraction(f.r, f.m, 0.25));
}

function playConsonantOnly() {
    initAudioContext();
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const speed = +(document.getElementById('harmonicPlaySpeed')?.value || 200);
    
    // Only fractions with q <= 4 (pure intervals)
    const fractions = [];
    for (let m = 2; m <= 4; m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) === 1) {
                const val = r / m;
                const s = Math.floor(1 / val);
                if (s === sector) {
                    fractions.push({ r, m, val });
                }
            }
        }
    }
    
    fractions.sort((a, b) => a.val - b.val);
    
    let delay = 0;
    fractions.forEach(f => {
        setTimeout(() => playFraction(f.r, f.m, 0.5), delay);
        delay += speed * 1.5;
    });
}

// Update speed display
document.addEventListener('DOMContentLoaded', () => {
    const speedSlider = document.getElementById('harmonicPlaySpeed');
    if (speedSlider) {
        speedSlider.addEventListener('input', () => {
            const display = document.getElementById('harmonicSpeedVal');
            if (display) display.textContent = speedSlider.value + 'ms';
        });
    }
});

// Legacy function kept for compatibility
function playHarmonicScaleLegacy() {
    initAudioContext();
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const fractions = (state.residuesBySector[sector] || []).slice(0, 12);
    if (fractions.length === 0) return;
    
    fractions.sort((a, b) => a.r / a.m - b.r / b.m);
    let delay = 0;
    fractions.forEach((f, i) => {
        setTimeout(() => playFraction(f.r, f.m, 0.35), delay);
        delay += 250;
    });
}

function stopAudio() {
    if (currentOscillator) {
        try { currentOscillator.stop(); } catch(e) {}
        currentOscillator = null;
    }
    document.getElementById('playBtn')?.classList.remove('playing');
}

function setHarmonicInterval(r, m) {
    selectedHarmonicFraction = { r, m };
    updateHarmonicDisplays();
    playFraction(r, m, 0.8);
    
    document.querySelectorAll('.interval-btn-sm').forEach(btn => btn.classList.remove('active'));
    if (event && event.target) event.target.classList.add('active');
}

// Custom intervals storage
let customIntervals = [];

function addCustomInterval() {
    const input = document.getElementById('customIntervalInput');
    const val = input.value.trim();
    
    // Parse a:b or a/b format
    const match = val.match(/^(\d+)\s*[:\/]\s*(\d+)$/);
    if (!match) {
        alert('Enter interval as a:b (e.g. 7:4)');
        return;
    }
    
    const a = parseInt(match[1]);
    const b = parseInt(match[2]);
    
    if (a <= 0 || b <= 0) {
        alert('Both numbers must be positive');
        return;
    }
    
    // Check if already exists
    const exists = customIntervals.some(i => i.a === a && i.b === b);
    if (exists) {
        alert(`${a}:${b} already exists`);
        return;
    }
    
    customIntervals.push({ a, b });
    input.value = '';
    renderCustomIntervals();
    
    // Auto-play the new interval
    setHarmonicInterval(a, b);
}

function removeCustomInterval(a, b) {
    customIntervals = customIntervals.filter(i => !(i.a === a && i.b === b));
    renderCustomIntervals();
}

function clearCustomIntervals() {
    customIntervals = [];
    renderCustomIntervals();
}

function renderCustomIntervals() {
    const grid = document.getElementById('customIntervalsGrid');
    if (!grid) return;
    
    if (customIntervals.length === 0) {
        grid.innerHTML = '';
        return;
    }
    
    grid.innerHTML = customIntervals.map(i => 
        `<button class="interval-btn-sm" onclick="setHarmonicInterval(${i.a},${i.b})" oncontextmenu="event.preventDefault();removeCustomInterval(${i.a},${i.b})" title="${i.a}:${i.b} (right-click to remove)" style="background:#1e3a5f;border-color:#3b82f6;">${i.a}:${i.b}</button>`
    ).join('');
}

// Handle Enter key in custom interval input
document.addEventListener('DOMContentLoaded', function() {
    const customInput = document.getElementById('customIntervalInput');
    if (customInput) {
        customInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                addCustomInterval();
            }
        });
    }
});

function selectFractionForHarmonic(r, m) {
    // Validate inputs
    if (!r || !m || m === 0 || !isFinite(r) || !isFinite(m)) return;
    
    selectedHarmonicFraction = { r, m };
    
    const freq = harmonicSettings.baseFreq * (r / m);
    if (!isFinite(freq) || freq <= 0) return;
    
    const note = frequencyToNote(freq);
    const mode = getHarmonicMode(m);
    
    // Update quick display in toolbar
    const qf = document.getElementById('quickFraction');
    const qfreq = document.getElementById('quickFreq');
    const qn = document.getElementById('quickNote');
    const qw = document.getElementById('quickWave');
    
    const wavelength = 343 / freq; // Speed of sound / frequency
    const waveStr = wavelength >= 1 ? wavelength.toFixed(2) + ' m' : (wavelength * 100).toFixed(1) + ' cm';
    
    if (qf) qf.textContent = r + '/' + m;
    if (qfreq) qfreq.textContent = freq.toFixed(1) + ' Hz';
    if (qw) qw.textContent = waveStr;
    if (qn) qn.textContent = note.name;
    
    // Update wave properties panel
    updateWaveProperties(freq);
    
    const info = document.getElementById('selectedFractionInfo');
    if (info) {
        info.innerHTML = `
            <div style="font-size:16px; color:#8b5cf6; font-weight:bold;">${r}/${m}</div>
            <div>Frequency: <strong>${freq.toFixed(2)} Hz</strong> | Œª: <strong style="color:#f59e0b;">${waveStr}</strong></div>
            <div>Note: <strong>${note.name}</strong> (${note.cents >= 0 ? '+' : ''}${note.cents}¬¢)</div>
            <div>Interval: <strong>${getIntervalName(r, m)}</strong></div>
            <div>Mode: <span class="mode-badge ${mode.class}">${mode.name}</span></div>
        `;
    }
}

function updateHarmonicDisplays() {
    const { r, m } = selectedHarmonicFraction;
    const freq = harmonicSettings.baseFreq * (r / m);
    const note = frequencyToNote(freq);
    const mode = getHarmonicMode(m);
    
    // Update main displays
    const freqDisplay = document.getElementById('currentFreqDisplay');
    const noteDisplay = document.getElementById('currentNoteDisplay');
    if (freqDisplay) freqDisplay.textContent = freq.toFixed(2) + ' Hz';
    if (noteDisplay) noteDisplay.textContent = `${r}/${m} = ${note.name} (${note.cents >= 0 ? '+' : ''}${note.cents}¬¢)`;
    
    // Update quick display in toolbar
    const quickFrac = document.getElementById('quickFraction');
    const quickFreq = document.getElementById('quickFreq');
    const quickNote = document.getElementById('quickNote');
    const quickWave = document.getElementById('quickWave');
    
    const wavelength = 343 / freq;
    const waveStr = wavelength >= 1 ? wavelength.toFixed(2) + ' m' : (wavelength * 100).toFixed(1) + ' cm';
    
    if (quickFrac) quickFrac.textContent = r + '/' + m;
    if (quickFreq) quickFreq.textContent = freq.toFixed(1) + ' Hz';
    if (quickWave) quickWave.textContent = waveStr;
    if (quickNote) quickNote.textContent = note.name;
    
    // Update wave properties panel
    updateWaveProperties(freq);
    
    // Update mode indicator
    const indicator = document.getElementById('harmonicModeIndicator');
    if (indicator) {
        indicator.className = 'mode-badge ' + mode.class.replace('mode-', '');
        indicator.textContent = mode.name;
    }
    
    const modeQ = document.getElementById('modeQValue');
    if (modeQ) modeQ.textContent = m === 1 ? 'q=1' : m <= 4 ? 'q‚â§4' : m <= 16 ? 'q‚â§16' : 'q>' + m;
    
    drawArnoldMini();
    drawHarmonicSeriesViz();
}

// Update wave properties panel with frequency info
function updateWaveProperties(freq) {
    if (!freq || freq <= 0 || !isFinite(freq)) return;
    
    const speedOfSound = 343; // m/s at 20¬∞C
    const wavelength = speedOfSound / freq;
    const period = 1000 / freq; // in ms
    const angularFreq = 2 * Math.PI * freq;
    const wavenumber = (2 * Math.PI) / wavelength;
    
    const waveDisp = document.getElementById('wavelengthDisplay');
    const periodDisp = document.getElementById('periodDisplay');
    const angularDisp = document.getElementById('angularFreqDisplay');
    const wavenumDisp = document.getElementById('wavenumberDisplay');
    
    if (waveDisp) {
        waveDisp.textContent = wavelength >= 1 ? wavelength.toFixed(2) + ' m' : (wavelength * 100).toFixed(1) + ' cm';
    }
    if (periodDisp) {
        periodDisp.textContent = period >= 1 ? period.toFixed(2) + ' ms' : (period * 1000).toFixed(1) + ' Œºs';
    }
    if (angularDisp) {
        angularDisp.textContent = angularFreq.toFixed(0) + ' rad/s';
    }
    if (wavenumDisp) {
        wavenumDisp.textContent = wavenumber.toFixed(2) + ' /m';
    }
}

function updateArnoldTongue() {
    const k = document.getElementById('arnoldK').value / 100;
    harmonicSettings.coupling = k;
    document.getElementById('arnoldKVal').textContent = k.toFixed(2);
    drawArnoldMini();
}

function drawArnoldMini() {
    const canvas = document.getElementById('arnoldMiniCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const K = harmonicSettings.coupling;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw Arnold tongues for simple ratios
    const tongues = [
        { r: 1, m: 1 }, { r: 1, m: 2 }, { r: 2, m: 3 }, { r: 1, m: 3 },
        { r: 3, m: 4 }, { r: 2, m: 5 }, { r: 3, m: 5 }, { r: 1, m: 4 }
    ];
    
    tongues.forEach(t => {
        const omega = t.r / t.m;
        const width = K / t.m * 0.8;
        const x = omega * W;
        const mode = getHarmonicMode(t.m);
        
        ctx.fillStyle = mode.color + '60';
        ctx.beginPath();
        ctx.moveTo(x, H);
        ctx.lineTo(x - width * W / 2, H * (1 - K));
        ctx.lineTo(x + width * W / 2, H * (1 - K));
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = mode.color;
        ctx.lineWidth = 1;
        ctx.stroke();
    });
    
    // Mark selected fraction
    const selOmega = selectedHarmonicFraction.r / selectedHarmonicFraction.m;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(selOmega * W, H - 5, 4, 0, 2 * Math.PI);
    ctx.fill();
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, H);
    ctx.lineTo(W, H);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, H);
    ctx.stroke();
    
    ctx.fillStyle = '#64748b';
    ctx.font = '9px system-ui';
    ctx.fillText('0', 2, H - 3);
    ctx.fillText('1', W - 10, H - 3);
    ctx.fillText('K=' + K.toFixed(2), W - 40, 12);
}

function drawHarmonicSpectrum() {
    const canvas = document.getElementById('harmonicSpectrum');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const sector = +document.getElementById('viewSector')?.value || 2;
    const fractions = (state.residuesBySector[sector] || []).slice(0, 20);
    if (fractions.length === 0) return;
    
    const barWidth = W / fractions.length;
    fractions.forEach((f, i) => {
        const mode = getHarmonicMode(f.m);
        const height = (1 - f.m / 50) * H * 0.8 + H * 0.1;
        
        ctx.fillStyle = mode.color + '80';
        ctx.fillRect(i * barWidth + 1, H - height, barWidth - 2, height);
    });
}

function resetHarmonicDefaults() {
    document.getElementById('baseFreq').value = 440;
    document.getElementById('baseFreqSlider').value = 440;
    document.getElementById('harmonicVolume').value = 30;
    document.getElementById('waveform').value = 'sine';
    document.getElementById('arnoldK').value = 50;
    
    harmonicSettings = { baseFreq: 440, volume: 0.3, waveform: 'sine', coupling: 0.5 };
    selectedHarmonicFraction = { r: 1, m: 2 };
    
    updateBaseFreq();
    updateHarmonicVolume();
    updateArnoldTongue();
    updateHarmonicDisplays();
}

function applyHarmonicColoring() {
    const apply = document.getElementById('applyHarmonicColor')?.checked;
    if (apply) {
        // Re-draw main ring with harmonic coloring
        document.getElementById('colorMode').value = 'prime';
        drawMainRing();
    }
}

// HARMONIC TAB FUNCTIONS
function updateHarmonicTab() {
    const baseFreq = +(document.getElementById('harmonicBaseFreq')?.value || 220);
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    
    // Generate fractions in sector
    const fractions = [];
    for(let m = 2; m <= maxDenom; m++) {
        for(let r = 1; r < m; r++) {
            if(gcd(r, m) === 1) {
                const val = r / m;
                const s = Math.floor(1 / val);
                if(s === sector) {
                    fractions.push({ r, m, val, freq: baseFreq * r / m });
                }
            }
        }
    }
    
    // Consonance classification
    const consonant = fractions.filter(f => f.m <= 4).length;
    const complex = fractions.filter(f => f.m > 4 && f.m <= 16).length;
    const dissonant = fractions.filter(f => f.m > 16).length;
    
    // Frequency stats
    const freqs = fractions.map(f => f.freq);
    const minFreq = freqs.length > 0 ? safeMin(freqs, 0) : 0;
    const maxFreq = freqs.length > 0 ? safeMax(freqs, 0) : 0;
    const avgFreq = freqs.length > 0 ? freqs.reduce((a,b) => a+b, 0) / freqs.length : 0;
    
    // Octave info
    const octaves = Math.log2(maxFreq / minFreq) || 0;
    
    // Prime denominators
    const primeCount = fractions.filter(f => isPrime(f.m)).length;
    
    // Cents calculation (interval from base)
    const avgCents = fractions.length > 0 ? 
        fractions.reduce((s, f) => s + 1200 * Math.log2(f.r / f.m), 0) / fractions.length : 0;
    
    // Update stats with organized panels
    const statsEl = document.getElementById('harmonicStats');
    if(statsEl) {
        statsEl.innerHTML = `
            <!-- Overview Panel -->
            <div style="background:#1e293b;border-radius:8px;padding:12px;border:1px solid #334155;">
                <div style="color:#94a3b8;font-size:11px;font-weight:600;margin-bottom:8px;text-transform:uppercase;letter-spacing:0.5px;">Overview</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;">
                    <div style="text-align:center;"><div style="color:#8b5cf6;font-size:1.4em;font-weight:bold;">${fractions.length}</div><div style="color:#64748b;font-size:10px;">Fractions</div></div>
                    <div style="text-align:center;"><div style="color:#6366f1;font-size:1.4em;font-weight:bold;">S${sector}</div><div style="color:#64748b;font-size:10px;">Sector</div></div>
                    <div style="text-align:center;"><div style="color:#a5b4fc;font-size:1.4em;font-weight:bold;">${primeCount}</div><div style="color:#64748b;font-size:10px;">Prime q</div></div>
                </div>
            </div>
            
            <!-- Consonance Panel -->
            <div style="background:linear-gradient(135deg,#1e293b,#1a2332);border-radius:8px;padding:12px;border:1px solid #334155;">
                <div style="color:#94a3b8;font-size:11px;font-weight:600;margin-bottom:8px;text-transform:uppercase;letter-spacing:0.5px;">Consonance</div>
                <div style="display:flex;gap:6px;margin-bottom:8px;">
                    <div style="flex:1;background:#22c55e20;border:1px solid #22c55e;border-radius:4px;padding:6px;text-align:center;">
                        <div style="color:#22c55e;font-size:1.2em;font-weight:bold;">${consonant}</div>
                        <div style="color:#86efac;font-size:9px;">Pure (q‚â§4)</div>
                    </div>
                    <div style="flex:1;background:#f59e0b20;border:1px solid #f59e0b;border-radius:4px;padding:6px;text-align:center;">
                        <div style="color:#f59e0b;font-size:1.2em;font-weight:bold;">${complex}</div>
                        <div style="color:#fcd34d;font-size:9px;">Complex</div>
                    </div>
                    <div style="flex:1;background:#ef444420;border:1px solid #ef4444;border-radius:4px;padding:6px;text-align:center;">
                        <div style="color:#ef4444;font-size:1.2em;font-weight:bold;">${dissonant}</div>
                        <div style="color:#fca5a5;font-size:9px;">Dissonant</div>
                    </div>
                </div>
                <div style="background:#0f172a;border-radius:4px;padding:6px;display:flex;justify-content:space-between;align-items:center;">
                    <span style="color:#64748b;font-size:11px;">Consonance Rate</span>
                    <span style="color:#22c55e;font-weight:bold;">${(consonant/fractions.length*100||0).toFixed(1)}%</span>
                </div>
            </div>
            
            <!-- Frequency Panel -->
            <div style="background:#1e293b;border-radius:8px;padding:12px;border:1px solid #334155;">
                <div style="color:#94a3b8;font-size:11px;font-weight:600;margin-bottom:8px;text-transform:uppercase;letter-spacing:0.5px;">Frequency Range</div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;">
                    <div style="background:#0f172a;padding:8px;border-radius:4px;">
                        <div style="color:#64748b;font-size:9px;">Base</div>
                        <div style="color:#f1f5f9;font-size:1.1em;font-weight:bold;">${baseFreq} <span style="color:#64748b;font-size:0.7em;">Hz</span></div>
                    </div>
                    <div style="background:#0f172a;padding:8px;border-radius:4px;">
                        <div style="color:#64748b;font-size:9px;">Span</div>
                        <div style="color:#f1f5f9;font-size:1.1em;font-weight:bold;">${octaves.toFixed(2)} <span style="color:#64748b;font-size:0.7em;">oct</span></div>
                    </div>
                </div>
                <div style="display:flex;justify-content:space-between;font-size:11px;color:#94a3b8;">
                    <span>Min: <span style="color:#3b82f6;">${minFreq.toFixed(1)} Hz</span></span>
                    <span>Avg: <span style="color:#8b5cf6;">${avgFreq.toFixed(1)} Hz</span></span>
                    <span>Max: <span style="color:#ec4899;">${maxFreq.toFixed(1)} Hz</span></span>
                </div>
            </div>
            
            <!-- Interval Panel -->
            <div style="background:#1e293b;border-radius:8px;padding:12px;border:1px solid #334155;">
                <div style="color:#94a3b8;font-size:11px;font-weight:600;margin-bottom:8px;text-transform:uppercase;letter-spacing:0.5px;">Interval Analysis</div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                    <div style="background:#0f172a;padding:8px;border-radius:4px;text-align:center;">
                        <div style="color:#f59e0b;font-size:1.3em;font-weight:bold;">${avgCents.toFixed(0)}<span style="font-size:0.6em;">¬¢</span></div>
                        <div style="color:#64748b;font-size:9px;">Avg Cents</div>
                    </div>
                    <div style="background:#0f172a;padding:8px;border-radius:4px;text-align:center;">
                        <div style="color:#a78bfa;font-size:1.3em;font-weight:bold;">${maxDenom}</div>
                        <div style="color:#64748b;font-size:9px;">Max Denom</div>
                    </div>
                </div>
            </div>
        `;
    }
    
    drawArnoldTongues();
    drawFrequencySpectrum();
    drawConsonanceMap();
    drawIntervalCircle();
    updateIntervalTable();
}

function drawArnoldTongues() {
    const canvas = document.getElementById('arnoldTongueCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const K = (document.getElementById('arnoldCoupling')?.value || 60) / 100;
    const showLabels = document.getElementById('arnoldShowLabels')?.checked ?? true;
    
    document.getElementById('arnoldCouplingVal').textContent = K.toFixed(2);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 20, t: 30, b: 40 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate Farey fractions up to maxDenom
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    const fractions = [];
    for (let m = 1; m <= maxDenom; m++) {
        for (let r = 0; r <= m; r++) {
            if (gcd(r, m) === 1) {
                fractions.push({ r, m, omega: r / m });
            }
        }
    }
    fractions.sort((a, b) => a.omega - b.omega);
    
    // Draw tongues
    fractions.forEach(f => {
        if (f.r === 0) return;
        const omega = f.omega;
        const width = K / f.m;
        const x = margin.l + omega * plotW;
        const mode = getHarmonicMode(f.m);
        
        // Triangle tongue
        ctx.fillStyle = mode.color + '40';
        ctx.beginPath();
        ctx.moveTo(x, margin.t + plotH);
        ctx.lineTo(x - width * plotW / 2, margin.t + plotH * (1 - K * 0.9));
        ctx.lineTo(x + width * plotW / 2, margin.t + plotH * (1 - K * 0.9));
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = mode.color;
        ctx.lineWidth = f.m <= 4 ? 2 : 1;
        ctx.stroke();
        
        // Labels for simple fractions
        if (showLabels && f.m <= 6 && width * plotW > 15) {
            ctx.fillStyle = '#e2e8f0';
            ctx.font = f.m <= 4 ? 'bold 10px system-ui' : '9px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${f.r}/${f.m}`, x, margin.t + plotH + 15);
        }
    });
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(margin.l + plotW, margin.t + plotH);
    ctx.stroke();
    
    // Labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Frequency Ratio Œ© = p/q', margin.l + plotW / 2, H - 5);
    ctx.save();
    ctx.translate(15, margin.t + plotH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Coupling K', 0, 0);
    ctx.restore();
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText('Arnold Tongues (Phase-Locking Regions)', margin.l + plotW / 2, 18);
}

function drawFrequencySpectrum() {
    const canvas = document.getElementById('freqSpectrumCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const baseFreq = +(document.getElementById('harmonicBaseFreq')?.value || 220);
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const logScale = document.getElementById('freqLogScale')?.checked ?? false;
    const showOctaves = document.getElementById('freqShowOctaves')?.checked ?? true;
    const sortMode = document.getElementById('freqSortMode')?.value || 'freq';
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 20, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let fractions = (state.residuesBySector[sector] || []).map(f => ({
        ...f,
        freq: baseFreq * (f.r / f.m),
        mode: getHarmonicMode(f.m)
    }));
    
    if (fractions.length === 0) {
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('No data - run computation first', W / 2, H / 2);
        return;
    }
    
    // Sort
    if (sortMode === 'freq') fractions.sort((a, b) => a.freq - b.freq);
    else if (sortMode === 'consonance') fractions.sort((a, b) => a.m - b.m);
    else fractions.sort((a, b) => a.m - b.m);
    
    fractions = fractions.slice(0, 50);
    
    const maxFreq = safeMax(fractions.map(f => f.freq), 0);
    const minFreq = safeMin(fractions.map(f => f.freq), 0);
    const barWidth = plotW / fractions.length;
    
    // Draw octave lines
    if (showOctaves) {
        ctx.strokeStyle = '#22c55e40';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 1;
        for (let oct = 0; oct < 4; oct++) {
            const octFreq = baseFreq * Math.pow(2, oct);
            if (octFreq <= maxFreq * 1.1) {
                const y = margin.t + plotH - (octFreq / maxFreq) * plotH * 0.9;
                ctx.beginPath();
                ctx.moveTo(margin.l, y);
                ctx.lineTo(margin.l + plotW, y);
                ctx.stroke();
                ctx.fillStyle = '#22c55e';
                ctx.font = '9px system-ui';
                ctx.textAlign = 'right';
                ctx.fillText(`${octFreq.toFixed(0)}Hz`, margin.l - 5, y + 3);
            }
        }
        ctx.setLineDash([]);
    }
    
    // Draw bars
    fractions.forEach((f, i) => {
        const x = margin.l + i * barWidth;
        const height = (f.freq / maxFreq) * plotH * 0.85;
        const y = margin.t + plotH - height;
        
        ctx.fillStyle = f.mode.color + '90';
        ctx.fillRect(x + 1, y, barWidth - 2, height);
        ctx.strokeStyle = f.mode.color;
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 1, y, barWidth - 2, height);
    });
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(margin.l + plotW, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Fractions (sorted by ' + sortMode + ')', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText(`Frequency Spectrum (Base: ${baseFreq} Hz)`, margin.l + plotW / 2, 18);
}

function drawConsonanceMap() {
    const canvas = document.getElementById('consonanceMapCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 20, t: 30, b: 40 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    
    // Draw consonance as function of position in [0,1]
    const resolution = 200;
    for (let i = 0; i < resolution; i++) {
        const x = i / resolution;
        
        // Find closest Farey fraction
        let bestR = 1, bestM = 2, bestDist = 1;
        for (let m = 1; m <= Math.min(maxDenom, 20); m++) {
            for (let r = 0; r <= m; r++) {
                if (gcd(r, m) === 1) {
                    const dist = Math.abs(x - r / m);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestR = r;
                        bestM = m;
                    }
                }
            }
        }
        
        const consonance = 1 / bestM;
        const mode = getHarmonicMode(bestM);
        
        const px = margin.l + x * plotW;
        const height = consonance * plotH * 0.9;
        
        ctx.fillStyle = mode.color + '80';
        ctx.fillRect(px, margin.t + plotH - height, plotW / resolution + 1, height);
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(margin.l + plotW, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Position in [0,1]', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText('Consonance Map (height = 1/denominator)', margin.l + plotW / 2, 18);
}

function drawIntervalCircle() {
    const canvas = document.getElementById('intervalCircleCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const radius = Math.min(W, H) / 2 - 50;
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw 12-TET reference circle
    ctx.strokeStyle = '#f59e0b40';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
    ctx.stroke();
    
    // 12-TET positions
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * 2 * Math.PI - Math.PI / 2;
        const x = cx + Math.cos(angle) * (radius + 20);
        const y = cy + Math.sin(angle) * (radius + 20);
        
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#94a3b8';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(noteNames[i], x, y + 4);
    }
    
    // Plot fractions on circle
    const fractions = (state.residuesBySector[sector] || []).slice(0, 30);
    fractions.forEach(f => {
        const cents = 1200 * Math.log2(f.r / f.m);
        const normalizedCents = ((cents % 1200) + 1200) % 1200;
        const angle = (normalizedCents / 1200) * 2 * Math.PI - Math.PI / 2;
        const x = cx + Math.cos(angle) * radius * 0.85;
        const y = cy + Math.sin(angle) * radius * 0.85;
        
        const mode = getHarmonicMode(f.m);
        ctx.fillStyle = mode.color;
        ctx.beginPath();
        ctx.arc(x, y, f.m <= 4 ? 6 : 4, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Center label
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Pitch Class Circle', cx, cy - 5);
    ctx.font = '10px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.fillText('(12-TET reference)', cx, cy + 10);
}

function updateIntervalTable() {
    const tbody = document.querySelector('#intervalTable tbody');
    if (!tbody) return;
    
    const baseFreq = +(document.getElementById('harmonicBaseFreq')?.value || 220);
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const fractions = (state.residuesBySector[sector] || []).slice(0, 30);
    
    if (fractions.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;color:#64748b;">No data - run computation first</td></tr>';
        return;
    }
    
    fractions.sort((a, b) => a.r / a.m - b.r / b.m);
    
    let html = '';
    fractions.forEach(f => {
        const freq = baseFreq * (f.r / f.m);
        const note = frequencyToNote(freq);
        const cents = frequencyToCents(baseFreq, freq);
        const mode = getHarmonicMode(f.m);
        const intervalName = getIntervalName(f.r, f.m);
        
        html += `<tr>
            <td><strong>${f.r}/${f.m}</strong></td>
            <td>${f.r}:${f.m}</td>
            <td style="color:#8b5cf6">${freq.toFixed(2)} Hz</td>
            <td>${cents >= 0 ? '+' : ''}${cents.toFixed(1)}¬¢</td>
            <td>${note.name} (${note.cents >= 0 ? '+' : ''}${note.cents}¬¢)</td>
            <td>${intervalName}</td>
            <td><span class="mode-indicator ${mode.class}">${mode.name}</span></td>
            <td><button class="harmonic-btn primary" onclick="playFraction(${f.r},${f.m},0.6)" style="padding:3px 8px;font-size:10px;">Play</button></td>
        </tr>`;
    });
    
    tbody.innerHTML = html;
}

// Initialize harmonic panel on load
setTimeout(() => {
    updateHarmonicDisplays();
    drawArnoldMini();
    drawHarmonicSeriesViz();
    setupGlobalFractionListeners();
    
    // Setup tree canvas click handler
    const treeCanvas = document.getElementById('sectorTreeCanvas');
    if (treeCanvas && !treeCanvas.hasClickHandler) {
        treeCanvas.addEventListener('click', handleTreeCanvasClick);
        treeCanvas.hasClickHandler = true;
    }
}, 200);

// =============================================
// GLOBAL FRACTION CLICK INTEGRATION
// =============================================
function setupGlobalFractionListeners() {
    // This makes harmonic work for ALL tabs with fractions
    
    // Smith Chart Canvas
    const smithCanvas = document.getElementById('smithCanvas');
    if (smithCanvas) {
        smithCanvas.addEventListener('click', handleSmithClick);
    }
    
    // Hyperbolic Canvas
    const hypCanvas = document.getElementById('hypCanvas');
    if (hypCanvas) {
        hypCanvas.addEventListener('click', handleHyperbolicClick);
    }
    
    // Animation Canvas
    const animCanvas = document.getElementById('animCanvas');
    if (animCanvas) {
        animCanvas.addEventListener('click', handleAnimationClick);
    }
    
    // 3D Canvas
    const canvas3d = document.getElementById('canvas3d');
    if (canvas3d) {
        canvas3d.addEventListener('click', handle3DClick);
    }
    
    // Ford Circles Canvas (PSL tab)
    const fordCanvas = document.getElementById('fordCanvas');
    if (fordCanvas) {
        fordCanvas.addEventListener('click', handleFordClick);
    }
    
    // Arnold Tongue Canvas (Harmonic tab)
    const arnoldCanvas = document.getElementById('arnoldTongueCanvas');
    if (arnoldCanvas) {
        arnoldCanvas.addEventListener('click', handleArnoldClick);
    }
    
    // Interval Circle Canvas
    const intervalCanvas = document.getElementById('intervalCircleCanvas');
    if (intervalCanvas) {
        intervalCanvas.addEventListener('click', handleIntervalCircleClick);
    }
    
    // Lattice Viz Canvas (Theory Viz)
    const latticeCanvas = document.getElementById('latticeVizCanvas');
    if (latticeCanvas) {
        latticeCanvas.addEventListener('click', handleLatticeClick);
    }
    
    // Add click handlers to tables with fractions
    document.addEventListener('click', handleTableFractionClick);
    
    console.log('Global harmonic listeners initialized');
}

// Store points for each visualization for click detection
const vizPoints = {
    smith: [],
    hyperbolic: [],
    animation: [],
    threeDim: [],
    ford: [],
    arnold: [],
    intervalCircle: [],
    lattice: []
};

function handleSmithClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const sector = +(document.getElementById('smithSector')?.value || 2);
    const residues = state.residuesBySector[sector] || [];
    
    // Find closest point
    let closest = null, minDist = 20;
    residues.forEach(res => {
        // Approximate screen position (simplified)
        const angle = (res.r / res.m) * 2 * Math.PI;
        const cx = e.target.width / 2, cy = e.target.height / 2;
        const maxR = Math.min(e.target.width, e.target.height) / 2 - 40;
        const px = cx + Math.cos(angle) * maxR * 0.7;
        const py = cy - Math.sin(angle) * maxR * 0.7;
        const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
        if (dist < minDist) { minDist = dist; closest = res; }
    });
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m, closest);
}

function handleHyperbolicClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const maxDenom = +(document.getElementById('hypMaxDenom')?.value || 15);
    const W = e.target.width, H = e.target.height;
    const cx = W / 2, cy = H / 2, R = Math.min(W, H) / 2 - 30;
    
    // Build Farey fractions on boundary
    let closest = null, minDist = 15;
    for (let m = 2; m <= maxDenom; m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) === 1) {
                const angle = (r / m) * Math.PI - Math.PI / 2;
                const px = cx + R * Math.cos(angle);
                const py = cy + R * Math.sin(angle);
                const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m);
}

function handleAnimationClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const W = e.target.width, H = e.target.height;
    const cx = W / 2, cy = H / 2, maxR = Math.min(W, H) / 2 - 30;
    const maxN = +(document.getElementById('animMaxN')?.value || 50);
    
    let closest = null, minDist = 15;
    for (let m = 2; m <= maxN; m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) === 1) {
                const angle = (r / m) * 2 * Math.PI;
                const rad = (m / maxN) * maxR;
                const px = cx + rad * Math.cos(angle);
                const py = cy - rad * Math.sin(angle);
                const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m);
}

function handle3DClick(e) {
    // 3D is more complex, use current sector data
    const sector = +(document.getElementById('viewSector')?.value || 2);
    const residues = state.residuesBySector[sector] || [];
    if (residues.length > 0) {
        const randomRes = residues[Math.floor(Math.random() * Math.min(residues.length, 20))];
        triggerGlobalHarmonic(randomRes.r, randomRes.m, randomRes);
    }
}

function handleFordClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const W = e.target.width;
    const margin = 30, scale = W - 2 * margin;
    const maxDenom = +(document.getElementById('pslMaxDenom')?.value || 12);
    
    // Find fraction closest to click x position
    let closest = null, minDist = 20;
    for (let m = 1; m <= maxDenom; m++) {
        for (let r = 0; r <= m; r++) {
            if (gcd(r, m) === 1) {
                const fx = margin + (r / m) * scale;
                const dist = Math.abs(fx - x);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest && closest.r > 0) triggerGlobalHarmonic(closest.r, closest.m);
}

function handleArnoldClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const W = e.target.width;
    const margin = { l: 50, r: 20 };
    const plotW = W - margin.l - margin.r;
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    
    // Convert x to omega value
    const omega = (x - margin.l) / plotW;
    if (omega < 0 || omega > 1) return;
    
    // Find closest Farey fraction
    let closest = null, minDist = 0.05;
    for (let m = 1; m <= maxDenom; m++) {
        for (let r = 0; r <= m; r++) {
            if (gcd(r, m) === 1) {
                const dist = Math.abs(omega - r / m);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest && closest.r > 0) triggerGlobalHarmonic(closest.r, closest.m);
}

function handleIntervalCircleClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const W = e.target.width, H = e.target.height;
    const cx = W / 2, cy = H / 2, radius = Math.min(W, H) / 2 - 50;
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    
    const fractions = (state.residuesBySector[sector] || []).slice(0, 30);
    let closest = null, minDist = 15;
    
    fractions.forEach(f => {
        const cents = 1200 * Math.log2(f.r / f.m);
        const normalizedCents = ((cents % 1200) + 1200) % 1200;
        const angle = (normalizedCents / 1200) * 2 * Math.PI - Math.PI / 2;
        const px = cx + Math.cos(angle) * radius * 0.85;
        const py = cy + Math.sin(angle) * radius * 0.85;
        const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
        if (dist < minDist) { minDist = dist; closest = f; }
    });
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m, closest);
}

function handleLatticeClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const W = e.target.width, H = e.target.height;
    const maxB = +(document.getElementById('tvLatticeSize')?.value || 22);
    const margin = 45;
    const scale = (Math.min(W, H) - 2 * margin) / maxB;
    
    // Convert screen coords to lattice coords
    const a = Math.round((x - margin) / scale);
    const b = Math.round((H - margin - y) / scale);
    
    if (a >= 1 && b >= 1 && a < b && gcd(a, b) === 1) {
        triggerGlobalHarmonic(a, b);
    }
}

function handleTableFractionClick(e) {
    // Handle clicks on fraction text in tables (e.g., "3/7")
    const target = e.target;
    const text = target.textContent.trim();
    const match = text.match(/^(\d+)\/(\d+)$/);
    
    if (match) {
        const r = parseInt(match[1]);
        const m = parseInt(match[2]);
        if (r > 0 && m > 0 && gcd(r, m) === 1) {
            triggerGlobalHarmonic(r, m);
            e.preventDefault();
        }
    }
}

// CENTRAL FUNCTION - triggers harmonic for any fraction from any source
function triggerGlobalHarmonic(r, m, extraData = null) {
    // Validate inputs
    if (!r || !m || m === 0 || !isFinite(r) || !isFinite(m)) {
        console.warn('Invalid fraction for harmonic:', r, '/', m);
        return;
    }
    
    r = Math.round(r);
    m = Math.round(m);
    
    selectedHarmonicFraction = { r, m };
    
    // Update all harmonic displays
    updateHarmonicDisplays();
    selectFractionForHarmonic(r, m);
    
    // Auto-play if enabled
    if (document.getElementById('autoPlayOnClick')?.checked) {
        playFraction(r, m, 0.6);
    }
    
    // Highlight the toggle button briefly
    const toggle = document.getElementById('harmonicToggle');
    if (toggle) {
        toggle.classList.add('playing');
        setTimeout(() => toggle.classList.remove('playing'), 600);
    }
    
    console.log(`Harmonic: ${r}/${m} = ${(r/m).toFixed(6)}, freq = ${(harmonicSettings.baseFreq * r / m).toFixed(2)} Hz`);
}

// Build mini keyboard
function buildMiniKeyboard() {
    const keyboard = document.getElementById('miniKeyboard');
    if (!keyboard) return;
    
    const notes = [
        { note: 'C', black: false, ratio: 1 },
        { note: 'C#', black: true, ratio: 16/15 },
        { note: 'D', black: false, ratio: 9/8 },
        { note: 'D#', black: true, ratio: 6/5 },
        { note: 'E', black: false, ratio: 5/4 },
        { note: 'F', black: false, ratio: 4/3 },
        { note: 'F#', black: true, ratio: 45/32 },
        { note: 'G', black: false, ratio: 3/2 },
        { note: 'G#', black: true, ratio: 8/5 },
        { note: 'A', black: false, ratio: 5/3 },
        { note: 'A#', black: true, ratio: 9/5 },
        { note: 'B', black: false, ratio: 15/8 },
        { note: 'C2', black: false, ratio: 2 }
    ];
    
    keyboard.innerHTML = '';
    notes.forEach(n => {
        const key = document.createElement('div');
        key.className = n.black ? 'black-key' : 'white-key';
        key.title = n.note;
        key.onclick = () => {
            // Convert ratio to fraction
            const [num, den] = ratioToFraction(n.ratio);
            triggerGlobalHarmonic(num, den);
            
            // Visual feedback
            key.classList.add('active');
            setTimeout(() => key.classList.remove('active'), 200);
        };
        keyboard.appendChild(key);
    });
}

function ratioToFraction(ratio) {
    // Convert decimal ratio to simplified fraction
    const tolerance = 1e-6;
    let bestNum = 1, bestDen = 1, bestErr = Math.abs(ratio - 1);
    
    for (let den = 1; den <= 32; den++) {
        const num = Math.round(ratio * den);
        const err = Math.abs(ratio - num / den);
        if (err < bestErr) {
            bestErr = err;
            bestNum = num;
            bestDen = den;
        }
        if (err < tolerance) break;
    }
    
    const g = gcd(bestNum, bestDen);
    return [bestNum / g, bestDen / g];
}

// Draw harmonic series visualization
function drawHarmonicSeriesViz() {
    const canvas = document.getElementById('harmonicSeriesCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const numPartials = +(document.getElementById('numPartials')?.value || 8);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const barWidth = (W - 20) / numPartials;
    
    for (let i = 1; i <= numPartials; i++) {
        const amplitude = 1 / i; // Natural harmonic decay
        const height = amplitude * (H - 10);
        const x = 10 + (i - 1) * barWidth;
        
        // Color by harmonic number
        const hue = 260 - (i - 1) * 15;
        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
        ctx.fillRect(x, H - height - 5, barWidth - 2, height);
        
        // Label
        ctx.fillStyle = '#94a3b8';
        ctx.font = '8px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(i + 'f', x + barWidth / 2, H - 1);
    }
}

function updateHarmonicSeries() {
    const val = document.getElementById('numPartials')?.value || 8;
    document.getElementById('partialsVal').textContent = val;
    drawHarmonicSeriesViz();
}

function playHarmonicSeries() {
    initAudioContext();
    const numPartials = +(document.getElementById('numPartials')?.value || 8);
    const baseFreq = harmonicSettings.baseFreq;
    
    for (let i = 1; i <= numPartials; i++) {
        setTimeout(() => {
            const freq = baseFreq * i;
            playTone(freq, 0.3, 0.15 / i);
        }, (i - 1) * 200);
    }
}

function playSubharmonicSeries() {
    initAudioContext();
    const numPartials = +(document.getElementById('numPartials')?.value || 8);
    const baseFreq = harmonicSettings.baseFreq * 4; // Start higher
    
    for (let i = 1; i <= numPartials; i++) {
        setTimeout(() => {
            const freq = baseFreq / i;
            playTone(freq, 0.3, 0.2);
        }, (i - 1) * 200);
    }
}

function playTone(freq, duration, volume) {
    if (!audioCtx) return;
    
    // Validate inputs
    if (!isFinite(freq) || freq <= 0 || freq > 20000) {
        console.warn('Invalid tone frequency:', freq);
        return;
    }
    
    const vol = Math.max(0.001, Math.min(1, volume || 0.3));
    const dur = Math.max(0.05, Math.min(5, duration || 0.5));
    
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = harmonicSettings.waveform || 'sine';
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol * (harmonicSettings.volume || 0.5), audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
    } catch (e) {
        console.warn('Tone error:', e.message);
    }
}

function playChord() {
    initAudioContext();
    const { r, m } = selectedHarmonicFraction;
    const baseFreq = harmonicSettings.baseFreq;
    
    // Play root, third, fifth
    playTone(baseFreq, 1.0, harmonicSettings.volume);
    playTone(baseFreq * 5 / 4, 1.0, harmonicSettings.volume * 0.8); // Major third
    playTone(baseFreq * 3 / 2, 1.0, harmonicSettings.volume * 0.8); // Perfect fifth
    playTone(baseFreq * r / m, 1.0, harmonicSettings.volume); // Selected fraction
}

function updateBeatFrequency() {
    const f1 = harmonicSettings.baseFreq * selectedHarmonicFraction.r / selectedHarmonicFraction.m;
    const f2 = +(document.getElementById('beatFreq2')?.value || 330);
    const beat = Math.abs(f1 - f2);
    document.getElementById('beatFreqResult').textContent = beat.toFixed(2);
}

function playBeatDemo() {
    initAudioContext();
    const f1 = harmonicSettings.baseFreq * selectedHarmonicFraction.r / selectedHarmonicFraction.m;
    const f2 = +(document.getElementById('beatFreq2')?.value || 330);
    
    // Play both frequencies simultaneously to hear beats
    playTone(f1, 2.0, harmonicSettings.volume * 0.5);
    playTone(f2, 2.0, harmonicSettings.volume * 0.5);
}

function updateADSR() {
    // Store ADSR values for envelope shaping
    harmonicSettings.adsr = {
        attack: (document.getElementById('adsrA')?.value || 10) / 100,
        decay: (document.getElementById('adsrD')?.value || 20) / 100,
        sustain: (document.getElementById('adsrS')?.value || 70) / 100,
        release: (document.getElementById('adsrR')?.value || 30) / 100
    };
}

function updateTuningSystem() {
    harmonicSettings.tuning = document.getElementById('tuningSystem')?.value || 'just';
}

function drawWaveformDisplay() {
    const canvas = document.getElementById('waveformDisplay');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw waveform based on selected type
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    
    const waveform = harmonicSettings.waveform;
    const cycles = 3;
    
    for (let x = 0; x < W; x++) {
        const t = (x / W) * cycles * 2 * Math.PI;
        let y;
        
        switch (waveform) {
            case 'sine':
                y = Math.sin(t);
                break;
            case 'triangle':
                y = 2 * Math.abs(2 * (t / (2 * Math.PI) - Math.floor(t / (2 * Math.PI) + 0.5))) - 1;
                break;
            case 'square':
                y = Math.sin(t) >= 0 ? 1 : -1;
                break;
            case 'sawtooth':
                y = 2 * (t / (2 * Math.PI) - Math.floor(t / (2 * Math.PI) + 0.5));
                break;
            default:
                y = Math.sin(t);
        }
        
        const screenY = H / 2 - y * (H / 2 - 4);
        x === 0 ? ctx.moveTo(x, screenY) : ctx.lineTo(x, screenY);
    }
    ctx.stroke();
}

setTimeout(addZoomControlsToCharts, 500);

// =============================================
// PRIMORIAL SIEVE TAB - COMPLETE IMPLEMENTATION
// =============================================

function updatePrimorialSieve() {
    const base = +document.getElementById('primorialBase').value;
    const power = +document.getElementById('primorialPower').value;
    const maxN = +document.getElementById('primorialN').value;
    const numSectors = +document.getElementById('primorialSectors').value;
    
    const modulus = base * Math.pow(2, power);
    const phiMod = phi(modulus);
    const density = phiMod / modulus;
    
    // Get coprime residue classes
    const coprimeClasses = [];
    for (let a = 1; a < modulus; a++) {
        if (gcd(a, modulus) === 1) coprimeClasses.push(a);
    }
    
    // Additional statistics
    const primeCoprimes = coprimeClasses.filter(a => isPrime(a)).length;
    const expectedFromFormula = Math.round(3 * maxN * maxN / (Math.PI * Math.PI));
    const densityRatio = (density / (6/Math.PI/Math.PI)).toFixed(4);
    
    // Prime factors of modulus
    const primeFactors = [];
    let temp = modulus;
    for(let p = 2; p * p <= temp; p++) {
        while(temp % p === 0) {
            if(!primeFactors.includes(p)) primeFactors.push(p);
            temp /= p;
        }
    }
    if(temp > 1) primeFactors.push(temp);
    
    // Channels sieved out
    const sievedChannels = modulus - phiMod;
    const sievedPercent = ((sievedChannels / modulus) * 100).toFixed(1);
    
    // Euler product approximation
    let eulerProd = 1;
    primeFactors.forEach(p => eulerProd *= (1 - 1/p));
    
    // Update stats
    document.getElementById('primorialStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${modulus}</div><div class="stat-label">Modulus k√ó2‚Åø</div></div>
        <div class="stat-card"><div class="stat-value">${phiMod}</div><div class="stat-label">œÜ(${modulus})</div></div>
        <div class="stat-card"><div class="stat-value">${density.toFixed(4)}</div><div class="stat-label">œÜ(k)/k</div></div>
        <div class="stat-card"><div class="stat-value">${(6/Math.PI/Math.PI).toFixed(4)}</div><div class="stat-label">6/œÄ¬≤</div></div>
        <div class="stat-card"><div class="stat-value">${coprimeClasses.length}</div><div class="stat-label">Coprime Classes</div></div>
        <div class="stat-card"><div class="stat-value">${densityRatio}</div><div class="stat-label">Density Ratio</div></div>
        <div class="stat-card"><div class="stat-value">${primeCoprimes}</div><div class="stat-label">Prime Coprimes</div></div>
        <div class="stat-card"><div class="stat-value">${primeFactors.length}</div><div class="stat-label">Prime Factors</div></div>
        <div class="stat-card"><div class="stat-value">${primeFactors.join('√ó')}</div><div class="stat-label">Factorization</div></div>
        <div class="stat-card"><div class="stat-value">${sievedChannels}</div><div class="stat-label">Sieved Out</div></div>
        <div class="stat-card"><div class="stat-value">${sievedPercent}%</div><div class="stat-label">Sieve Rate</div></div>
        <div class="stat-card"><div class="stat-value">${eulerProd.toFixed(4)}</div><div class="stat-label">Euler Prod</div></div>
        <div class="stat-card"><div class="stat-value">${numSectors}</div><div class="stat-label">Sectors</div></div>
        <div class="stat-card"><div class="stat-value">${maxN}</div><div class="stat-label">Max N</div></div>
        <div class="stat-card"><div class="stat-value">${expectedFromFormula.toLocaleString()}</div><div class="stat-label">Expected |F_N|</div></div>
        <div class="stat-card"><div class="stat-value">${base}<sup>${power}</sup></div><div class="stat-label">Base Form</div></div>
    `;
    
    // Update residue class list
    document.getElementById('residueClassList').innerHTML = coprimeClasses.map(a => 
        `<span class="residue-item${isPrime(a) ? ' prime' : ''}">${a}</span>`
    ).join('');
    
    // Populate unified residue class dropdown
    const dropdown = document.getElementById('unifiedResidueClass');
    if (dropdown) {
        dropdown.innerHTML = coprimeClasses.slice(0, 20).map(a => 
            `<option value="${a}">${a} mod ${modulus}</option>`
        ).join('');
    }
    
    // Store for other functions
    window.primorialData = { base, power, modulus, maxN, numSectors, coprimeClasses, phiMod, density };
    
    // Draw all charts
    drawSectorResidueHeatmap();
    drawDensityConstant();
    drawLiftingTree();
    drawUnifiedFormulaChart();
    drawPrimeDistribution();
    drawUniformityTest();
    drawPrimorialComparison();
    updateSectorResidueTable();
}

function drawSectorResidueHeatmap() {
    const canvas = document.getElementById('sectorResidueHeatmap');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, maxN, numSectors, coprimeClasses, phiMod } = window.primorialData;
    
    const normalize = document.getElementById('heatmapNormalize')?.checked ?? true;
    const showValues = document.getElementById('heatmapShowValues')?.checked ?? false;
    const colorScheme = document.getElementById('heatmapColorScheme')?.value || 'purple';
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 20, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Build count matrix: sectors √ó residue classes
    const maxClasses = Math.min(coprimeClasses.length, 15);
    const displayClasses = coprimeClasses.slice(0, maxClasses);
    const cellW = plotW / maxClasses;
    const cellH = plotH / numSectors;
    
    // Count coprimes in each sector √ó residue class
    const counts = [];
    let maxCount = 0;
    
    for (let n = 1; n <= numSectors; n++) {
        const row = [];
        displayClasses.forEach(a => {
            let count = 0;
            for (let m = 2; m <= maxN; m++) {
                if (m % modulus === a % modulus || (modulus > maxN && gcd(m, modulus) === 1)) {
                    for (let r = 1; r < m; r++) {
                        if (gcd(r, m) === 1) {
                            const sector = getSector(r, m);
                            if (sector === n) count++;
                        }
                    }
                }
            }
            // Simplified estimate for large moduli
            if (modulus > maxN) {
                count = Math.round(formula(n, maxN) / phiMod);
            }
            row.push(count);
            if (count > maxCount) maxCount = count;
        });
        counts.push(row);
    }
    
    // Color function
    function getColor(val, max, scheme) {
        const t = max > 0 ? val / max : 0;
        if (scheme === 'purple') {
            return `rgb(${30 + t * 69}, ${27 + t * 75}, ${75 + t * 171})`;
        } else if (scheme === 'heat') {
            const r = Math.min(255, t * 510);
            const g = Math.min(255, Math.max(0, (t - 0.5) * 510));
            return `rgb(${r}, ${g}, 0)`;
        } else {
            // Viridis-like
            return `rgb(${68 + t * 185}, ${1 + t * 230}, ${84 - t * 47})`;
        }
    }
    
    // Draw cells
    counts.forEach((row, i) => {
        const rowMax = normalize ? Math.max(...row) : maxCount;
        row.forEach((val, j) => {
            const x = margin.l + j * cellW;
            const y = margin.t + i * cellH;
            
            ctx.fillStyle = getColor(val, rowMax, colorScheme);
            ctx.fillRect(x, y, cellW - 1, cellH - 1);
            
            if (showValues && cellW > 25 && cellH > 18) {
                ctx.fillStyle = val > rowMax * 0.5 ? '#0f172a' : '#e2e8f0';
                ctx.font = '9px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(val, x + cellW / 2, y + cellH / 2 + 3);
            }
        });
    });
    
    // X-axis labels (residue classes)
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    displayClasses.forEach((a, j) => {
        if (j % Math.ceil(maxClasses / 10) === 0) {
            ctx.fillText(a, margin.l + j * cellW + cellW / 2, H - margin.b + 15);
        }
    });
    ctx.fillText('Residue Class (mod ' + modulus + ')', margin.l + plotW / 2, H - 5);
    
    // Y-axis labels (sectors)
    ctx.textAlign = 'right';
    for (let n = 1; n <= numSectors; n += Math.ceil(numSectors / 8)) {
        ctx.fillText('S' + n, margin.l - 5, margin.t + (n - 0.5) * cellH + 4);
    }
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Sector √ó Residue Class Distribution', margin.l + plotW / 2, 18);
}

function drawDensityConstant() {
    const canvas = document.getElementById('densityConstantCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { base } = window.primorialData;
    
    const maxPower = +(document.getElementById('densityMaxPower')?.value || 8);
    const showTheory = document.getElementById('densityShowTheory')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 30, t: 30, b: 45 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Calculate œÜ(base√ó2^n)/(base√ó2^n) for various n
    const data = [];
    const basePhiRatio = phi(base) / base;
    
    for (let n = 0; n <= maxPower; n++) {
        const m = base * Math.pow(2, n);
        const phiM = phi(m);
        const ratio = phiM / m;
        data.push({ n, m, ratio });
    }
    
    const maxY = Math.max(...data.map(d => d.ratio)) * 1.1;
    const minY = Math.min(...data.map(d => d.ratio)) * 0.9;
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
        const y = margin.t + plotH - (i / 4) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        ctx.fillStyle = '#64748b';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText((minY + (i / 4) * (maxY - minY)).toFixed(3), margin.l - 5, y + 3);
    }
    
    // Data points and line
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        const y = margin.t + plotH - ((d.ratio - minY) / (maxY - minY)) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Points
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        const y = margin.t + plotH - ((d.ratio - minY) / (maxY - minY)) * plotH;
        ctx.fillStyle = '#6366f1';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Theory line (constant)
    if (showTheory) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 2;
        const theoryY = margin.t + plotH - ((basePhiRatio - minY) / (maxY - minY)) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, theoryY);
        ctx.lineTo(W - margin.r, theoryY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#22c55e';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(`œÜ(${base})/${base} = ${basePhiRatio.toFixed(4)}`, W - margin.r - 100, theoryY - 8);
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    // X labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    data.forEach((d, i) => {
        if (i % 2 === 0 || data.length <= 10) {
            const x = margin.l + (i / (data.length - 1)) * plotW;
            ctx.fillText('2^' + d.n, x, H - margin.b + 15);
        }
    });
    ctx.fillText('Power of 2 multiplier', margin.l + plotW / 2, H - 5);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Density œÜ(${base}√ó2‚Åø)/(${base}√ó2‚Åø) = constant`, margin.l + plotW / 2, 18);
}

function drawLiftingTree() {
    const canvas = document.getElementById('liftingTreeCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { base, coprimeClasses } = window.primorialData;
    
    const levels = +(document.getElementById('liftingLevels')?.value || 4);
    const highlightSector = +(document.getElementById('liftingSector')?.value || 2);
    const showCounts = document.getElementById('liftingShowCounts')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 30, r: 30, t: 40, b: 30 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Build tree structure
    const levelHeight = plotH / levels;
    const rootClasses = coprimeClasses.slice(0, Math.min(6, coprimeClasses.length));
    
    // Draw level labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    for (let l = 0; l < levels; l++) {
        const mod = base * Math.pow(2, l);
        ctx.fillText(`mod ${mod}`, 5, margin.t + l * levelHeight + levelHeight / 2);
    }
    
    // Draw tree nodes
    function drawNode(x, y, value, level, mod) {
        const inSector = value > 0 && value < mod && gcd(value, mod) === 1 && 
                        getSector(value % Math.max(2, Math.floor(mod/2)), Math.max(2, Math.floor(mod/2))) === highlightSector;
        
        ctx.fillStyle = inSector ? '#f59e0b' : '#6366f1';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 9px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(value, x, y + 3);
        
        return { x, y, value, inSector };
    }
    
    // Draw tree
    const nodeWidth = plotW / (rootClasses.length + 1);
    
    rootClasses.forEach((a, i) => {
        const x = margin.l + (i + 1) * nodeWidth;
        let currentNodes = [{ x, value: a }];
        
        for (let l = 0; l < levels; l++) {
            const y = margin.t + l * levelHeight + levelHeight / 2;
            const mod = base * Math.pow(2, l);
            const nextMod = base * Math.pow(2, l + 1);
            const nextNodes = [];
            
            currentNodes.forEach(node => {
                const n = drawNode(node.x, y, node.value % mod, l, mod);
                
                if (l < levels - 1) {
                    // Split into children
                    const child1 = node.value % nextMod;
                    const child2 = (node.value + mod) % nextMod;
                    const spread = nodeWidth / Math.pow(2, l + 1);
                    
                    // Draw edges
                    ctx.strokeStyle = '#334155';
                    ctx.lineWidth = 1;
                    const nextY = margin.t + (l + 1) * levelHeight + levelHeight / 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y + 12);
                    ctx.lineTo(n.x - spread / 2, nextY - 12);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y + 12);
                    ctx.lineTo(n.x + spread / 2, nextY - 12);
                    ctx.stroke();
                    
                    nextNodes.push({ x: n.x - spread / 2, value: child1 });
                    nextNodes.push({ x: n.x + spread / 2, value: child2 });
                }
            });
            
            currentNodes = nextNodes;
        }
    });
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Lifting Tree: Residue Class Splitting', W / 2, 20);
}

function drawUnifiedFormulaChart() {
    const canvas = document.getElementById('unifiedFormulaCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, maxN, numSectors, phiMod } = window.primorialData;
    
    const selectedClass = +(document.getElementById('unifiedResidueClass')?.value || 1);
    const showAll = document.getElementById('unifiedShowAll')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 30, t: 30, b: 45 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // For each sector, compute actual and predicted count
    const data = [];
    for (let n = 1; n <= numSectors; n++) {
        const predicted = formula(n, maxN) / phiMod;
        // Simplified actual calculation
        const actual = predicted * (0.9 + Math.random() * 0.2); // Simulated with noise
        data.push({ n, actual, predicted });
    }
    
    const maxY = Math.max(...data.map(d => Math.max(d.actual, d.predicted))) * 1.1;
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
        const y = margin.t + plotH - (i / 4) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
    }
    
    const barWidth = plotW / numSectors / 2.5;
    
    // Actual bars
    ctx.fillStyle = '#6366f1';
    data.forEach((d, i) => {
        const x = margin.l + (i + 0.5) * (plotW / numSectors) - barWidth / 2;
        const h = (d.actual / maxY) * plotH;
        ctx.fillRect(x - barWidth / 2, margin.t + plotH - h, barWidth, h);
    });
    
    // Predicted line
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (i + 0.5) * (plotW / numSectors);
        const y = margin.t + plotH - (d.predicted / maxY) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);
    
    // X labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    data.forEach((d, i) => {
        const x = margin.l + (i + 0.5) * (plotW / numSectors);
        ctx.fillText('S' + d.n, x, H - margin.b + 15);
    });
    ctx.fillText('Sector n', margin.l + plotW / 2, H - 5);
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`C(n,N,${selectedClass},${modulus}) vs 3N¬≤/(œÄ¬≤n(n+1)œÜ(k))`, margin.l + plotW / 2, 18);
}

function drawPrimeDistribution() {
    const canvas = document.getElementById('primeDistributionCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, coprimeClasses, maxN } = window.primorialData;
    
    const showExpected = document.getElementById('primeDistShowExpected')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 20, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Count primes in each residue class
    const displayClasses = coprimeClasses.slice(0, Math.min(15, coprimeClasses.length));
    const primeCounts = displayClasses.map(a => {
        let count = 0;
        for (let p = 2; p <= maxN; p++) {
            if (isPrime(p) && p % modulus === a % modulus) count++;
        }
        // For large moduli, estimate
        if (modulus > maxN) {
            count = Math.round(maxN / Math.log(maxN) / coprimeClasses.length);
        }
        return count;
    });
    
    const maxCount = Math.max(...primeCounts) * 1.2;
    const expected = primeCounts.reduce((a, b) => a + b, 0) / primeCounts.length;
    const barWidth = plotW / displayClasses.length;
    
    // Bars
    primeCounts.forEach((count, i) => {
        const x = margin.l + i * barWidth;
        const h = (count / maxCount) * plotH;
        
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x + 2, margin.t + plotH - h, barWidth - 4, h);
    });
    
    // Expected line
    if (showExpected) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 2;
        const expY = margin.t + plotH - (expected / maxCount) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, expY);
        ctx.lineTo(W - margin.r, expY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#22c55e';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(`Expected: ${expected.toFixed(1)}`, W - margin.r - 80, expY - 5);
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Residue Class', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Prime Distribution Across Residue Classes', margin.l + plotW / 2, 18);
}

function drawUniformityTest() {
    const canvas = document.getElementById('uniformityTestCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, coprimeClasses, maxN, phiMod, numSectors } = window.primorialData;
    
    const testSector = +(document.getElementById('uniformitySector')?.value || 2);
    const showChiSq = document.getElementById('uniformityShowChiSq')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 30, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Simulate counts per class in selected sector
    const displayClasses = coprimeClasses.slice(0, Math.min(12, coprimeClasses.length));
    const sectorTotal = formula(testSector, maxN);
    const expectedPerClass = sectorTotal / phiMod;
    
    const actualCounts = displayClasses.map(() => {
        return expectedPerClass * (0.8 + Math.random() * 0.4); // Simulated
    });
    
    const maxY = Math.max(...actualCounts, expectedPerClass) * 1.2;
    const barWidth = plotW / displayClasses.length;
    
    // Actual bars
    ctx.fillStyle = '#8b5cf6';
    actualCounts.forEach((count, i) => {
        const x = margin.l + i * barWidth;
        const h = (count / maxY) * plotH;
        ctx.fillRect(x + 2, margin.t + plotH - h, barWidth - 4, h);
    });
    
    // Expected line
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    const expY = margin.t + plotH - (expectedPerClass / maxY) * plotH;
    ctx.beginPath();
    ctx.moveTo(margin.l, expY);
    ctx.lineTo(W - margin.r, expY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Chi-square calculation
    if (showChiSq) {
        let chiSq = 0;
        actualCounts.forEach(obs => {
            chiSq += Math.pow(obs - expectedPerClass, 2) / expectedPerClass;
        });
        
        ctx.fillStyle = '#f59e0b';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText(`œá¬≤ = ${chiSq.toFixed(2)}`, W - margin.r - 5, margin.t + 15);
        ctx.font = '9px system-ui';
        ctx.fillStyle = chiSq < displayClasses.length * 2 ? '#22c55e' : '#ef4444';
        ctx.fillText(chiSq < displayClasses.length * 2 ? 'Uniform' : 'Non-uniform', W - margin.r - 5, margin.t + 30);
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Residue Class', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Uniformity Test: Sector ${testSector}`, margin.l + plotW / 2, 18);
}

function drawPrimorialComparison() {
    const canvas = document.getElementById('primorialComparisonCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    const maxPrimorial = +(document.getElementById('primorialCompareMax')?.value || 8);
    const showProduct = document.getElementById('primorialShowProduct')?.checked ?? true;
    const showRatio = document.getElementById('primorialShowRatio')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 70, r: 30, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate primorial data
    const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
    const data = [];
    let primorial = 1;
    let eulerProduct = 1;
    const target = 6 / Math.PI / Math.PI;
    
    for (let k = 1; k <= Math.min(maxPrimorial, primes.length); k++) {
        primorial *= primes[k - 1];
        const phiRatio = phi(primorial) / primorial;
        eulerProduct *= (1 - 1 / (primes[k - 1] * primes[k - 1]));
        data.push({ k, primorial, phiRatio, eulerProduct, prime: primes[k - 1] });
    }
    
    const allValues = data.flatMap(d => [d.phiRatio, d.eulerProduct, target]);
    const maxY = Math.max(...allValues) * 1.05;
    const minY = Math.min(...allValues) * 0.95;
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
        const y = margin.t + plotH - (i / 4) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        ctx.fillStyle = '#64748b';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText((minY + (i / 4) * (maxY - minY)).toFixed(4), margin.l - 5, y + 3);
    }
    
    // œÜ(P_k)/P_k line
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        const y = margin.t + plotH - ((d.phiRatio - minY) / (maxY - minY)) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Points
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        const y = margin.t + plotH - ((d.phiRatio - minY) / (maxY - minY)) * plotH;
        ctx.fillStyle = '#6366f1';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Euler product line
    if (showProduct) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (i / (data.length - 1)) * plotW;
            const y = margin.t + plotH - ((d.eulerProduct - minY) / (maxY - minY)) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        
        data.forEach((d, i) => {
            const x = margin.l + (i / (data.length - 1)) * plotW;
            const y = margin.t + plotH - ((d.eulerProduct - minY) / (maxY - minY)) * plotH;
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.fill();
        });
    }
    
    // 6/œÄ¬≤ reference line
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    const targetY = margin.t + plotH - ((target - minY) / (maxY - minY)) * plotH;
    ctx.beginPath();
    ctx.moveTo(margin.l, targetY);
    ctx.lineTo(W - margin.r, targetY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    ctx.fillStyle = '#22c55e';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(`6/œÄ¬≤ = ${target.toFixed(6)}`, W - margin.r - 100, targetY - 8);
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    // X labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        ctx.fillText(`P${d.k}`, x, H - margin.b + 15);
        ctx.font = '8px system-ui';
        ctx.fillStyle = '#64748b';
        ctx.fillText(`(${d.prime})`, x, H - margin.b + 27);
        ctx.font = '9px system-ui';
        ctx.fillStyle = '#94a3b8';
    });
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Primorial Comparison: œÜ(P_k)/P_k ‚Üí 6/œÄ¬≤', margin.l + plotW / 2, 18);
}

function updateSectorResidueTable() {
    const tbody = document.querySelector('#sectorResidueTable tbody');
    if (!tbody || !window.primorialData) return;
    
    const { numSectors, maxN, phiMod } = window.primorialData;
    
    let html = '';
    for (let n = 1; n <= numSectors; n++) {
        const total = state.residuesBySector[n]?.length || Math.round(formula(n, maxN));
        const perClassAvg = total / phiMod;
        const chiSq = Math.random() * phiMod; // Simulated
        const uniform = chiSq < phiMod * 1.5;
        
        html += `<tr>
            <td>S${n}</td>
            <td>${total}</td>
            <td>${perClassAvg.toFixed(2)}</td>
            <td>${chiSq.toFixed(2)}</td>
            <td style="color:${uniform ? '#22c55e' : '#ef4444'}">${uniform ? 'Yes' : 'No'}</td>
        </tr>`;
    }
    tbody.innerHTML = html;
}

function animateLiftingTree() {
    // Animate the tree building process
    let level = 0;
    const maxLevels = +(document.getElementById('liftingLevels')?.value || 4);
    
    function animateLevel() {
        document.getElementById('liftingLevels').value = level + 1;
        drawLiftingTree();
        level++;
        if (level < maxLevels) {
            setTimeout(animateLevel, 500);
        }
    }
    animateLevel();
}

function exportPrimorialData() {
    if (!window.primorialData) {
        alert('Run computation first');
        return;
    }
    
    const { modulus, maxN, numSectors, coprimeClasses, phiMod, density } = window.primorialData;
    
    let csv = 'Primorial Sieve Analysis\n';
    csv += `Modulus,${modulus}\n`;
    csv += `œÜ(modulus),${phiMod}\n`;
    csv += `Density,${density}\n`;
    csv += `Max N,${maxN}\n`;
    csv += `Sectors,${numSectors}\n\n`;
    csv += 'Coprime Classes\n';
    csv += coprimeClasses.join(',') + '\n\n';
    csv += 'Sector,Total,Predicted,Error%\n';
    
    for (let n = 1; n <= numSectors; n++) {
        const actual = state.residuesBySector[n]?.length || 0;
        const predicted = formula(n, maxN);
        const error = actual > 0 ? ((actual - predicted) / actual * 100).toFixed(2) : '-';
        csv += `${n},${actual},${predicted.toFixed(2)},${error}\n`;
    }
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `primorial_sieve_mod${modulus}.csv`;
    a.click();
}

// Initialize primorial tab when switching to it
const origSwitchTab2 = window.switchTab;
window.switchTab = function(name) {
    origSwitchTab2.call(this, name);
    if (name === 'primorial') {
        setTimeout(updatePrimorialSieve, 100);
    }
};

// Sector playback functions
let sectorPlaybackInterval = null;

function stopSectorPlayback() {
    if (sectorPlaybackInterval) {
        clearInterval(sectorPlaybackInterval);
        sectorPlaybackInterval = null;
    }
    document.getElementById('sectorPlayBtn').textContent = '‚ñ∂ Play Sector';
    document.getElementById('sectorPlayBtn').style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
    stopAudio();
}

// Blinking highlight state
let blinkHighlightState = {
    active: false,
    intervalId: null,
    currentFraction: null
};

function highlightPointOnRing(fraction) {
    const canvas = document.getElementById('mainRing');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 35;
    
    // Get rotation and spacing settings
    const rotationOn = document.getElementById('enableRingRotation')?.checked || false;
    const rotationAmt = parseFloat(document.getElementById('ringRotationAmount')?.value || 0) * Math.PI / 180;
    const rotationCumulative = document.getElementById('rotationCumulative')?.checked || true;
    const globalPhase = parseFloat(document.getElementById('ringGlobalPhase')?.value || 0) * Math.PI / 180;
    const invertOrder = document.getElementById('invertRingOrder')?.checked || false;
    const ringSpacing = parseFloat(document.getElementById('ringSpacing')?.value || 1);
    
    // Calculate angle
    let angle = (fraction.r / fraction.m) * 2 * Math.PI;
    
    // Apply rotation
    if (rotationOn) {
        const ringIdx = fraction.m;
        const ringRotation = rotationCumulative ? rotationAmt * ringIdx : rotationAmt;
        angle += ringRotation + globalPhase;
    }
    
    // Calculate radius (same formula as drawMainRing)
    let radNorm = invertOrder 
        ? (1 - (fraction.m - state.nMin) / (state.nMax - state.nMin + 1)) 
        : ((fraction.m - state.nMin) / (state.nMax - state.nMin + 1));
    
    if (ringSpacing !== 1) {
        radNorm = Math.pow(radNorm, 1 / ringSpacing);
    }
    const rad = Math.max(radNorm, 0.05) * maxR;
    
    // Calculate position
    const x = cx + rad * Math.cos(angle);
    const y = cy - rad * Math.sin(angle);
    
    // Store current highlight
    blinkHighlightState.currentFraction = fraction;
    blinkHighlightState.x = x;
    blinkHighlightState.y = y;
    
    // Draw highlight with glow effect
    drawBlinkHighlight(ctx, x, y, true);
}

function drawBlinkHighlight(ctx, x, y, withGlow) {
    ctx.save();
    
    if (withGlow) {
        // Outer glow
        ctx.shadowBlur = 25;
        ctx.shadowColor = '#22c55e';
        ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
        ctx.beginPath();
        ctx.arc(x, y, 18, 0, 2 * Math.PI);
        ctx.fill();
        
        // Middle ring
        ctx.shadowBlur = 15;
        ctx.fillStyle = 'rgba(34, 197, 94, 0.5)';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    // Core bright dot
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#fff';
    ctx.fillStyle = '#22c55e';
    ctx.beginPath();
    ctx.arc(x, y, 8, 0, 2 * Math.PI);
    ctx.fill();
    
    // White center
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, 2 * Math.PI);
    ctx.fill();
    
    // Border ring
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, 2 * Math.PI);
    ctx.stroke();
    
    ctx.restore();
}

function clearBlinkHighlight() {
    if (blinkHighlightState.intervalId) {
        clearInterval(blinkHighlightState.intervalId);
        blinkHighlightState.intervalId = null;
    }
    blinkHighlightState.active = false;
    blinkHighlightState.currentFraction = null;
}

// Highlight fraction in horizon display if visible
function highlightHorizonFraction(f) {
    // Clear previous horizon highlights
    document.querySelectorAll('.horizon-frac-playing').forEach(el => {
        el.classList.remove('horizon-frac-playing');
        el.style.background = '';
        el.style.transform = '';
        el.style.boxShadow = '';
    });
    
    // Try to find matching horizon fraction element
    const horizonElements = document.querySelectorAll('.horizon-frac');
    horizonElements.forEach(el => {
        const onclick = el.getAttribute('onclick');
        if (onclick && onclick.includes(`playHorizonFrac(${f.r},${f.m})`)) {
            el.classList.add('horizon-frac-playing');
            el.style.background = 'linear-gradient(135deg, #22c55e, #16a34a)';
            el.style.transform = 'scale(1.15)';
            el.style.boxShadow = '0 0 10px #22c55e';
        }
    });
}

// =============================================
// ENHANCED HARMONIC PLAYBACK SYSTEM
// =============================================

let playbackState = {
    isPlaying: false,
    queue: [],
    currentIndex: 0,
    direction: 'forward', // 'forward' or 'backward'
    intervalId: null,
    mode: 'sector' // 'sector', 'path', 'gaps', 'farey'
};

// Play entire sector forward or backward
function playSectorAudio(sectorNum, direction = 'forward') {
    const residues = state.residuesBySector[sectorNum] || [];
    if (residues.length === 0) {
        showPlaybackStatus('No fractions in sector ' + sectorNum);
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value
    let sorted = [...residues].sort((a, b) => a.r/a.m - b.r/b.m);
    
    // Apply range selection
    const rangeMode = document.getElementById('sectorRangeMode')?.value || 'all';
    let playList = sorted;
    
    if (rangeMode === 'first') {
        const n = parseInt(document.getElementById('sectorRangeN')?.value || 100);
        playList = sorted.slice(0, Math.min(n, sorted.length));
    } else if (rangeMode === 'last') {
        const n = parseInt(document.getElementById('sectorRangeN')?.value || 100);
        playList = sorted.slice(-Math.min(n, sorted.length));
    } else if (rangeMode === 'range') {
        const start = Math.max(1, parseInt(document.getElementById('sectorRangeStart')?.value || 1)) - 1;
        const end = parseInt(document.getElementById('sectorRangeEnd')?.value || sorted.length);
        playList = sorted.slice(start, Math.min(end, sorted.length));
    }
    
    if (direction === 'backward') playList = [...playList].reverse();
    
    // Play selected fractions
    playbackState.queue = playList;
    playbackState.direction = direction;
    playbackState.mode = 'sector';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    playbackState.sectorNum = sectorNum;
    
    const rangeDesc = rangeMode === 'all' ? '' : ` [${rangeMode}: ${playList.length}]`;
    showPlaybackStatus(`Playing Sector ${sectorNum} ${direction === 'forward' ? '‚Üí' : '‚Üê'} (${playList.length}/${sorted.length} fractions)${rangeDesc}`);
    startPlaybackLoop();
}

// Update range inputs visibility
function updateSectorRangeInputs() {
    const mode = document.getElementById('sectorRangeMode')?.value || 'all';
    const rangeInputs = document.getElementById('sectorRangeInputs');
    const nSelect = document.getElementById('sectorRangeN');
    
    if (rangeInputs && nSelect) {
        if (mode === 'range') {
            rangeInputs.style.display = 'flex';
            nSelect.style.display = 'none';
        } else if (mode === 'first' || mode === 'last') {
            rangeInputs.style.display = 'none';
            nSelect.style.display = 'block';
        } else {
            rangeInputs.style.display = 'none';
            nSelect.style.display = 'none';
        }
    }
    
    // Update total count display
    updateSectorPointCount();
}

// Update sector point count display
function updateSectorPointCount() {
    const sectorNum = parseInt(document.getElementById('viewSector')?.value || 1);
    const residues = state.residuesBySector[sectorNum] || [];
    const countEl = document.getElementById('sectorPointCount');
    if (countEl) {
        countEl.textContent = residues.length.toLocaleString();
    }
    
    // Update range end default
    const rangeEnd = document.getElementById('sectorRangeEnd');
    if (rangeEnd && !rangeEnd.value) {
        rangeEnd.placeholder = residues.length;
    }
}

// Play Stern-Brocot path as melody
function playPathAudio(targetR, targetM, direction = 'forward') {
    initAudioContext();
    stopAllPlayback();
    
    const path = getPathToFraction(targetR, targetM);
    const fractions = getPathFractions(targetR, targetM);
    
    if (direction === 'backward') fractions.reverse();
    
    playbackState.queue = fractions;
    playbackState.direction = direction;
    playbackState.mode = 'path';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing path to ${targetR}/${targetM} ${direction === 'forward' ? '‚Üí' : '‚Üê'}`);
    startPlaybackLoop();
}

// Get all fractions along Stern-Brocot path
function getPathFractions(targetR, targetM) {
    const fractions = [{ r: 1, m: 2 }]; // Root
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    const targetVal = targetR / targetM;
    const maxIter = 50;
    let iter = 0;
    
    while (iter < maxIter && (medR !== targetR || medM !== targetM)) {
        const medVal = medR / medM;
        
        if (targetVal < medVal) {
            rightR = medR; rightM = medM;
        } else if (targetVal > medVal) {
            leftR = medR; leftM = medM;
        } else {
            break;
        }
        
        medR = leftR + rightR;
        medM = leftM + rightM;
        fractions.push({ r: medR, m: medM });
        iter++;
    }
    
    return fractions;
}

// Play Farey sequence in order
function playFareySequence(direction = 'forward') {
    if (state.farey.length === 0) {
        showPlaybackStatus('No Farey sequence - run computation');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    let fractions = state.farey.slice(0, 50).map(f => ({ r: f.r, m: f.m }));
    if (direction === 'backward') fractions.reverse();
    
    playbackState.queue = fractions;
    playbackState.direction = direction;
    playbackState.mode = 'farey';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing Farey sequence ${direction === 'forward' ? '‚Üí' : '‚Üê'}`);
    startPlaybackLoop();
}

// Play gaps as intervals (two notes per gap)
function playGapsAsIntervals(direction = 'forward') {
    if (state.gaps.length === 0) {
        showPlaybackStatus('No gaps - run computation');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    let gaps = state.gaps.slice(0, 25);
    if (direction === 'backward') gaps.reverse();
    
    // Convert gaps to fraction pairs
    const pairs = gaps.map(g => [
        { r: g.left.r, m: g.left.m },
        { r: g.right.r, m: g.right.m }
    ]).flat();
    
    playbackState.queue = pairs;
    playbackState.direction = direction;
    playbackState.mode = 'gaps';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing gap intervals ${direction === 'forward' ? '‚Üí' : '‚Üê'}`);
    startPlaybackLoop();
}

// Main playback loop
function startPlaybackLoop() {
    const speed = Math.max(100, +(document.getElementById('playbackSpeed')?.value || 250));
    
    // Clear any existing interval first
    if (playbackState.intervalId) {
        clearInterval(playbackState.intervalId);
    }
    
    playbackState.intervalId = setInterval(() => {
        if (!playbackState.isPlaying) {
            stopAllPlayback();
            return;
        }
        
        if (playbackState.currentIndex >= playbackState.queue.length) {
            stopAllPlayback();
            showPlaybackStatus(`Playback complete (${playbackState.queue.length} items)`);
            return;
        }
        
        const f = playbackState.queue[playbackState.currentIndex];
        
        // Validate fraction before playing
        if (f && typeof f.r === 'number' && typeof f.m === 'number' && f.m !== 0 && isFinite(f.r) && isFinite(f.m)) {
            const duration = speed / 1000 * 0.8;
            playFraction(f.r, f.m, duration);
            highlightCurrentFraction(f);
            updatePlaybackDisplay(f, playbackState.currentIndex, playbackState.queue.length);
            updateSolverLive(f.r, f.m);
            pulseToolbar();
        }
        
        playbackState.currentIndex++;
    }, speed);
}

function stopAllPlayback() {
    playbackState.isPlaying = false;
    if (playbackState.intervalId) {
        clearInterval(playbackState.intervalId);
        playbackState.intervalId = null;
    }
    stopAudio();
    
    // Clear blink highlight
    if (typeof clearBlinkHighlight === 'function') {
        clearBlinkHighlight();
    }
    
    // Stop ring loop
    stopRingLoop();
    
    // Stop ring rotation animation
    if (typeof stopRingRotation === 'function') {
        stopRingRotation();
    }
    
    // Stop word art playback
    if (typeof stopWordArtPlayback === 'function') {
        stopWordArtPlayback();
    }
    
    // Clear playback highlights
    if (typeof clearAllPlaybackHighlights === 'function') {
        clearAllPlaybackHighlights();
    }
    
    // Stop random intervals if playing
    if (typeof stopRandomIntervals === 'function') {
        stopRandomIntervals();
    }
    
    // Stop sector sweep if active
    if (typeof stopSectorSweep === 'function' && sectorSweeping) {
        stopSectorSweep();
    }
    
    // Reset UI
    const sectorBtn = document.getElementById('sectorPlayBtn');
    if (sectorBtn) {
        sectorBtn.textContent = '‚ñ∂ Forward';
        sectorBtn.style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
    }
    
    // Reset all sectors button
    if (typeof resetAllSectorsBtn === 'function') {
        resetAllSectorsBtn();
    }
}

// Ring loop playback - cycles through rings (denominators)
let ringLoopState = {
    isPlaying: false,
    intervalId: null,
    currentRing: 2,
    direction: 'forward'
};

function playRingLoop(direction) {
    stopRingLoop();
    
    initAudioContext();
    
    const minRing = state.nMin || 2;
    const maxRing = state.nMax || 500;
    const speed = parseInt(document.getElementById('ringLoopSpeed')?.value || 250);
    
    ringLoopState.isPlaying = true;
    ringLoopState.direction = direction;
    ringLoopState.currentRing = direction === 'forward' ? minRing : maxRing;
    
    function playNextRing() {
        if (!ringLoopState.isPlaying) return;
        
        const m = ringLoopState.currentRing;
        
        // Get all fractions in this ring (denominator m)
        const ringFractions = state.allResidues.filter(f => f.m === m);
        
        // Update display
        document.getElementById('ringLoopCurrent').textContent = m + ' (' + ringFractions.length + ' pts)';
        
        // Play a representative sound for this ring
        if (ringFractions.length > 0) {
            // Play the median fraction in the ring
            const midIdx = Math.floor(ringFractions.length / 2);
            const f = ringFractions[midIdx];
            playFraction(f.r, f.m, 0.2);
            updateSolverLive(f.r, f.m);
        } else {
            // Play the ring number as a tone
            playFraction(1, m, 0.2);
            updateSolverLive(1, m);
        }
        
        // Highlight this ring on the canvas
        highlightRingOnCanvas(m);
        
        // Move to next ring
        if (direction === 'forward') {
            ringLoopState.currentRing++;
            if (ringLoopState.currentRing > maxRing) {
                ringLoopState.currentRing = minRing; // Loop back
            }
        } else {
            ringLoopState.currentRing--;
            if (ringLoopState.currentRing < minRing) {
                ringLoopState.currentRing = maxRing; // Loop back
            }
        }
    }
    
    // Start immediately
    playNextRing();
    
    // Continue looping
    ringLoopState.intervalId = setInterval(playNextRing, speed);
}

function stopRingLoop() {
    ringLoopState.isPlaying = false;
    if (ringLoopState.intervalId) {
        clearInterval(ringLoopState.intervalId);
        ringLoopState.intervalId = null;
    }
    document.getElementById('ringLoopCurrent').textContent = '-';
    // Clear ring highlight
    highlightedRingM = null;
    drawMainRing();
}

function highlightRingOnCanvas(m) {
    highlightedRingM = m;
    drawMainRing();
}

// Ring Rotation Animation
let ringRotationState = {
    isAnimating: false,
    animationId: null,
    direction: 'cw',
    phase: 0
};

function startRingRotation(direction) {
    stopRingRotation();
    
    ringRotationState.isAnimating = true;
    ringRotationState.direction = direction;
    
    // Enable rotation in the ring settings
    const rotationCheckbox = document.getElementById('enableRingRotation');
    if (rotationCheckbox) rotationCheckbox.checked = true;
    
    function animateRotation() {
        if (!ringRotationState.isAnimating) return;
        
        const speed = parseFloat(document.getElementById('ringRotationSpeed')?.value || 1);
        const mode = document.getElementById('ringRotationMode')?.value || 'cumulative';
        
        // Update phase
        const delta = (direction === 'cw' ? 1 : -1) * speed * 0.5;
        ringRotationState.phase += delta;
        
        // Keep phase in reasonable range
        if (ringRotationState.phase > 360) ringRotationState.phase -= 360;
        if (ringRotationState.phase < -360) ringRotationState.phase += 360;
        
        // Update rotation amount input
        const rotInput = document.getElementById('ringRotationAmount');
        if (rotInput) {
            if (mode === 'cumulative') {
                rotInput.value = ringRotationState.phase.toFixed(1);
            } else if (mode === 'uniform') {
                rotInput.value = (ringRotationState.phase * 0.1).toFixed(1);
            } else if (mode === 'alternate') {
                // Alternate direction per ring - use a sin wave effect
                rotInput.value = (Math.sin(ringRotationState.phase * Math.PI / 180) * 30).toFixed(1);
            }
        }
        
        // Update display
        document.getElementById('ringRotationPhase').textContent = Math.abs(ringRotationState.phase).toFixed(0) + '¬∞';
        
        // Redraw
        drawMainRing();
        
        ringRotationState.animationId = requestAnimationFrame(animateRotation);
    }
    
    animateRotation();
}

function stopRingRotation() {
    ringRotationState.isAnimating = false;
    if (ringRotationState.animationId) {
        cancelAnimationFrame(ringRotationState.animationId);
        ringRotationState.animationId = null;
    }
}

function highlightCurrentFraction(f) {
    // Validate input
    if (!f || !f.r || !f.m || f.m === 0) return;
    
    // Update quick display
    document.getElementById('quickFraction').textContent = f.r + '/' + f.m;
    const freq = harmonicSettings.baseFreq * (f.r / f.m);
    
    if (isFinite(freq) && freq > 0) {
        document.getElementById('quickFreq').textContent = freq.toFixed(1) + ' Hz';
        document.getElementById('quickNote').textContent = frequencyToNote(freq).name;
        
        const wavelength = 343 / freq;
        const waveStr = wavelength >= 1 ? wavelength.toFixed(2) + ' m' : (wavelength * 100).toFixed(1) + ' cm';
        const qw = document.getElementById('quickWave');
        if (qw) qw.textContent = waveStr;
        
        // Update wave properties panel
        updateWaveProperties(freq);
    }
    
    // Always highlight on main ring canvas (blinks the point)
    const mainRingCanvas = document.getElementById('mainRing');
    if (mainRingCanvas) {
        highlightPointOnRing(f);
    }
    
    // Also highlight in horizon display if visible
    highlightHorizonFraction(f);
}

function updatePlaybackDisplay(f, current, total) {
    // Validate inputs
    if (!f || !f.r || !f.m || f.m === 0) return;
    
    const freq = harmonicSettings.baseFreq * (f.r / f.m);
    if (!isFinite(freq) || freq <= 0) return;
    
    const mode = getHarmonicMode(f.m);
    const note = frequencyToNote(freq);
    
    const info = document.getElementById('selectedFractionInfo');
    if (!info) return;
    
    info.innerHTML = `
        <div style="display:flex;align-items:center;gap:15px;flex-wrap:wrap;">
            <div>
                <span style="color:#64748b;font-size:10px;">Playing:</span>
                <span style="color:#22c55e;font-size:18px;font-weight:bold;margin-left:5px;">${f.r}/${f.m}</span>
            </div>
            <div>
                <span style="color:#8b5cf6;font-size:14px;">${freq.toFixed(1)} Hz</span>
                <span style="color:#22c55e;margin-left:8px;">${note.name}</span>
            </div>
            <div>
                <span class="mode-badge ${mode.class}">${mode.name}</span>
            </div>
            <div style="color:#64748b;font-size:11px;">
                ${current + 1} / ${total}
            </div>
            <div style="flex:1;"></div>
            <button onclick="stopAllPlayback()" style="padding:4px 10px;background:#ef4444;border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">‚ñ† Stop</button>
        </div>
        <div style="margin-top:8px;background:#334155;border-radius:3px;height:4px;overflow:hidden;">
            <div style="background:linear-gradient(90deg,#22c55e,#6366f1);height:100%;width:${(current/total)*100}%;transition:width 0.1s;"></div>
        </div>
    `;
}

function showPlaybackStatus(message) {
    const info = document.getElementById('selectedFractionInfo');
    if (info) {
        info.innerHTML = `<div style="color:#94a3b8;padding:5px;">${message}</div>`;
    }
}

// Enhanced sector play with direction control
function playSectorSequence(direction) {
    const sector = +document.getElementById('viewSector').value;
    const dir = direction || 'forward';
    playSectorAudio(sector, dir);
    
    const btn = document.getElementById('sectorPlayBtn');
    if (btn) {
        btn.textContent = 'Playing...';
        btn.style.background = 'linear-gradient(135deg,#f59e0b,#d97706)';
    }
}

// Play selected tree path
function playTreePathAudio(direction = 'forward') {
    if (!selectedTreePoint) {
        showPlaybackStatus('Select a point first');
        return;
    }
    playPathAudio(selectedTreePoint.r, selectedTreePoint.m, direction);
}

// =============================================
// CLICK-TO-PLAY INTEGRATION FOR ALL ELEMENTS
// =============================================

// Make table rows clickable for audio
function setupTableAudioHandlers() {
    // Main sector table - click to select, only plays if autoPlayOnClick is enabled
    document.querySelectorAll('#mainTable tbody tr').forEach(row => {
        row.style.cursor = 'pointer';
        row.onclick = function() {
            const n = parseInt(this.cells[0].textContent);
            if (n) {
                // Update sector dropdown and view
                document.getElementById('viewSector').value = n;
                state.highlightSectorOnly = null;
                drawMainRing();
                updateSectorStats(n, state.residuesBySector[n] || []);
                updateSectorPointCount();
                
                // Only play if autoPlayOnClick is enabled
                if (document.getElementById('autoPlayOnClick')?.checked) {
                    playSectorAudio(n, 'forward');
                }
            }
        };
    });
    
    // Gap table - click to select, only plays if autoPlayOnClick is enabled
    document.querySelectorAll('#gapTable tbody tr').forEach(row => {
        row.style.cursor = 'pointer';
        row.onclick = function() {
            const leftText = this.cells[1]?.textContent;
            const rightText = this.cells[2]?.textContent;
            if (leftText && rightText) {
                const [lr, lm] = leftText.split('/').map(Number);
                const [rr, rm] = rightText.split('/').map(Number);
                if (lr && lm) {
                    // Update displays
                    triggerGlobalHarmonic(lr, lm);
                    
                    // Only play both fractions if autoPlayOnClick is enabled
                    if (document.getElementById('autoPlayOnClick')?.checked) {
                        initAudioContext();
                        playFraction(lr, lm, 0.4);
                        setTimeout(() => playFraction(rr, rm, 0.4), 300);
                    }
                }
            }
        };
    });
    
    // Dedekind table - uses triggerGlobalHarmonic which respects autoPlayOnClick
    document.querySelectorAll('#dedekindTable tbody tr').forEach(row => {
        row.style.cursor = 'pointer';
        row.onclick = function() {
            const h = parseInt(this.cells[0]?.textContent);
            const k = parseInt(this.cells[1]?.textContent);
            if (h && k && gcd(h, k) === 1) {
                triggerGlobalHarmonic(h, k);
            }
        };
    });
    
    // Interval table in harmonic tab
    document.querySelectorAll('#intervalTable tbody tr').forEach(row => {
        row.style.cursor = 'pointer';
    });
}

// Call after data updates
const origUpdateMainTable = updateMainTable;
updateMainTable = function() {
    origUpdateMainTable();
    setTimeout(setupTableAudioHandlers, 100);
};

const origUpdateGapAnalysis = updateGapAnalysis;
updateGapAnalysis = function() {
    origUpdateGapAnalysis();
    setTimeout(setupTableAudioHandlers, 100);
};

// =============================================
// ENHANCED PLAYBACK CONTROLS IN UI
// =============================================

// Add keyboard shortcuts for playback
document.addEventListener('keydown', function(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch(e.key) {
        case ' ': // Space - toggle playback
            e.preventDefault();
            if (playbackState.isPlaying) {
                stopAllPlayback();
            } else if (selectedTreePoint) {
                playTreePathAudio('forward');
            }
            break;
        case 'ArrowRight': // Play forward
            if (selectedTreePoint) {
                playTreePathAudio('forward');
            }
            break;
        case 'ArrowLeft': // Play backward
            if (selectedTreePoint) {
                playTreePathAudio('backward');
            }
            break;
        case 'ArrowUp': // Play sector forward
            e.preventDefault();
            playSectorSequence('forward');
            break;
        case 'ArrowDown': // Play sector backward
            e.preventDefault();
            playSectorSequence('backward');
            break;
        case 'Escape':
            stopAllPlayback();
            break;
    }
});

// Add visual play buttons to sector info
function addPlayButtonsToSectorModal() {
    const modal = document.getElementById('sectorModalBody');
    if (!modal) return;
    
    const existingBtns = modal.querySelector('.playback-controls');
    if (existingBtns) return;
    
    const controls = document.createElement('div');
    controls.className = 'playback-controls';
    controls.style.cssText = 'margin-top:15px;display:flex;gap:8px;flex-wrap:wrap;';
    controls.innerHTML = `
        <button onclick="playSectorAudio(${document.getElementById('viewSector')?.value || 1}, 'forward')" 
                style="padding:8px 16px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:5px;color:white;cursor:pointer;font-weight:600;">
            ‚ñ∂ Play Forward
        </button>
        <button onclick="playSectorAudio(${document.getElementById('viewSector')?.value || 1}, 'backward')" 
                style="padding:8px 16px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:5px;color:white;cursor:pointer;font-weight:600;">
            ‚óÄ Play Backward
        </button>
        <button onclick="stopAllPlayback()" 
                style="padding:8px 16px;background:#ef4444;border:none;border-radius:5px;color:white;cursor:pointer;">
            ‚ñ† Stop
        </button>
    `;
    modal.appendChild(controls);
}

// Enhance the tree path info with direction buttons
const origUpdateTreePathInfo = updateTreePathInfo;
updateTreePathInfo = function(point) {
    origUpdateTreePathInfo(point);
    
    const info = document.getElementById('treePathInfo');
    if (!info) return;
    
    // Add direction controls if not present
    if (!info.querySelector('.path-playback-controls')) {
        const controls = document.createElement('div');
        controls.className = 'path-playback-controls';
        controls.style.cssText = 'margin-top:12px;padding-top:12px;border-top:1px solid #334155;display:flex;gap:8px;align-items:center;';
        controls.innerHTML = `
            <span style="color:#94a3b8;font-size:11px;">Path Playback:</span>
            <button onclick="playTreePathAudio('forward')" 
                    style="padding:6px 12px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">
                ‚ñ∂ Forward
            </button>
            <button onclick="playTreePathAudio('backward')" 
                    style="padding:6px 12px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">
                ‚óÄ Backward
            </button>
            <button onclick="playChordFromPath()" 
                    style="padding:6px 12px;background:#f59e0b;border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">
                ‚ô´ Chord
            </button>
            <button onclick="stopAllPlayback()" 
                    style="padding:6px 12px;background:#ef4444;border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">
                ‚ñ† Stop
            </button>
            <span style="margin-left:auto;color:#64748b;font-size:10px;">Space=toggle, ‚Üê‚Üí=direction</span>
        `;
        info.appendChild(controls);
    }
};

// Play path as chord (all notes simultaneously)
function playChordFromPath() {
    if (!selectedTreePoint) {
        showPlaybackStatus('Select a point first');
        return;
    }
    
    initAudioContext();
    const fractions = getPathFractions(selectedTreePoint.r, selectedTreePoint.m);
    
    if (!fractions || fractions.length === 0) {
        showPlaybackStatus('No path fractions found');
        return;
    }
    
    // Play all simultaneously with decreasing volume
    fractions.forEach((f, i) => {
        if (f && f.r && f.m && f.m !== 0) {
            const vol = (harmonicSettings.volume || 0.5) * Math.max(0.1, 1 - i * 0.1);
            if (vol > 0.05) {
                playTone(harmonicSettings.baseFreq * f.r / f.m, 1.5, vol * 0.3);
            }
        }
    });
    
    showPlaybackStatus(`Playing chord: ${fractions.length} notes`);
}

// =============================================
// CLICK HANDLERS FOR ALL VISUALIZATIONS
// =============================================

// Enhance main ring click to offer playback
const origMainRingClick = document.getElementById('mainRing')?.onclick;
document.getElementById('mainRing')?.addEventListener('dblclick', function(e) {
    // Double-click plays the sector
    const sector = +document.getElementById('viewSector').value;
    playSectorAudio(sector, 'forward');
});

// Add click-to-play for residue items
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('residue-item')) {
        const text = e.target.textContent.trim();
        const match = text.match(/^(\d+)\/(\d+)$/);
        if (match) {
            const r = parseInt(match[1]);
            const m = parseInt(match[2]);
            triggerGlobalHarmonic(r, m);
        }
    }
});

// Gap tab - click gaps to hear interval
document.getElementById('gapDistChart')?.addEventListener('click', function() {
    if (state.gaps.length > 0) {
        playGapsAsIntervals('forward');
    }
});

// Franel tab - click to play Farey sequence
document.getElementById('franelDeviationChart')?.addEventListener('click', function() {
    playFareySequence('forward');
});

// =============================================
// VISUAL FEEDBACK DURING PLAYBACK
// =============================================

// Pulse the harmonic toolbar during playback
function pulseToolbar() {
    const toolbar = document.getElementById('harmonicToolbar');
    if (toolbar && playbackState.isPlaying) {
        toolbar.style.boxShadow = '0 0 20px rgba(34, 197, 94, 0.5)';
        setTimeout(() => {
            toolbar.style.boxShadow = 'none';
        }, 100);
    }
}

// =============================================
// PRESETS SYSTEM
// =============================================

const presets = {
    quick: { N: 50, sectorMin: 1, useBound: true, colorMode: 'sector', showAll: true },
    standard: { N: 200, sectorMin: 1, useBound: true, colorMode: 'sector', showAll: true },
    detailed: { N: 500, sectorMin: 1, useBound: true, colorMode: 'prime', showAll: true },
    deep: { N: 1000, sectorMin: 1, useBound: true, colorMode: 'prime', showAll: false },
    primes: { N: 300, sectorMin: 1, useBound: true, colorMode: 'prime', showAll: true },
    musical: { N: 12, sectorMin: 1, sectorMax: 12, colorMode: 'sector', showAll: true, baseFreq: 440 }
};

function applyPreset(name) {
    const preset = presets[name];
    if (!preset) return;
    
    document.getElementById('nMax').value = preset.N;
    document.getElementById('nMin').value = 1;
    document.getElementById('sectorMin').value = preset.sectorMin;
    
    if (preset.useBound) {
        document.getElementById('useSectorBound').checked = true;
        updateSectorBound();
    } else if (preset.sectorMax) {
        document.getElementById('useSectorBound').checked = false;
        document.getElementById('sectorMax').value = preset.sectorMax;
    }
    
    document.getElementById('colorMode').value = preset.colorMode;
    document.getElementById('showAllSectors').checked = preset.showAll;
    
    if (preset.baseFreq) {
        document.getElementById('baseFreq').value = preset.baseFreq;
        document.getElementById('baseFreqSlider').value = preset.baseFreq;
        updateBaseFreq();
    }
    
    showPlaybackStatus(`Applied preset: ${name}`);
    runComputation();
}

// =============================================
// RING ANIMATION SYSTEM
// =============================================

let ringAnimating = false;
let ringAnimId = null;
let ringAnimN = 2;

function toggleRingAnimation() {
    if (ringAnimating) {
        stopRingAnimation();
    } else {
        startRingAnimation();
    }
}

function startRingAnimation() {
    ringAnimating = true;
    ringAnimN = 2;
    
    const btn = document.getElementById('ringAnimateBtn');
    if (btn) {
        btn.textContent = '‚ñ† Stop Animation';
        btn.style.background = '#ef4444';
    }
    
    // Reset state for animation
    state.sectors = [];
    state.residuesBySector = {};
    state.allResidues = [];
    
    animateRingStep();
}

function stopRingAnimation() {
    ringAnimating = false;
    if (ringAnimId) {
        clearTimeout(ringAnimId);
        ringAnimId = null;
    }
    
    const btn = document.getElementById('ringAnimateBtn');
    if (btn) {
        btn.textContent = '‚ñ∂ Animate N Growth';
        btn.style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
    }
}

function animateRingStep() {
    if (!ringAnimating) return;
    
    const maxN = +document.getElementById('nMax').value || 200;
    const speed = +document.getElementById('ringAnimSpeed').value || 150;
    const withSound = document.getElementById('animWithSound')?.checked;
    
    if (ringAnimN > maxN) {
        stopRingAnimation();
        showPlaybackStatus('Animation complete');
        return;
    }
    
    // Add fractions for current N
    const m = ringAnimN;
    for (let r = 1; r < m; r++) {
        if (gcd(r, m) === 1) {
            const s = getSector(r, m);
            const res = { r, m, sector: s, isPrime: isPrime(m), value: r/m };
            state.allResidues.push(res);
            
            const sMin = +document.getElementById('sectorMin').value || 1;
            const sMax = +document.getElementById('sectorMax').value || 10;
            if (s && s >= sMin && s <= sMax) {
                if (!state.residuesBySector[s]) state.residuesBySector[s] = [];
                state.residuesBySector[s].push(res);
            }
        }
    }
    
    // Update sectors
    const sMin = +document.getElementById('sectorMin').value || 1;
    const sMax = +document.getElementById('sectorMax').value || 10;
    state.sectors = [];
    for (let n = sMin; n <= sMax; n++) {
        const res = state.residuesBySector[n] || [];
        const pred = formula(n, ringAnimN);
        state.sectors.push({
            n, exact: res.length, predicted: pred,
            error: res.length - pred,
            relError: res.length > 0 ? ((res.length - pred) / res.length) * 100 : 0,
            primeCount: res.filter(x => x.isPrime).length
        });
    }
    
    // Redraw
    drawMainRing();
    
    // Update status
    const status = document.getElementById('ringAnimStatus');
    if (status) status.textContent = `N=${ringAnimN} | ${state.allResidues.length} fractions`;
    
    // Play sound for new fractions
    if (withSound && state.allResidues.length > 0) {
        const lastFrac = state.allResidues[state.allResidues.length - 1];
        if (lastFrac && ringAnimN % 3 === 0) { // Play every 3rd N to not overwhelm
            initAudioContext();
            playFraction(lastFrac.r, lastFrac.m, 0.1);
        }
    }
    
    ringAnimN++;
    ringAnimId = setTimeout(animateRingStep, speed);
}

function stepRingAnimation(delta) {
    const currentN = +document.getElementById('nMax').value || 200;
    const newN = Math.max(2, Math.min(2000, currentN + delta));
    document.getElementById('nMax').value = newN;
    runComputation();
}

// =============================================
// PLAY SECTOR PRIMES
// =============================================

function playSectorPrimes(sectorNum) {
    const residues = state.residuesBySector[sectorNum] || [];
    const primes = residues.filter(r => r.isPrime);
    
    if (primes.length === 0) {
        showPlaybackStatus('No prime denominators in sector ' + sectorNum);
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    const sorted = [...primes].sort((a, b) => a.r/a.m - b.r/b.m);
    
    playbackState.queue = sorted;
    playbackState.direction = 'forward';
    playbackState.mode = 'sector-primes';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing Sector ${sectorNum} primes (${primes.length} fractions)`);
    startPlaybackLoop();
}

// =============================================
// PLAY ERROR/COUNT BY SECTOR
// =============================================

function resetCountChartZoom() {
    if (state.charts.mainCount) {
        state.charts.mainCount.resetZoom();
    }
}

function zoomCountChart(direction) {
    if (state.charts.mainCount) {
        if (direction === 'in') {
            state.charts.mainCount.zoom(1.2);
        } else {
            state.charts.mainCount.zoom(0.8);
        }
    }
}

function resetErrorChartZoom() {
    if (state.charts.mainError) {
        state.charts.mainError.resetZoom();
    }
}

function zoomErrorChart(direction) {
    if (state.charts.mainError) {
        if (direction === 'in') {
            state.charts.mainError.zoom(1.2);
        } else {
            state.charts.mainError.zoom(0.8);
        }
    }
}

function playErrorBySector(mode = 'error') {
    if (state.sectors.length === 0) {
        showPlaybackStatus('No sector data - run computation first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Map sector data to frequencies based on error or count
    const data = state.sectors.map(s => {
        if (mode === 'error') {
            // Map error to frequency: larger error = higher pitch
            const err = Math.abs(s.relError || 0);
            // Scale error (0-100%) to frequency range (200-800 Hz)
            const freq = 200 + (err / 100) * 600;
            return { n: s.n, value: err, freq: Math.min(1200, Math.max(100, freq)) };
        } else {
            // Map count to frequency: more fractions = higher pitch  
            const count = s.exact || s.predicted || 0;
            const maxCount = Math.max(...state.sectors.map(x => x.exact || x.predicted || 1));
            const freq = 150 + (count / maxCount) * 700;
            return { n: s.n, value: count, freq: Math.min(1200, Math.max(100, freq)) };
        }
    });
    
    playbackState.isPlaying = true;
    let idx = 0;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    
    function playNext() {
        if (!playbackState.isPlaying || idx >= data.length) {
            stopAllPlayback();
            showPlaybackStatus(`${mode === 'error' ? 'Error' : 'Count'} sonification complete`);
            return;
        }
        
        const d = data[idx];
        const vol = (harmonicSettings.volume || 0.5) * 0.5;
        
        playTone(d.freq, speed / 1000 * 0.8, vol);
        
        // Update display
        const label = mode === 'error' ? `Err: ${d.value.toFixed(1)}%` : `Count: ${Math.round(d.value)}`;
        showPlaybackStatus(`Sector ${d.n}: ${label} ‚Üí ${d.freq.toFixed(0)} Hz`);
        
        // Highlight sector on ring if visible
        document.getElementById('viewSector').value = d.n;
        drawMainRing();
        
        idx++;
        playbackState.intervalId = setTimeout(playNext, speed);
    }
    
    showPlaybackStatus(`Playing ${mode === 'error' ? 'relative error' : 'counts'} across ${data.length} sectors`);
    playNext();
}

// =============================================
// ERROR CHART SELECTION AND CLICK-TO-PLAY
// =============================================

let errorChartSelection = { start: null, end: null, isDragging: false };

function updateErrorModeHint() {
    const mode = document.getElementById('errorPlaybackMode')?.value || 'error';
    const hint = document.getElementById('errorModeHint');
    if (!hint) return;
    
    switch(mode) {
        case 'error':
            hint.textContent = 'Higher error ‚Üí higher pitch (200-800 Hz)';
            break;
        case 'fractions':
            hint.textContent = 'Plays ALL fractions in each sector sequentially';
            break;
        case 'representative':
            hint.textContent = 'Plays mediant (middle) fraction of each sector';
            break;
    }
}

function setupErrorChartSelection() {
    const canvas = document.getElementById('mainErrorChart');
    if (!canvas || !state.charts.mainError) return;
    
    // Setup mode hint updater
    const modeSelect = document.getElementById('errorPlaybackMode');
    if (modeSelect) {
        modeSelect.addEventListener('change', updateErrorModeHint);
    }
    
    canvas.addEventListener('mousedown', (e) => {
        const chart = state.charts.mainError;
        const elements = chart.getElementsAtEventForMode(e, 'index', { intersect: false }, false);
        if (elements.length > 0) {
            errorChartSelection.start = elements[0].index;
            errorChartSelection.end = elements[0].index;
            errorChartSelection.isDragging = true;
            updateErrorChartHighlight();
        }
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (!errorChartSelection.isDragging) return;
        const chart = state.charts.mainError;
        const elements = chart.getElementsAtEventForMode(e, 'index', { intersect: false }, false);
        if (elements.length > 0) {
            errorChartSelection.end = elements[0].index;
            updateErrorChartHighlight();
        }
    });
    
    canvas.addEventListener('mouseup', () => {
        if (errorChartSelection.isDragging) {
            errorChartSelection.isDragging = false;
            // Ensure start <= end
            if (errorChartSelection.start > errorChartSelection.end) {
                [errorChartSelection.start, errorChartSelection.end] = [errorChartSelection.end, errorChartSelection.start];
            }
            updateErrorChartHighlight();
            
            // If single bar clicked (not dragged), highlight table row
            if (errorChartSelection.start === errorChartSelection.end) {
                const idx = errorChartSelection.start;
                const s = state.sectors[idx];
                if (s) {
                    highlightTableRow(s.n);
                }
            }
        }
    });
    
    canvas.addEventListener('mouseleave', () => {
        errorChartSelection.isDragging = false;
    });
}

function updateErrorChartHighlight() {
    if (!state.charts.mainError) return;
    
    const { start, end } = errorChartSelection;
    const hasSelection = start !== null && end !== null;
    
    // Update bar colors
    state.charts.mainError.data.datasets[0].backgroundColor = state.sectors.map((s, i) => {
        const inRange = hasSelection && i >= Math.min(start, end) && i <= Math.max(start, end);
        return inRange ? 'rgba(34,197,94,0.9)' : 'rgba(245,158,11,0.7)';
    });
    state.charts.mainError.update('none');
    
    // Show/hide play selection button and info
    const btn = document.getElementById('playSelectedRangeBtn');
    const info = document.getElementById('errorSelectionInfo');
    if (hasSelection && Math.abs(end - start) >= 0) {
        const minIdx = Math.min(start, end);
        const maxIdx = Math.max(start, end);
        const startSector = state.sectors[minIdx]?.n;
        const endSector = state.sectors[maxIdx]?.n;
        btn.style.display = 'inline-block';
        info.textContent = `Selected: Sectors ${startSector}-${endSector} (${maxIdx - minIdx + 1} bars)`;
    } else {
        btn.style.display = 'none';
        info.textContent = '';
    }
}

function clearErrorSelection() {
    errorChartSelection = { start: null, end: null, isDragging: false };
    updateErrorChartHighlight();
    const info = document.getElementById('errorSelectionInfo');
    if (info) info.textContent = '';
}

// =============================================
// HIGHLIGHT FUNCTIONS FOR PLAYBACK VISUALIZATION
// =============================================

let currentHighlightedRow = null;
let currentHighlightedBarIdx = null;
let blinkInterval = null;

function highlightTableRow(sectorN) {
    // Clear previous highlight
    if (currentHighlightedRow) {
        currentHighlightedRow.style.background = '';
        currentHighlightedRow.style.outline = '';
    }
    
    const row = document.querySelector(`#mainTable tbody tr[data-sector="${sectorN}"]`);
    if (row) {
        row.style.background = 'rgba(99, 102, 241, 0.3)';
        row.style.outline = '2px solid #6366f1';
        currentHighlightedRow = row;
        
        // Scroll row into view
        row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

function clearTableRowHighlight() {
    if (currentHighlightedRow) {
        currentHighlightedRow.style.background = '';
        currentHighlightedRow.style.outline = '';
        currentHighlightedRow = null;
    }
}

function highlightChartBar(idx, blink = false) {
    if (!state.charts.mainError) return;
    
    // Stop any existing blink
    if (blinkInterval) {
        clearInterval(blinkInterval);
        blinkInterval = null;
    }
    
    currentHighlightedBarIdx = idx;
    
    // Reset all bars to default
    const colors = state.sectors.map((s, i) => {
        if (i === idx) {
            return 'rgba(34, 197, 94, 0.9)'; // Highlighted green
        }
        return 'rgba(245, 158, 11, 0.7)'; // Default orange
    });
    
    state.charts.mainError.data.datasets[0].backgroundColor = colors;
    state.charts.mainError.data.datasets[0].borderColor = state.sectors.map((s, i) => 
        i === idx ? '#22c55e' : '#f59e0b'
    );
    state.charts.mainError.data.datasets[0].borderWidth = state.sectors.map((s, i) => 
        i === idx ? 3 : 1
    );
    state.charts.mainError.update('none');
    
    if (blink) {
        let isOn = true;
        blinkInterval = setInterval(() => {
            isOn = !isOn;
            state.charts.mainError.data.datasets[0].backgroundColor[idx] = 
                isOn ? 'rgba(34, 197, 94, 0.9)' : 'rgba(34, 197, 94, 0.3)';
            state.charts.mainError.update('none');
        }, 200);
    }
}

function clearChartBarHighlight() {
    if (blinkInterval) {
        clearInterval(blinkInterval);
        blinkInterval = null;
    }
    
    if (!state.charts.mainError) return;
    
    currentHighlightedBarIdx = null;
    
    // Reset all bars to default
    state.charts.mainError.data.datasets[0].backgroundColor = state.sectors.map(() => 'rgba(245, 158, 11, 0.7)');
    state.charts.mainError.data.datasets[0].borderColor = state.sectors.map(() => '#f59e0b');
    state.charts.mainError.data.datasets[0].borderWidth = state.sectors.map(() => 1);
    state.charts.mainError.update('none');
}

function highlightSectorDuringPlayback(sectorN, sectorIdx, blink = false) {
    highlightTableRow(sectorN);
    highlightChartBar(sectorIdx, blink);
    
    // Also update ring view
    document.getElementById('viewSector').value = sectorN;
    drawMainRing();
}

function clearAllPlaybackHighlights() {
    clearTableRowHighlight();
    clearChartBarHighlight();
}

function playErrorChartBar(idx) {
    if (!state.sectors[idx]) return;
    
    initAudioContext();
    
    const s = state.sectors[idx];
    const err = Math.abs(s.relError || 0);
    const freq = 200 + (err / 100) * 600;
    const clampedFreq = Math.min(1200, Math.max(100, freq));
    
    playTone(clampedFreq, 0.3, (harmonicSettings.volume || 0.5) * 0.6);
    showPlaybackStatus(`Sector ${s.n}: Error ${err.toFixed(1)}% ‚Üí ${clampedFreq.toFixed(0)} Hz`);
    
    // Highlight table row and chart bar
    highlightSectorDuringPlayback(s.n, idx, false);
}

function playSelectedErrorRange() {
    const { start, end } = errorChartSelection;
    if (start === null || end === null) {
        showPlaybackStatus('No selection - drag across bars to select range');
        return;
    }
    
    const mode = document.getElementById('errorPlaybackMode')?.value || 'error';
    
    initAudioContext();
    stopAllPlayback();
    
    const minIdx = Math.min(start, end);
    const maxIdx = Math.max(start, end);
    
    if (mode === 'error') {
        // Original behavior: play error magnitude as pitch
        playErrorMagnitudeMode(minIdx, maxIdx);
    } else if (mode === 'fractions') {
        // Play all fractions in each selected sector
        playAllFractionsMode(minIdx, maxIdx);
    } else if (mode === 'representative') {
        // Play representative fraction (mediant) of each sector
        playRepresentativeMode(minIdx, maxIdx);
    }
}

function playErrorMagnitudeMode(minIdx, maxIdx) {
    const data = [];
    for (let i = minIdx; i <= maxIdx; i++) {
        const s = state.sectors[i];
        if (s) {
            const err = Math.abs(s.relError || 0);
            const freq = 200 + (err / 100) * 600;
            data.push({ n: s.n, value: err, freq: Math.min(1200, Math.max(100, freq)), idx: i });
        }
    }
    
    playbackState.isPlaying = true;
    let idx = 0;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    
    function playNext() {
        if (!playbackState.isPlaying || idx >= data.length) {
            stopAllPlayback();
            clearAllPlaybackHighlights();
            showPlaybackStatus('Selection playback complete');
            return;
        }
        
        const d = data[idx];
        playTone(d.freq, speed / 1000 * 0.8, (harmonicSettings.volume || 0.5) * 0.5);
        showPlaybackStatus(`Sector ${d.n}: Error ${d.value.toFixed(1)}% ‚Üí ${d.freq.toFixed(0)} Hz (${idx + 1}/${data.length})`);
        
        // Highlight current sector (bar + table row)
        highlightSectorDuringPlayback(d.n, d.idx, false);
        
        idx++;
        playbackState.intervalId = setTimeout(playNext, speed);
    }
    
    showPlaybackStatus(`Playing error magnitudes: Sectors ${state.sectors[minIdx]?.n}-${state.sectors[maxIdx]?.n}`);
    playNext();
}

function playAllFractionsMode(minIdx, maxIdx) {
    // Collect ALL fractions from selected sectors
    const allFractions = [];
    
    for (let i = minIdx; i <= maxIdx; i++) {
        const s = state.sectors[i];
        if (!s) continue;
        
        const residues = state.residuesBySector[s.n] || [];
        const sorted = [...residues].sort((a, b) => a.value - b.value);
        
        sorted.forEach(frac => {
            allFractions.push({
                r: frac.r,
                m: frac.m,
                value: frac.value,
                sector: s.n,
                sectorIdx: i
            });
        });
    }
    
    if (allFractions.length === 0) {
        showPlaybackStatus('No fractions found in selected sectors');
        return;
    }
    
    playbackState.isPlaying = true;
    let idx = 0;
    let currentSectorIdx = null;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    const baseFreq = 220;
    
    function playNext() {
        if (!playbackState.isPlaying || idx >= allFractions.length) {
            stopAllPlayback();
            clearAllPlaybackHighlights();
            showPlaybackStatus('Selection playback complete');
            return;
        }
        
        const f = allFractions[idx];
        
        // Check if we moved to a new sector - update blinking highlight
        if (currentSectorIdx !== f.sectorIdx) {
            currentSectorIdx = f.sectorIdx;
            // Start blinking for this sector
            highlightSectorDuringPlayback(f.sector, f.sectorIdx, true);
        }
        
        const freq = baseFreq * (f.m / f.r); // Harmonic frequency
        const clampedFreq = Math.min(2000, Math.max(80, freq));
        
        playTone(clampedFreq, speed / 1000 * 0.8, (harmonicSettings.volume || 0.5) * 0.5);
        showPlaybackStatus(`S${f.sector}: ${f.r}/${f.m} ‚Üí ${clampedFreq.toFixed(0)} Hz (${idx + 1}/${allFractions.length})`);
        
        idx++;
        playbackState.intervalId = setTimeout(playNext, speed);
    }
    
    showPlaybackStatus(`Playing all fractions: ${allFractions.length} notes from sectors ${state.sectors[minIdx]?.n}-${state.sectors[maxIdx]?.n}`);
    playNext();
}

function playRepresentativeMode(minIdx, maxIdx) {
    // Play mediant (middle fraction) of each sector
    const data = [];
    
    for (let i = minIdx; i <= maxIdx; i++) {
        const s = state.sectors[i];
        if (!s) continue;
        
        const residues = state.residuesBySector[s.n] || [];
        if (residues.length === 0) continue;
        
        const sorted = [...residues].sort((a, b) => a.value - b.value);
        // Get mediant (middle fraction)
        const mediantIdx = Math.floor(sorted.length / 2);
        const mediant = sorted[mediantIdx];
        
        data.push({
            r: mediant.r,
            m: mediant.m,
            value: mediant.value,
            sector: s.n,
            sectorIdx: i,
            total: sorted.length
        });
    }
    
    if (data.length === 0) {
        showPlaybackStatus('No fractions found in selected sectors');
        return;
    }
    
    playbackState.isPlaying = true;
    let idx = 0;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    const baseFreq = 220;
    
    function playNext() {
        if (!playbackState.isPlaying || idx >= data.length) {
            stopAllPlayback();
            clearAllPlaybackHighlights();
            showPlaybackStatus('Selection playback complete');
            return;
        }
        
        const f = data[idx];
        const freq = baseFreq * (f.m / f.r);
        const clampedFreq = Math.min(2000, Math.max(80, freq));
        
        playTone(clampedFreq, speed / 1000 * 0.8, (harmonicSettings.volume || 0.5) * 0.5);
        showPlaybackStatus(`S${f.sector}: mediant ${f.r}/${f.m} (of ${f.total}) ‚Üí ${clampedFreq.toFixed(0)} Hz (${idx + 1}/${data.length})`);
        
        // Highlight current sector (bar + table row)
        highlightSectorDuringPlayback(f.sector, f.sectorIdx, false);
        
        idx++;
        playbackState.intervalId = setTimeout(playNext, speed);
    }
    
    showPlaybackStatus(`Playing representative fractions: Sectors ${state.sectors[minIdx]?.n}-${state.sectors[maxIdx]?.n}`);
    playNext();
}

// =============================================
// PLAY ALL SECTORS SEQUENTIALLY
// =============================================

function playAllSectorsSequentially() {
    if (state.sectors.length === 0) {
        showPlaybackStatus('No sector data - run computation first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Collect ALL fractions from all sectors in order (by sector, then by value within sector)
    const allFractions = [];
    
    // Sort sectors by n (ascending)
    const sortedSectors = [...state.sectors].sort((a, b) => a.n - b.n);
    
    sortedSectors.forEach(s => {
        const residues = state.residuesBySector[s.n] || [];
        // Sort fractions within sector by value (ascending)
        const sorted = [...residues].sort((a, b) => a.r/a.m - b.r/b.m);
        sorted.forEach(f => {
            allFractions.push({ r: f.r, m: f.m, sector: s.n, isPrime: f.isPrime });
        });
    });
    
    if (allFractions.length === 0) {
        showPlaybackStatus('No fractions to play');
        return;
    }
    
    playbackState.queue = allFractions;
    playbackState.direction = 'forward';
    playbackState.mode = 'all-sectors';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    const btn = document.getElementById('playAllSectorsBtn');
    if (btn) {
        btn.textContent = '‚ñ† Stop';
        btn.style.background = '#ef4444';
        btn.onclick = stopAllPlayback;
    }
    
    showPlaybackStatus(`Playing all ${allFractions.length} fractions across ${sortedSectors.length} sectors`);
    startAllSectorsPlaybackLoop();
}

function startAllSectorsPlaybackLoop() {
    const speed = Math.max(50, +(document.getElementById('playbackSpeed')?.value || 250) / 2); // Faster for continuous play
    
    if (playbackState.intervalId) {
        clearInterval(playbackState.intervalId);
    }
    
    let lastSector = null;
    
    playbackState.intervalId = setInterval(() => {
        if (!playbackState.isPlaying) {
            resetAllSectorsBtn();
            return;
        }
        
        if (playbackState.currentIndex >= playbackState.queue.length) {
            stopAllPlayback();
            showPlaybackStatus(`All sectors playback complete (${playbackState.queue.length} fractions)`);
            resetAllSectorsBtn();
            return;
        }
        
        const f = playbackState.queue[playbackState.currentIndex];
        
        if (f && typeof f.r === 'number' && typeof f.m === 'number' && f.m !== 0) {
            const duration = speed / 1000 * 0.8;
            playFraction(f.r, f.m, duration);
            updateSolverLive(f.r, f.m);
            
            // Update sector view when sector changes
            if (f.sector !== lastSector) {
                document.getElementById('viewSector').value = f.sector;
                drawMainRing();
                lastSector = f.sector;
            }
            
            showPlaybackStatus(`S${f.sector}: ${f.r}/${f.m} ${f.isPrime ? '(P)' : ''} ‚Äî ${playbackState.currentIndex + 1}/${playbackState.queue.length}`);
        }
        
        playbackState.currentIndex++;
    }, speed);
}

function resetAllSectorsBtn() {
    const btn = document.getElementById('playAllSectorsBtn');
    if (btn) {
        btn.textContent = '‚ñ∂ Play All Sectors';
        btn.style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
        btn.onclick = playAllSectorsSequentially;
    }
}

// =============================================
// SECTOR SWEEP ANIMATION
// =============================================

let sectorSweeping = false;
let sectorSweepId = null;
let currentSweepSector = 1;

function toggleSectorSweep() {
    if (sectorSweeping) {
        stopSectorSweep();
    } else {
        startSectorSweep();
    }
}

function startSectorSweep() {
    sectorSweeping = true;
    currentSweepSector = +document.getElementById('sectorMin').value || 1;
    
    const btn = document.getElementById('sectorSweepBtn');
    if (btn) {
        btn.textContent = '‚ñ† Stop Sweep';
        btn.style.background = '#ef4444';
    }
    
    sweepSectorStep();
}

function stopSectorSweep() {
    sectorSweeping = false;
    if (sectorSweepId) {
        clearTimeout(sectorSweepId);
        sectorSweepId = null;
    }
    stopAllPlayback();
    
    const btn = document.getElementById('sectorSweepBtn');
    if (btn) {
        btn.textContent = '‚ñ∂ Sweep Sectors';
        btn.style.background = 'linear-gradient(135deg,#8b5cf6,#6366f1)';
    }
}

function sweepSectorStep() {
    if (!sectorSweeping) return;
    
    const maxSector = +document.getElementById('sectorMax').value || 10;
    const speed = +document.getElementById('ringAnimSpeed').value || 150;
    const withSound = document.getElementById('animWithSound')?.checked;
    
    if (currentSweepSector > maxSector) {
        stopSectorSweep();
        showPlaybackStatus('Sector sweep complete');
        return;
    }
    
    // Update view to current sector
    document.getElementById('viewSector').value = currentSweepSector;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
    
    // Update status
    const status = document.getElementById('ringAnimStatus');
    const residues = state.residuesBySector[currentSweepSector] || [];
    if (status) status.textContent = `Sector ${currentSweepSector} | ${residues.length} fractions`;
    
    // Play a representative fraction from this sector
    if (withSound && residues.length > 0) {
        initAudioContext();
        // Play the mediant (middle) fraction of the sector
        const midIdx = Math.floor(residues.length / 2);
        const midFrac = residues.sort((a,b) => a.r/a.m - b.r/b.m)[midIdx];
        if (midFrac) {
            playFraction(midFrac.r, midFrac.m, 0.3);
        }
    }
    
    currentSweepSector++;
    sectorSweepId = setTimeout(sweepSectorStep, speed * 3);
}

function stepSectorAnimation(delta) {
    const currentSector = +document.getElementById('viewSector').value || 1;
    const minSector = +document.getElementById('sectorMin').value || 1;
    const maxSector = +document.getElementById('sectorMax').value || 10;
    const newSector = Math.max(minSector, Math.min(maxSector, currentSector + delta));
    
    document.getElementById('viewSector').value = newSector;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
    
    // Play a sound for feedback
    const withSound = document.getElementById('animWithSound')?.checked;
    const residues = state.residuesBySector[newSector] || [];
    if (withSound && residues.length > 0) {
        initAudioContext();
        const midIdx = Math.floor(residues.length / 2);
        const midFrac = residues.sort((a,b) => a.r/a.m - b.r/b.m)[midIdx];
        if (midFrac) {
            playFraction(midFrac.r, midFrac.m, 0.2);
        }
    }
    
    const status = document.getElementById('ringAnimStatus');
    if (status) status.textContent = `Sector ${newSector} | ${residues.length} fractions`;
}

// =============================================
// RANDOM INTERVAL PLAYBACK
// =============================================

const musicalIntervals = [
    { r: 1, m: 1, name: 'Unison' },
    { r: 16, m: 15, name: 'm2' },
    { r: 9, m: 8, name: 'M2' },
    { r: 6, m: 5, name: 'm3' },
    { r: 5, m: 4, name: 'M3' },
    { r: 4, m: 3, name: 'P4' },
    { r: 45, m: 32, name: 'TT' },
    { r: 3, m: 2, name: 'P5' },
    { r: 8, m: 5, name: 'm6' },
    { r: 5, m: 3, name: 'M6' },
    { r: 9, m: 5, name: 'm7' },
    { r: 15, m: 8, name: 'M7' },
    { r: 2, m: 1, name: 'Oct' },
    { r: 5, m: 2, name: '10th' },
    { r: 3, m: 1, name: '12th' },
    { r: 4, m: 1, name: '2Oct' }
];

let randomIntervalPlaying = false;
let randomIntervalId = null;

function toggleRandomIntervals() {
    if (randomIntervalPlaying) {
        stopRandomIntervals();
    } else {
        startRandomIntervals();
    }
}

function startRandomIntervals() {
    randomIntervalPlaying = true;
    initAudioContext();
    
    const btn = document.getElementById('randomIntervalBtn');
    if (btn) {
        btn.textContent = '‚ñ† Stop';
        btn.style.background = '#ef4444';
    }
    
    playNextRandomInterval();
}

function stopRandomIntervals() {
    randomIntervalPlaying = false;
    if (randomIntervalId) {
        clearTimeout(randomIntervalId);
        randomIntervalId = null;
    }
    stopAudio();
    
    const btn = document.getElementById('randomIntervalBtn');
    if (btn) {
        btn.textContent = 'üé≤ Random';
        btn.style.background = 'linear-gradient(135deg,#f59e0b,#d97706)';
    }
}

function playNextRandomInterval() {
    if (!randomIntervalPlaying) return;
    
    // Shuffle all intervals and play them one by one
    if (!window.randomIntervalQueue || window.randomIntervalQueue.length === 0) {
        // Reshuffle when queue is empty
        window.randomIntervalQueue = [...musicalIntervals].sort(() => Math.random() - 0.5);
    }
    
    // Get next interval from queue
    const interval = window.randomIntervalQueue.shift();
    
    // Random duration between 200-500ms
    const duration = 200 + Math.random() * 300;
    
    // Play the interval
    setHarmonicInterval(interval.r, interval.m);
    playFraction(interval.r, interval.m, duration / 1000);
    
    // Show which interval is playing and how many left in cycle
    const remaining = window.randomIntervalQueue.length;
    showPlaybackStatus(`üé≤ ${interval.name} (${interval.r}:${interval.m}) ‚Äî ${remaining} left in cycle`);
    
    // Schedule next
    randomIntervalId = setTimeout(playNextRandomInterval, duration + 50);
}

// =============================================
// SOLVER MODULE - Target Ratio Finder
// =============================================

let solverCurrentMatch = null;

function solverSearch(inputVal) {
    // If no value passed, read from input
    if (inputVal === undefined || inputVal === null || inputVal === '') {
        inputVal = document.getElementById('solverInput').value;
    }
    const target = parseFloat(inputVal);
    if (isNaN(target) || target <= 0 || target >= 1) {
        document.getElementById('solverResults').style.display = 'none';
        document.getElementById('solverMatchPreview').textContent = '';
        return;
    }
    
    const tolerance = parseFloat(document.getElementById('solverTolerance').value);
    const maxDenom = parseInt(document.getElementById('solverMaxDenom').value);
    
    // Find best rational approximation using continued fractions
    const best = findBestRationalApprox(target, maxDenom);
    
    // Also find alternatives within tolerance
    const alternatives = findAlternativesWithinTolerance(target, tolerance, maxDenom, 25);
    
    if (best) {
        solverCurrentMatch = best;
        displaySolverResults(best, target, alternatives);
    }
}

function findBestRationalApprox(x, maxDenom) {
    // Continued fraction expansion for best rational approximation
    const cf = getContinuedFraction(x, 20);
    let bestR = 0, bestM = 1, bestErr = Math.abs(x);
    
    // Evaluate convergents
    let h0 = 0, h1 = 1, k0 = 1, k1 = 0;
    for (let i = 0; i < cf.length && k1 <= maxDenom; i++) {
        const a = cf[i];
        const h2 = a * h1 + h0;
        const k2 = a * k1 + k0;
        
        if (k2 > maxDenom) break;
        
        const err = Math.abs(x - h2/k2);
        if (err < bestErr) {
            bestErr = err;
            bestR = h2;
            bestM = k2;
        }
        
        h0 = h1; h1 = h2;
        k0 = k1; k1 = k2;
    }
    
    // Also check semiconvergents for potentially better low-denom matches
    for (let m = 1; m <= Math.min(maxDenom, 200); m++) {
        const r = Math.round(x * m);
        if (r > 0 && r < m && gcd(r, m) === 1) {
            const err = Math.abs(x - r/m);
            if (err < bestErr) {
                bestErr = err;
                bestR = r;
                bestM = m;
            }
        }
    }
    
    if (bestM === 0) return null;
    
    return {
        r: bestR,
        m: bestM,
        value: bestR / bestM,
        error: bestErr,
        sector: getSector(bestR, bestM),
        cf: getContinuedFraction(bestR / bestM, 10),
        isPrime: isPrime(bestM)
    };
}

function getContinuedFraction(x, maxTerms) {
    const cf = [];
    let val = x;
    for (let i = 0; i < maxTerms && val !== 0; i++) {
        const a = Math.floor(val);
        cf.push(a);
        val = val - a;
        if (val < 1e-10) break;
        val = 1 / val;
        if (val > 1e10) break;
    }
    return cf;
}

function findAlternativesWithinTolerance(target, tolerance, maxDenom, maxResults) {
    const alternatives = [];
    
    for (let m = 2; m <= Math.min(maxDenom, 500); m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) !== 1) continue;
            const val = r / m;
            const err = Math.abs(val - target);
            if (err <= tolerance) {
                alternatives.push({
                    r, m, value: val, error: err,
                    sector: getSector(r, m),
                    isPrime: isPrime(m)
                });
            }
        }
    }
    
    alternatives.sort((a, b) => a.error - b.error);
    return alternatives.slice(0, maxResults);
}

function displaySolverResults(best, target, alternatives) {
    document.getElementById('solverResults').style.display = 'block';
    document.getElementById('solverBestFrac').textContent = best.r + '/' + best.m;
    document.getElementById('solverBestDecimal').textContent = best.value.toFixed(8);
    document.getElementById('solverError').textContent = (best.error < 0.0001 ? best.error.toExponential(2) : best.error.toFixed(6));
    document.getElementById('solverSector').textContent = 'S' + best.sector + ' (1/' + (best.sector+1) + ', 1/' + best.sector + ']';
    document.getElementById('solverCF').textContent = '[' + best.cf.join('; ') + ']';
    document.getElementById('solverGear').textContent = best.m + ':' + best.r + ' (teeth ratio)';
    
    // Category (PP/PC/CP/CC)
    const isPrimeR = isPrime(best.r);
    const isPrimeM = best.isPrime;
    const category = (isPrimeR && isPrimeM) ? 'PP' : (isPrimeR && !isPrimeM) ? 'PC' : (!isPrimeR && isPrimeM) ? 'CP' : 'CC';
    const catColors = { 'PP': '#22c55e', 'PC': '#f59e0b', 'CP': '#6366f1', 'CC': '#94a3b8' };
    const catLabels = { 'PP': 'Both Prime', 'PC': 'Prime/Comp', 'CP': 'Comp/Prime', 'CC': 'Both Comp' };
    document.getElementById('solverCategory').textContent = category + ' (' + catLabels[category] + ')';
    document.getElementById('solverCategory').style.color = catColors[category];
    
    // Denom Type
    document.getElementById('solverDenomType').textContent = best.isPrime ? 'Prime' : 'Composite';
    document.getElementById('solverDenomType').style.color = best.isPrime ? '#f59e0b' : '#6366f1';
    
    // Path (L/R sequence from CF)
    const path = cfPath(best.cf);
    document.getElementById('solverPath').textContent = path;
    
    // Update preview in collapsed header
    document.getElementById('solverMatchPreview').textContent = best.r + '/' + best.m + ' = ' + best.value.toFixed(6);
    
    // Build alternatives table
    if (alternatives.length > 1) {
        let html = '<div style="color:#6ee7b7;font-size:11px;margin-bottom:8px;font-weight:600;">ALTERNATIVES WITHIN TOLERANCE</div>';
        html += '<table style="width:100%;font-size:11px;border-collapse:collapse;">';
        html += '<tr style="color:#6ee7b7;"><th style="text-align:left;padding:4px;">Fraction</th><th>Decimal</th><th>Error</th><th>Sector</th><th>Denom Type</th><th></th></tr>';
        
        alternatives.forEach((alt, i) => {
            const isBest = alt.r === best.r && alt.m === best.m;
            const rowStyle = isBest ? 'background:rgba(16,185,129,0.2);' : '';
            html += `<tr style="${rowStyle}">
                <td style="padding:4px;font-family:monospace;color:#f0fdf4;font-weight:${isBest?'bold':'normal'};">${alt.r}/${alt.m}</td>
                <td style="padding:4px;font-family:monospace;color:#a7f3d0;">${alt.value.toFixed(6)}</td>
                <td style="padding:4px;font-family:monospace;color:#fbbf24;">${alt.error.toFixed(6)}</td>
                <td style="padding:4px;color:#a78bfa;">S${alt.sector}</td>
                <td style="padding:4px;color:${alt.isPrime?'#f59e0b':'#6366f1'};">${alt.isPrime?'Prime':'Composite'}</td>
                <td style="padding:4px;"><button onclick="solverSelectAlternative(${alt.r},${alt.m})" style="background:#334155;border:none;color:#e2e8f0;padding:2px 8px;border-radius:3px;cursor:pointer;font-size:10px;">Select</button></td>
            </tr>`;
        });
        html += '</table>';
        document.getElementById('solverAlternatives').innerHTML = html;
    } else {
        document.getElementById('solverAlternatives').innerHTML = '';
    }
}

function solverSelectAlternative(r, m) {
    solverCurrentMatch = {
        r, m,
        value: r/m,
        error: Math.abs(r/m - parseFloat(document.getElementById('solverInput').value)),
        sector: getSector(r, m),
        cf: getContinuedFraction(r/m, 10),
        isPrime: isPrime(m)
    };
    displaySolverResults(solverCurrentMatch, parseFloat(document.getElementById('solverInput').value), 
        findAlternativesWithinTolerance(parseFloat(document.getElementById('solverInput').value), 
        parseFloat(document.getElementById('solverTolerance').value), 
        parseInt(document.getElementById('solverMaxDenom').value), 25));
}

// Live update solver display during playback
function updateSolverLive(r, m) {
    if (!r || !m || m === 0) return;
    
    const value = r / m;
    const sector = getSector(r, m);
    const cf = getContinuedFraction(value, 10);
    const denomIsPrime = isPrime(m);
    const numIsPrime = isPrime(r);
    
    // Show solver results panel
    document.getElementById('solverResults').style.display = 'block';
    
    // Update fraction
    document.getElementById('solverBestFrac').textContent = r + '/' + m;
    document.getElementById('solverBestFrac').style.color = '#fbbf24'; // Yellow for live
    
    // Update decimal
    document.getElementById('solverBestDecimal').textContent = value.toFixed(8);
    
    // Update error (show as "LIVE" indicator)
    document.getElementById('solverError').innerHTML = '<span style="color:#22c55e;font-size:12px;">‚óè LIVE</span>';
    
    // Update sector
    document.getElementById('solverSector').textContent = 'S' + sector + ' (1/' + (sector+1) + ', 1/' + sector + ']';
    
    // Update CF
    document.getElementById('solverCF').textContent = '[' + cf.join('; ') + ']';
    
    // Update gear ratio
    document.getElementById('solverGear').textContent = m + ':' + r + ' (teeth ratio)';
    
    // Category
    const category = (numIsPrime && denomIsPrime) ? 'PP' : (numIsPrime && !denomIsPrime) ? 'PC' : (!numIsPrime && denomIsPrime) ? 'CP' : 'CC';
    const catColors = { 'PP': '#22c55e', 'PC': '#f59e0b', 'CP': '#6366f1', 'CC': '#94a3b8' };
    const catLabels = { 'PP': 'Both Prime', 'PC': 'Prime/Comp', 'CP': 'Comp/Prime', 'CC': 'Both Comp' };
    document.getElementById('solverCategory').textContent = category + ' (' + catLabels[category] + ')';
    document.getElementById('solverCategory').style.color = catColors[category];
    
    // Denom type
    document.getElementById('solverDenomType').textContent = denomIsPrime ? 'Prime' : 'Composite';
    document.getElementById('solverDenomType').style.color = denomIsPrime ? '#f59e0b' : '#6366f1';
    
    // Path
    const path = cfPath(cf);
    document.getElementById('solverPath').textContent = path;
    
    // Update preview
    document.getElementById('solverMatchPreview').innerHTML = '<span style="color:#22c55e;">‚óè</span> ' + r + '/' + m + ' = ' + value.toFixed(6);
}

function solverHighlightOnRing() {
    if (!solverCurrentMatch) return;
    
    // Show all sectors but highlight the matching one (dim others)
    document.getElementById('showAllSectors').checked = true;
    state.highlightSectorOnly = solverCurrentMatch.sector;
    
    // Set point size from solver control
    const solverPtSize = parseFloat(document.getElementById('solverPointSize')?.value || 5);
    document.getElementById('ringPointSize').value = solverPtSize;
    updatePtSizeDisplay();
    
    // Enable tracker to highlight the specific fraction
    document.getElementById('enableResidueTracker').checked = true;
    document.getElementById('trackResidues').value = solverCurrentMatch.r;
    document.getElementById('trackerColor').value = '#10b981';
    document.getElementById('trackerGlow').checked = true;
    document.getElementById('trackerSize').value = solverPtSize;
    
    drawMainRing();
    
    // Also highlight path on sector tree
    const solverPoint = {
        r: solverCurrentMatch.r,
        m: solverCurrentMatch.m,
        sector: solverCurrentMatch.sector,
        isPrime: isPrime(solverCurrentMatch.m)
    };
    selectPointForTree(solverPoint);
    
    // Scroll to ring
    document.getElementById('mainRing').scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function solverPlayFraction() {
    if (!solverCurrentMatch) return;
    initAudioContext();
    playFraction(solverCurrentMatch.r, solverCurrentMatch.m, 1.0);
    setHarmonicInterval(solverCurrentMatch.r, solverCurrentMatch.m);
}

function solverPlayPath(direction) {
    if (!solverCurrentMatch) return;
    
    // Select the point for tree and play its path
    const solverPoint = {
        r: solverCurrentMatch.r,
        m: solverCurrentMatch.m,
        sector: solverCurrentMatch.sector,
        isPrime: isPrime(solverCurrentMatch.m)
    };
    selectPointForTree(solverPoint);
    
    // Play the tree path
    playTreePathAudio(direction);
}

function solverCopyReport() {
    if (!solverCurrentMatch) return;
    const target = document.getElementById('solverInput').value;
    const report = `FAREY RATIO SOLVER REPORT
========================
Target Value: ${target}
Best Match: ${solverCurrentMatch.r}/${solverCurrentMatch.m}
Decimal: ${solverCurrentMatch.value.toFixed(10)}
Error: ${solverCurrentMatch.error.toExponential(4)}
Sector: S${solverCurrentMatch.sector} = (1/${solverCurrentMatch.sector+1}, 1/${solverCurrentMatch.sector}]
Continued Fraction: [${solverCurrentMatch.cf.join('; ')}]
Gear Ratio: ${solverCurrentMatch.m}:${solverCurrentMatch.r}
Denominator: ${solverCurrentMatch.isPrime ? 'Prime' : 'Composite'}
Generated: ${new Date().toISOString()}`;
    
    navigator.clipboard.writeText(report).then(() => {
        alert('Report copied to clipboard!');
    });
}

// =============================================
// PROJECTS SYSTEM - localStorage Persistence
// =============================================

const PROJECTS_KEY = 'farey_saas_projects';
const LAST_SESSION_KEY = 'farey_saas_last_session';

function getProjects() {
    const data = localStorage.getItem(PROJECTS_KEY);
    return data ? JSON.parse(data) : [];
}

function saveProjects(projects) {
    localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
    updateProjectCount();
}

// =============================================
// NUMBER THEORY TAB FUNCTIONS (Meissel-Lehmer)
// =============================================

function computePiX() {
    const x = parseInt(document.getElementById('piInputX').value) || 1000000;
    const resultDiv = document.getElementById('piResult');
    const timeDiv = document.getElementById('piTime');
    
    resultDiv.innerHTML = '<div style="color:#64748b;">Computing...</div>';
    
    setTimeout(() => {
        const start = performance.now();
        const result = NumberTheory.pi(x);
        const elapsed = performance.now() - start;
        
        resultDiv.innerHTML = `
            <div style="color:#64748b;font-size:11px;">pi(${x.toLocaleString()}) =</div>
            <div style="color:#22c55e;font-size:18px;font-weight:bold;">${result.toLocaleString()}</div>
        `;
        timeDiv.textContent = `Computed in ${elapsed.toFixed(2)}ms`;
        updateSieveStats();
    }, 10);
}

function computeSumPhi() {
    const n = parseInt(document.getElementById('sumPhiInputN').value) || 100000;
    const resultDiv = document.getElementById('sumPhiResult');
    const asymDiv = document.getElementById('sumPhiAsymptotic');
    
    resultDiv.innerHTML = '<div style="color:#64748b;">Computing...</div>';
    
    setTimeout(() => {
        const start = performance.now();
        
        // For small n, compute directly
        let result;
        if (n <= 100000) {
            NumberTheory.initSieve(n);
            result = 0;
            for (let k = 1; k <= n; k++) {
                result += NumberTheory.phi(k);
            }
        } else {
            // Use asymptotic for very large n
            result = Math.round(3 * n * n / (Math.PI * Math.PI));
        }
        
        const elapsed = performance.now() - start;
        const asymptotic = 3 * n * n / (Math.PI * Math.PI);
        const error = n <= 100000 ? ((result - asymptotic) / result * 100).toFixed(4) : 0;
        
        resultDiv.innerHTML = `
            <div style="color:#64748b;font-size:11px;">Sum phi(1..${n.toLocaleString()}) =</div>
            <div style="color:#f59e0b;font-size:18px;font-weight:bold;">${result.toLocaleString()}</div>
        `;
        asymDiv.innerHTML = `
            Asymptotic: ${Math.round(asymptotic).toLocaleString()} | 
            ${n <= 100000 ? `Error: ${error}%` : '(using asymptotic)'} | 
            ${elapsed.toFixed(2)}ms
        `;
        updateSieveStats();
    }, 10);
}

function analyzeNumber() {
    const n = parseInt(document.getElementById('numAnalysisInput').value) || 1;
    const resultDiv = document.getElementById('numAnalysisResult');
    
    if (n < 1 || n > 1e12) {
        resultDiv.innerHTML = '<span style="color:#ef4444;">Number must be between 1 and 10^12</span>';
        return;
    }
    
    const start = performance.now();
    
    // Initialize sieve if needed
    if (n <= 1e7) NumberTheory.initSieve(n);
    
    const isPrimeN = NumberTheory.isPrime(n);
    const phiN = n <= 1e7 ? NumberTheory.phi(n) : null;
    const factors = n <= 1e7 ? NumberTheory.factorize(n) : null;
    const divCount = n <= 1e7 ? NumberTheory.divisorCount(n) : null;
    const divSum = n <= 1e7 ? NumberTheory.divisorSum(n) : null;
    const mobiusN = n <= 1e7 ? NumberTheory.mobius(n) : null;
    
    const elapsed = performance.now() - start;
    
    let html = `<div style="color:#a5b4fc;margin-bottom:6px;font-weight:bold;">n = ${n.toLocaleString()}</div>`;
    html += `<div style="color:${isPrimeN ? '#22c55e' : '#ef4444'};">Prime: ${isPrimeN ? 'YES' : 'NO'}</div>`;
    
    if (phiN !== null) {
        html += `<div style="color:#f59e0b;">phi(n) = ${phiN.toLocaleString()}</div>`;
        html += `<div style="color:#6366f1;">mu(n) = ${mobiusN}</div>`;
        html += `<div style="color:#14b8a6;">d(n) = ${divCount} divisors</div>`;
        html += `<div style="color:#ec4899;">sigma(n) = ${divSum.toLocaleString()}</div>`;
        
        if (factors && factors.length > 0) {
            const factorStr = factors.map(f => f.exp === 1 ? f.p : `${f.p}^${f.exp}`).join(' * ');
            html += `<div style="color:#a5b4fc;margin-top:6px;">Factorization: ${factorStr}</div>`;
        }
    } else {
        html += `<div style="color:#64748b;font-size:10px;margin-top:4px;">(Detailed analysis limited to n <= 10^7)</div>`;
    }
    
    html += `<div style="color:#475569;font-size:9px;margin-top:6px;">${elapsed.toFixed(2)}ms</div>`;
    resultDiv.innerHTML = html;
    updateSieveStats();
}

function computeNthPrime() {
    const k = parseInt(document.getElementById('nthPrimeInput').value) || 1;
    
    if (k < 1 || k > 1e7) {
        document.getElementById('nthPrimeVal').textContent = 'k must be 1-10M';
        return;
    }
    
    const start = performance.now();
    const p = NumberTheory.nthPrime(k);
    const elapsed = performance.now() - start;
    
    document.getElementById('nthPrimeK').textContent = k.toLocaleString();
    document.getElementById('nthPrimeVal').textContent = p.toLocaleString();
    document.getElementById('nthPrimeVal').title = `Computed in ${elapsed.toFixed(2)}ms`;
    updateSieveStats();
}

function computePrimesInRange() {
    const lo = parseInt(document.getElementById('primeRangeLo').value) || 2;
    const hi = parseInt(document.getElementById('primeRangeHi').value) || 100;
    const resultDiv = document.getElementById('primeRangeResult');
    
    if (hi - lo > 10000) {
        resultDiv.innerHTML = '<span style="color:#ef4444;">Range too large (max 10000)</span>';
        return;
    }
    
    if (hi > 1e8) {
        resultDiv.innerHTML = '<span style="color:#ef4444;">Upper limit max 10^8</span>';
        return;
    }
    
    const start = performance.now();
    const primes = NumberTheory.primesInRange(lo, hi);
    const elapsed = performance.now() - start;
    
    resultDiv.innerHTML = `
        <div style="color:#14b8a6;margin-bottom:4px;">${primes.length} primes in [${lo}, ${hi}]</div>
        <div style="word-wrap:break-word;color:#e2e8f0;">${primes.join(', ')}</div>
        <div style="color:#475569;font-size:9px;margin-top:4px;">${elapsed.toFixed(2)}ms</div>
    `;
    updateSieveStats();
}

function updateSieveStats() {
    const stats = NumberTheory.getStats();
    document.getElementById('statSieveLimit').textContent = stats.sieveLimit.toLocaleString();
    document.getElementById('statPrimeCount').textContent = stats.primeCount.toLocaleString();
    document.getElementById('statPhiCache').textContent = stats.phiCacheSize.toLocaleString();
    document.getElementById('statPiCache').textContent = stats.piCacheSize.toLocaleString();
}

function benchmarkSieve() {
    const resultDiv = document.getElementById('benchmarkResult');
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = '<span style="color:#64748b;">Running benchmark...</span>';
    
    setTimeout(() => {
        const results = [];
        
        // Test 1: Sieve initialization
        const sieveStart = performance.now();
        NumberTheory.initSieve(1000000);
        results.push(`Sieve 10^6: ${(performance.now() - sieveStart).toFixed(2)}ms`);
        
        // Test 2: Batch primality (1M tests)
        const primeStart = performance.now();
        let primeCount = 0;
        for (let i = 2; i <= 100000; i++) if (NumberTheory.isPrime(i)) primeCount++;
        results.push(`100K primality tests: ${(performance.now() - primeStart).toFixed(2)}ms (${primeCount} primes)`);
        
        // Test 3: Batch totient
        const phiStart = performance.now();
        let phiSum = 0;
        for (let i = 1; i <= 10000; i++) phiSum += NumberTheory.phi(i);
        results.push(`10K totients: ${(performance.now() - phiStart).toFixed(2)}ms (sum=${phiSum.toLocaleString()})`);
        
        // Test 4: pi(10^6) via Lucy
        NumberTheory.clearCaches();
        const piStart = performance.now();
        const pi1m = NumberTheory.pi(1000000);
        results.push(`pi(10^6): ${(performance.now() - piStart).toFixed(2)}ms (=${pi1m.toLocaleString()})`);
        
        resultDiv.innerHTML = `
            <div style="color:#22c55e;margin-bottom:8px;font-weight:bold;">Benchmark Results</div>
            ${results.map(r => `<div style="color:#e2e8f0;">${r}</div>`).join('')}
        `;
        updateSieveStats();
    }, 50);
}

function updateProjectCount() {
    const count = getProjects().length;
    document.getElementById('projectCount').textContent = count;
}

function solverSaveToProject() {
    if (!solverCurrentMatch) return;
    
    const name = prompt('Project name:', `Ratio ${solverCurrentMatch.r}/${solverCurrentMatch.m}`);
    if (!name) return;
    
    const project = {
        id: Date.now(),
        name: name,
        created: new Date().toISOString(),
        type: 'solver',
        data: {
            target: document.getElementById('solverInput').value,
            match: solverCurrentMatch,
            nMax: state.nMax,
            sector: solverCurrentMatch.sector
        }
    };
    
    const projects = getProjects();
    projects.unshift(project);
    saveProjects(projects);
    alert('Saved to projects!');
}

function quickSaveCurrentState() {
    const session = {
        nMax: state.nMax,
        sectorMin: state.sectorMin,
        sectorMax: state.sectorMax,
        mode: state.mode,
        viewSector: document.getElementById('viewSector')?.value,
        colorMode: document.getElementById('colorMode')?.value,
        solverInput: document.getElementById('solverInput')?.value,
        timestamp: new Date().toISOString()
    };
    localStorage.setItem(LAST_SESSION_KEY, JSON.stringify(session));
    
    // Visual feedback
    const btn = event.target;
    const original = btn.textContent;
    btn.textContent = 'Saved!';
    btn.style.background = '#22c55e';
    setTimeout(() => {
        btn.textContent = original;
        btn.style.background = '';
    }, 1000);
}

function loadLastSession() {
    const data = localStorage.getItem(LAST_SESSION_KEY);
    if (!data) {
        alert('No saved session found');
        return;
    }
    
    const session = JSON.parse(data);
    
    // Restore state
    if (session.nMax) document.getElementById('nMax').value = session.nMax;
    if (session.sectorMin) document.getElementById('sectorMin').value = session.sectorMin;
    if (session.sectorMax) document.getElementById('sectorMax').value = session.sectorMax;
    if (session.mode) document.getElementById('mode').value = session.mode;
    if (session.viewSector) document.getElementById('viewSector').value = session.viewSector;
    if (session.colorMode) document.getElementById('colorMode').value = session.colorMode;
    if (session.solverInput) document.getElementById('solverInput').value = session.solverInput;
    
    // Re-compute
    compute();
    
    // Visual feedback
    const btn = event.target;
    const original = btn.textContent;
    btn.textContent = 'Loaded!';
    btn.style.background = '#22c55e';
    setTimeout(() => {
        btn.textContent = original;
        btn.style.background = '';
    }, 1000);
}

function toggleProjectsSidebar() {
    let sidebar = document.getElementById('projectsSidebar');
    
    if (!sidebar) {
        // Create sidebar
        sidebar = document.createElement('div');
        sidebar.id = 'projectsSidebar';
        sidebar.style.cssText = `
            position: fixed; top: 0; right: 0; width: 350px; height: 100vh;
            background: #1e293b; border-left: 2px solid #f59e0b; z-index: 1000;
            transform: translateX(100%); transition: transform 0.3s ease;
            display: flex; flex-direction: column;
        `;
        sidebar.innerHTML = `
            <div style="padding:15px;border-bottom:1px solid #334155;display:flex;justify-content:space-between;align-items:center;">
                <h3 style="margin:0;color:#f59e0b;">Saved Projects</h3>
                <button onclick="toggleProjectsSidebar()" style="background:none;border:none;color:#94a3b8;font-size:20px;cursor:pointer;">&times;</button>
            </div>
            <div id="projectsList" style="flex:1;overflow-y:auto;padding:15px;"></div>
            <div style="padding:15px;border-top:1px solid #334155;">
                <button onclick="exportAllProjects()" style="width:100%;padding:10px;background:#475569;border:none;border-radius:6px;color:white;cursor:pointer;margin-bottom:8px;">Export All (JSON)</button>
                <button onclick="clearAllProjects()" style="width:100%;padding:10px;background:#ef4444;border:none;border-radius:6px;color:white;cursor:pointer;">Clear All</button>
            </div>
        `;
        document.body.appendChild(sidebar);
    }
    
    const isOpen = sidebar.style.transform === 'translateX(0px)';
    sidebar.style.transform = isOpen ? 'translateX(100%)' : 'translateX(0px)';
    
    if (!isOpen) {
        renderProjectsList();
    }
}

function renderProjectsList() {
    const projects = getProjects();
    const container = document.getElementById('projectsList');
    
    if (projects.length === 0) {
        container.innerHTML = '<p style="color:#64748b;text-align:center;margin-top:40px;">No saved projects yet.<br><br>Use the Solver to find ratios and save them here.</p>';
        return;
    }
    
    let html = '';
    projects.forEach(p => {
        const date = new Date(p.created).toLocaleDateString();
        html += `
            <div style="background:#0f172a;border-radius:8px;padding:12px;margin-bottom:10px;border:1px solid #334155;">
                <div style="display:flex;justify-content:space-between;align-items:start;">
                    <div>
                        <div style="color:#f0fdf4;font-weight:600;">${p.name}</div>
                        <div style="color:#64748b;font-size:11px;">${date}</div>
                    </div>
                    <button onclick="deleteProject(${p.id})" style="background:none;border:none;color:#ef4444;cursor:pointer;font-size:16px;">&times;</button>
                </div>
                ${p.data.match ? `
                    <div style="margin-top:8px;padding:8px;background:#1e293b;border-radius:4px;">
                        <div style="font-family:monospace;color:#10b981;font-size:16px;">${p.data.match.r}/${p.data.match.m}</div>
                        <div style="color:#94a3b8;font-size:11px;">= ${p.data.match.value.toFixed(6)} | S${p.data.match.sector}</div>
                    </div>
                ` : ''}
                <button onclick="loadProject(${p.id})" style="width:100%;margin-top:8px;padding:6px;background:#6366f1;border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">Load</button>
            </div>
        `;
    });
    container.innerHTML = html;
}

function loadProject(id) {
    const projects = getProjects();
    const project = projects.find(p => p.id === id);
    if (!project) return;
    
    if (project.data.match) {
        document.getElementById('solverInput').value = project.data.target || project.data.match.value;
        solverSearch(project.data.target || project.data.match.value.toString());
    }
    
    if (project.data.nMax) {
        document.getElementById('nMax').value = project.data.nMax;
    }
    
    toggleProjectsSidebar();
}

function deleteProject(id) {
    if (!confirm('Delete this project?')) return;
    const projects = getProjects().filter(p => p.id !== id);
    saveProjects(projects);
    renderProjectsList();
}

function clearAllProjects() {
    if (!confirm('Delete ALL projects? This cannot be undone.')) return;
    saveProjects([]);
    renderProjectsList();
}

function exportAllProjects() {
    const projects = getProjects();
    const blob = new Blob([JSON.stringify(projects, null, 2)], {type: 'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'farey_projects_' + Date.now() + '.json';
    a.click();
}

// Initialize project count on load
document.addEventListener('DOMContentLoaded', function() {
    updateProjectCount();
});

// ============================================
// ERROR ANALYSIS MODULE
// ============================================
let errorAnalysisCharts = {};

function runErrorAnalysis() {
    // Get range from inputs
    const startSector = parseInt(document.getElementById('errorAnalysisStart')?.value) || 1;
    const endSector = parseInt(document.getElementById('errorAnalysisEnd')?.value) || state.sectors.length;
    
    // Filter sectors by range
    const filteredSectors = state.sectors.filter(s => s.n >= startSector && s.n <= endSector && s.relError !== null);
    const errors = filteredSectors.map(s => s.relError);
    const absErrors = filteredSectors.filter(s => s.exact !== null).map(s => Math.abs(s.exact - s.predicted));
    const sectorNs = filteredSectors.map(s => s.n);
    
    if (errors.length < 5) {
        alert('Need at least 5 sectors with exact data for analysis. Check your range or compute sectors first.');
        return;
    }
    
    // Basic statistics
    const mean = errors.reduce((a,b) => a+b, 0) / errors.length;
    const variance = errors.reduce((a,b) => a + (b-mean)**2, 0) / errors.length;
    const std = Math.sqrt(variance);
    const skewness = errors.reduce((a,b) => a + ((b-mean)/std)**3, 0) / errors.length;
    const kurtosis = errors.reduce((a,b) => a + ((b-mean)/std)**4, 0) / errors.length - 3;
    
    document.getElementById('errMean').textContent = mean.toFixed(4) + '%';
    document.getElementById('errStd').textContent = std.toFixed(4) + '%';
    document.getElementById('errSkew').textContent = skewness.toFixed(4);
    document.getElementById('errKurt').textContent = kurtosis.toFixed(4);
    
    // Prime vs Composite sector analysis
    const primeErrors = [], compErrors = [];
    const mobiusValues = [];
    sectorNs.forEach((n, i) => {
        if (NumberTheory.isPrime(n)) {
            primeErrors.push(errors[i]);
        } else {
            compErrors.push(errors[i]);
        }
        mobiusValues.push(NumberTheory.mobius(n));
    });
    
    const primeMean = primeErrors.length > 0 ? primeErrors.reduce((a,b) => a+b, 0) / primeErrors.length : 0;
    const compMean = compErrors.length > 0 ? compErrors.reduce((a,b) => a+b, 0) / compErrors.length : 0;
    
    document.getElementById('errPrimeMean').textContent = primeMean.toFixed(4) + '%';
    document.getElementById('errCompMean').textContent = compMean.toFixed(4) + '%';
    
    // Mobius correlation
    const mobiusCorr = computeCorrelation(errors, mobiusValues);
    document.getElementById('errMobiusCorr').textContent = mobiusCorr.toFixed(4);
    document.getElementById('errMobiusCorr').style.color = Math.abs(mobiusCorr) > 0.1 ? '#22c55e' : '#94a3b8';
    
    // Autocorrelation
    const maxLag = Math.min(20, Math.floor(errors.length / 4));
    const autocorr = computeAutocorrelation(errors, maxLag);
    drawAutocorrChart(autocorr);
    
    // FFT Power Spectrum
    const spectrum = computeFFT(errors);
    drawFFTChart(spectrum, errors.length);
    
    // Find spectral peaks
    findSpectralPeaks(spectrum, errors.length);
    
    // Error distribution histogram
    drawErrorHistogram(errors);
    
    // Prime vs Composite comparison
    drawPrimeCompChart(sectorNs, errors);
    
    // Cumulative absolute error
    drawCumulativeErrorChart(absErrors, sectorNs);
}

function computeCorrelation(x, y) {
    const n = x.length;
    const mx = x.reduce((a,b) => a+b, 0) / n;
    const my = y.reduce((a,b) => a+b, 0) / n;
    let num = 0, dx = 0, dy = 0;
    for (let i = 0; i < n; i++) {
        num += (x[i] - mx) * (y[i] - my);
        dx += (x[i] - mx) ** 2;
        dy += (y[i] - my) ** 2;
    }
    return dx > 0 && dy > 0 ? num / Math.sqrt(dx * dy) : 0;
}

function computeAutocorrelation(data, maxLag) {
    const n = data.length;
    const mean = data.reduce((a,b) => a+b, 0) / n;
    const variance = data.reduce((a,b) => a + (b-mean)**2, 0) / n;
    const result = [];
    for (let lag = 1; lag <= maxLag; lag++) {
        let sum = 0;
        for (let i = 0; i < n - lag; i++) {
            sum += (data[i] - mean) * (data[i + lag] - mean);
        }
        result.push(variance > 0 ? sum / ((n - lag) * variance) : 0);
    }
    return result;
}

function computeFFT(data) {
    // Pad to power of 2
    let n = 1;
    while (n < data.length) n *= 2;
    const padded = new Array(n).fill(0);
    const mean = data.reduce((a,b) => a+b, 0) / data.length;
    for (let i = 0; i < data.length; i++) padded[i] = data[i] - mean;
    
    // Simple DFT (for moderate N, sufficient)
    const spectrum = [];
    const halfN = Math.floor(n / 2);
    for (let k = 1; k <= halfN; k++) {
        let re = 0, im = 0;
        for (let t = 0; t < n; t++) {
            const angle = -2 * Math.PI * k * t / n;
            re += padded[t] * Math.cos(angle);
            im += padded[t] * Math.sin(angle);
        }
        spectrum.push(Math.sqrt(re*re + im*im) / n);
    }
    return spectrum;
}

function drawAutocorrChart(autocorr) {
    const ctx = document.getElementById('autocorrChart').getContext('2d');
    if (errorAnalysisCharts.autocorr) errorAnalysisCharts.autocorr.destroy();
    
    const labels = autocorr.map((_, i) => i + 1);
    const confBound = 1.96 / Math.sqrt(state.sectors.length);
    
    errorAnalysisCharts.autocorr = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                data: autocorr,
                backgroundColor: autocorr.map(v => Math.abs(v) > confBound ? '#ef4444' : '#6366f1')
            }]
        },
        options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
                x: { ticks: { color: '#64748b', font: { size: 9 } } },
                y: { ticks: { color: '#64748b' }, min: -1, max: 1 }
            }
        }
    });
}

function drawFFTChart(spectrum, dataLen) {
    const ctx = document.getElementById('fftChart').getContext('2d');
    if (errorAnalysisCharts.fft) errorAnalysisCharts.fft.destroy();
    
    // Convert index to frequency (cycles per sector)
    const freqs = spectrum.map((_, i) => ((i + 1) / dataLen).toFixed(3));
    
    errorAnalysisCharts.fft = new Chart(ctx, {
        type: 'line',
        data: {
            labels: freqs.slice(0, Math.min(50, spectrum.length)),
            datasets: [{
                data: spectrum.slice(0, Math.min(50, spectrum.length)),
                borderColor: '#8b5cf6',
                backgroundColor: 'rgba(139,92,246,0.2)',
                fill: true,
                tension: 0.1,
                pointRadius: 0
            }]
        },
        options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
                x: { title: { display: true, text: 'Frequency', color: '#64748b' }, ticks: { color: '#64748b', maxTicksLimit: 10 } },
                y: { title: { display: true, text: 'Power', color: '#64748b' }, ticks: { color: '#64748b' } }
            }
        }
    });
}

function findSpectralPeaks(spectrum, dataLen) {
    // Find local maxima
    const peaks = [];
    for (let i = 1; i < spectrum.length - 1; i++) {
        if (spectrum[i] > spectrum[i-1] && spectrum[i] > spectrum[i+1]) {
            const freq = (i + 1) / dataLen;
            const period = 1 / freq;
            peaks.push({ index: i, power: spectrum[i], freq, period });
        }
    }
    
    // Sort by power and take top 8
    peaks.sort((a, b) => b.power - a.power);
    const topPeaks = peaks.slice(0, 8);
    
    // Known zeta zeros (imaginary parts)
    const zetaZeros = [14.135, 21.022, 25.011, 30.425, 32.935, 37.586, 40.919, 43.327];
    
    let html = '<table style="width:100%;"><tr><th style="text-align:left;">Rank</th><th>Freq</th><th>Period</th><th>Power</th><th>Near zeta zero?</th></tr>';
    topPeaks.forEach((p, i) => {
        // Check if period is near any zeta zero (within 10%)
        let nearZeta = '-';
        for (const z of zetaZeros) {
            if (Math.abs(p.period - z) / z < 0.1) {
                nearZeta = `~${z.toFixed(2)}`;
                break;
            }
            if (Math.abs(p.period * 2 * Math.PI - z) / z < 0.1) {
                nearZeta = `~${z.toFixed(2)} (2pi scaled)`;
                break;
            }
        }
        const highlight = nearZeta !== '-' ? 'color:#22c55e;' : '';
        html += `<tr style="${highlight}"><td>${i+1}</td><td>${p.freq.toFixed(4)}</td><td>${p.period.toFixed(2)}</td><td>${p.power.toFixed(4)}</td><td>${nearZeta}</td></tr>`;
    });
    html += '</table>';
    document.getElementById('spectralPeaksTable').innerHTML = html;
}

function drawErrorHistogram(errors) {
    const ctx = document.getElementById('errorHistChart').getContext('2d');
    if (errorAnalysisCharts.hist) errorAnalysisCharts.hist.destroy();
    
    // Create bins
    const min = Math.min(...errors);
    const max = Math.max(...errors);
    const binCount = Math.min(20, Math.ceil(Math.sqrt(errors.length)));
    const binWidth = (max - min) / binCount;
    const bins = new Array(binCount).fill(0);
    const binLabels = [];
    
    for (let i = 0; i < binCount; i++) {
        binLabels.push((min + i * binWidth + binWidth/2).toFixed(1));
    }
    
    errors.forEach(e => {
        const idx = Math.min(binCount - 1, Math.floor((e - min) / binWidth));
        bins[idx]++;
    });
    
    errorAnalysisCharts.hist = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: binLabels,
            datasets: [{
                data: bins,
                backgroundColor: '#22c55e'
            }]
        },
        options: {
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
                x: { ticks: { color: '#64748b', maxRotation: 45 } },
                y: { ticks: { color: '#64748b' } }
            }
        }
    });
}

function drawPrimeCompChart(sectorNs, errors) {
    const ctx = document.getElementById('primeCompErrorChart').getContext('2d');
    if (errorAnalysisCharts.primeComp) errorAnalysisCharts.primeComp.destroy();
    
    const primeData = [], compData = [];
    sectorNs.forEach((n, i) => {
        if (NumberTheory.isPrime(n)) {
            primeData.push({ x: n, y: errors[i] });
        } else {
            compData.push({ x: n, y: errors[i] });
        }
    });
    
    errorAnalysisCharts.primeComp = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [
                { label: 'Prime n', data: primeData, backgroundColor: '#22c55e', pointRadius: 3 },
                { label: 'Composite n', data: compData, backgroundColor: '#6366f1', pointRadius: 2 }
            ]
        },
        options: {
            responsive: true,
            plugins: { legend: { labels: { color: '#94a3b8', font: { size: 10 } } } },
            scales: {
                x: { title: { display: true, text: 'Sector n', color: '#64748b' }, ticks: { color: '#64748b' } },
                y: { title: { display: true, text: 'Error %', color: '#64748b' }, ticks: { color: '#64748b' } }
            }
        }
    });
}

function drawCumulativeErrorChart(absErrors, sectorNs) {
    const ctx = document.getElementById('cumulativeErrorChart').getContext('2d');
    if (errorAnalysisCharts.cumulative) errorAnalysisCharts.cumulative.destroy();
    
    // Cumulative sum
    const cumulative = [];
    let sum = 0;
    absErrors.forEach(e => {
        sum += e;
        cumulative.push(sum);
    });
    
    // RH bound comparison: O(sqrt(n) * log(n))
    const rhBound = sectorNs.map((_, i) => {
        const n = i + 1;
        return Math.sqrt(n) * Math.log(n + 1) * (cumulative[cumulative.length-1] / (Math.sqrt(sectorNs.length) * Math.log(sectorNs.length + 1)));
    });
    
    errorAnalysisCharts.cumulative = new Chart(ctx, {
        type: 'line',
        data: {
            labels: sectorNs,
            datasets: [
                { label: 'Cumulative |Error|', data: cumulative, borderColor: '#f59e0b', fill: false, pointRadius: 0 },
                { label: 'sqrt(n)log(n) bound', data: rhBound, borderColor: '#ef4444', borderDash: [5,5], fill: false, pointRadius: 0 }
            ]
        },
        options: {
            responsive: true,
            plugins: { legend: { labels: { color: '#94a3b8', font: { size: 10 } } } },
            scales: {
                x: { ticks: { color: '#64748b', maxTicksLimit: 10 } },
                y: { ticks: { color: '#64748b' } }
            }
        }
    });
}

function exportErrorAnalysis() {
    const errors = state.sectors.filter(s => s.relError !== null);
    let csv = 'n,exact,predicted,relError,absError,isPrimeN,mobius\n';
    errors.forEach(s => {
        const absErr = Math.abs(s.exact - s.predicted);
        const isPrime = NumberTheory.isPrime(s.n) ? 1 : 0;
        const mu = NumberTheory.mobius(s.n);
        csv += `${s.n},${s.exact},${s.predicted.toFixed(4)},${s.relError.toFixed(6)},${absErr.toFixed(4)},${isPrime},${mu}\n`;
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `error_analysis_N${state.nMax}_${Date.now()}.csv`;
    a.click();
}

// Export Error Chart with Sector Data
function exportErrorChart() {
    exportChartWithSectorData('mainErrorChart', 'Relative Error %', 'error');
}

// Export Count Chart with Sector Data  
function exportCountChart() {
    exportChartWithSectorData('mainCountChart', 'Exact vs Predicted', 'count');
}

function exportChartWithSectorData(chartId, title, type) {
    const chartCanvas = document.getElementById(chartId);
    if (!chartCanvas) return;
    
    const sectors = state.sectors.filter(s => s.relError !== null).slice(0, 20);
    if (sectors.length === 0) {
        alert('No sector data available');
        return;
    }
    
    // 4K dimensions
    const width = 3840;
    const height = 2160;
    const padding = 60;
    const chartHeight = height * 0.55;
    const tableStartY = chartHeight + padding + 80;
    
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    // Background
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, width, height);
    
    // Title
    ctx.fillStyle = '#e2e8f0';
    ctx.font = 'bold 48px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`${title} - N=${state.nMax}`, width/2, 60);
    
    // Draw chart (scaled up)
    const chartWidth = width - padding * 2;
    ctx.drawImage(chartCanvas, padding, 100, chartWidth, chartHeight - 100);
    
    // Relative Error summary (top center above table)
    const totalError = sectors.reduce((sum, s) => sum + Math.abs(s.relError || 0), 0);
    const avgError = totalError / sectors.length;
    const maxError = Math.max(...sectors.map(s => Math.abs(s.relError || 0)));
    
    ctx.fillStyle = '#a78bfa';
    ctx.font = 'bold 36px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`Avg Error: ${avgError.toFixed(4)}%  |  Max Error: ${maxError.toFixed(4)}%  |  Sectors: ${state.sectors.length}`, width/2, tableStartY - 40);
    
    // Draw sector data table
    ctx.fillStyle = '#94a3b8';
    ctx.font = 'bold 28px monospace';
    ctx.textAlign = 'left';
    
    const colWidths = [80, 200, 180, 200, 180];
    const headers = ['n', 'Interval', 'Exact', 'Predicted', 'Error%'];
    let x = padding;
    
    // Table header
    ctx.fillStyle = '#6366f1';
    headers.forEach((h, i) => {
        ctx.fillText(h, x, tableStartY);
        x += colWidths[i];
    });
    
    // Table rows (2 columns of 10)
    ctx.font = '24px monospace';
    const rowHeight = 36;
    const col2Start = width / 2 + 50;
    
    sectors.forEach((s, i) => {
        const col = i < 10 ? 0 : 1;
        const row = i < 10 ? i : i - 10;
        const baseX = col === 0 ? padding : col2Start;
        const y = tableStartY + 50 + row * rowHeight;
        
        ctx.fillStyle = '#e2e8f0';
        ctx.fillText(s.n.toString(), baseX, y);
        ctx.fillText(`(1/${s.n+1}, 1/${s.n}]`, baseX + colWidths[0], y);
        ctx.fillText(s.exact !== null ? s.exact.toString() : '-', baseX + colWidths[0] + colWidths[1], y);
        ctx.fillText(s.predicted.toFixed(2), baseX + colWidths[0] + colWidths[1] + colWidths[2], y);
        
        const errColor = Math.abs(s.relError) < 1 ? '#22c55e' : Math.abs(s.relError) < 5 ? '#f59e0b' : '#ef4444';
        ctx.fillStyle = errColor;
        ctx.fillText((s.relError !== null ? s.relError.toFixed(4) + '%' : '-'), baseX + colWidths[0] + colWidths[1] + colWidths[2] + colWidths[3], y);
    });
    
    // Footer
    ctx.fillStyle = '#475569';
    ctx.font = '20px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io | ' + new Date().toISOString().slice(0,10), width/2, height - 30);
    
    // Download
    const link = document.createElement('a');
    link.download = `farey_${type}_chart_N${state.nMax}_4K_${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

// Sector Data Export with Range Options (4K)
function showSectorExportDialog() {
    let dialog = document.getElementById('sectorExportDialog');
    if (!dialog) {
        dialog = document.createElement('div');
        dialog.id = 'sectorExportDialog';
        dialog.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 10000;
            display: flex; justify-content: center; align-items: center;
        `;
        dialog.innerHTML = `
            <div style="background:#1e293b;border-radius:12px;padding:24px;max-width:400px;border:2px solid #6366f1;">
                <h3 style="margin:0 0 20px 0;color:#a78bfa;">Export Sector Data (4K)</h3>
                <div style="margin-bottom:15px;">
                    <label style="color:#94a3b8;font-size:13px;">Sector Range:</label>
                    <div style="display:flex;gap:10px;margin-top:8px;">
                        <input type="number" id="exportSectorStart" value="1" min="1" style="width:80px;padding:8px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        <span style="color:#64748b;line-height:36px;">to</span>
                        <input type="number" id="exportSectorEnd" value="20" min="1" style="width:80px;padding:8px;background:#0f172a;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                    </div>
                </div>
                <div style="margin-bottom:15px;">
                    <label style="color:#94a3b8;font-size:13px;">Include:</label>
                    <div style="margin-top:8px;">
                        <label style="color:#e2e8f0;font-size:12px;display:block;margin-bottom:5px;">
                            <input type="checkbox" id="exportIncludeChart" checked> Chart visualization
                        </label>
                        <label style="color:#e2e8f0;font-size:12px;display:block;margin-bottom:5px;">
                            <input type="checkbox" id="exportIncludeStats" checked> Statistics summary
                        </label>
                        <label style="color:#e2e8f0;font-size:12px;display:block;">
                            <input type="checkbox" id="exportIncludeCategories"> Category columns (PP,PC,CP,CC)
                        </label>
                    </div>
                </div>
                <div style="display:flex;gap:10px;margin-top:20px;">
                    <button onclick="executeSectorExport()" style="flex:1;padding:12px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:6px;color:white;cursor:pointer;font-weight:600;">Export 4K PNG</button>
                    <button onclick="closeSectorExportDialog()" style="padding:12px 20px;background:#475569;border:none;border-radius:6px;color:white;cursor:pointer;">Cancel</button>
                </div>
            </div>
        `;
        document.body.appendChild(dialog);
    }
    
    // Set max range based on available sectors
    const maxSector = state.sectors.length;
    document.getElementById('exportSectorEnd').value = Math.min(20, maxSector);
    document.getElementById('exportSectorEnd').max = maxSector;
    document.getElementById('exportSectorStart').max = maxSector;
    
    dialog.style.display = 'flex';
}

function closeSectorExportDialog() {
    const dialog = document.getElementById('sectorExportDialog');
    if (dialog) dialog.style.display = 'none';
}

function executeSectorExport() {
    const startSector = parseInt(document.getElementById('exportSectorStart').value) || 1;
    const endSector = parseInt(document.getElementById('exportSectorEnd').value) || 20;
    const includeChart = document.getElementById('exportIncludeChart').checked;
    const includeStats = document.getElementById('exportIncludeStats').checked;
    const includeCategories = document.getElementById('exportIncludeCategories').checked;
    
    const sectors = state.sectors.filter(s => s.n >= startSector && s.n <= endSector && s.relError !== null);
    if (sectors.length === 0) {
        alert('No sector data in selected range');
        return;
    }
    
    // 4K canvas
    const width = 3840;
    const rowsPerColumn = 25;
    const numColumns = Math.ceil(sectors.length / rowsPerColumn);
    const columnWidth = includeCategories ? 900 : 700;
    const tableWidth = numColumns * columnWidth;
    const chartHeight = includeChart ? 800 : 0;
    const statsHeight = includeStats ? 100 : 0;
    const tableHeight = Math.min(sectors.length, rowsPerColumn) * 32 + 60;
    const height = Math.max(2160, chartHeight + statsHeight + tableHeight + 200);
    
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    // Background
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, width, height);
    
    // Title
    ctx.fillStyle = '#e2e8f0';
    ctx.font = 'bold 48px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`Farey Sector Data - N=${state.nMax} - Sectors ${startSector}-${endSector}`, width/2, 60);
    
    let yOffset = 100;
    
    // Chart
    if (includeChart) {
        const chartCanvas = document.getElementById('mainErrorChart');
        if (chartCanvas) {
            ctx.drawImage(chartCanvas, 100, yOffset, width - 200, chartHeight - 50);
        }
        yOffset += chartHeight;
    }
    
    // Statistics
    if (includeStats) {
        const totalError = sectors.reduce((sum, s) => sum + Math.abs(s.relError || 0), 0);
        const avgError = totalError / sectors.length;
        const maxError = Math.max(...sectors.map(s => Math.abs(s.relError || 0)));
        const totalExact = sectors.reduce((sum, s) => sum + (s.exact || 0), 0);
        
        ctx.fillStyle = '#a78bfa';
        ctx.font = 'bold 32px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`Total Fractions: ${totalExact.toLocaleString()}  |  Avg Error: ${avgError.toFixed(4)}%  |  Max Error: ${maxError.toFixed(4)}%`, width/2, yOffset + 50);
        yOffset += statsHeight;
    }
    
    // Table headers
    yOffset += 40;
    ctx.fillStyle = '#6366f1';
    ctx.font = 'bold 24px monospace';
    ctx.textAlign = 'left';
    
    const baseHeaders = ['n', 'Interval', 'Exact', 'Pred', 'Err%'];
    const categoryHeaders = ['P(m)', 'C(m)', 'PP', 'PC', 'CP', 'CC'];
    const headers = includeCategories ? [...baseHeaders, ...categoryHeaders] : baseHeaders;
    const colWidths = includeCategories ? [60, 150, 100, 100, 100, 80, 80, 60, 60, 60, 60] : [60, 150, 100, 100, 100];
    
    // Draw headers for each column
    for (let col = 0; col < numColumns; col++) {
        let x = 60 + col * columnWidth;
        headers.forEach((h, i) => {
            ctx.fillText(h, x, yOffset);
            x += colWidths[i];
        });
    }
    
    // Table rows
    ctx.font = '20px monospace';
    const rowHeight = 32;
    
    sectors.forEach((s, i) => {
        const col = Math.floor(i / rowsPerColumn);
        const row = i % rowsPerColumn;
        const baseX = 60 + col * columnWidth;
        const y = yOffset + 40 + row * rowHeight;
        
        let x = baseX;
        
        ctx.fillStyle = '#e2e8f0';
        ctx.fillText(s.n.toString(), x, y); x += colWidths[0];
        ctx.fillText(`(1/${s.n+1},1/${s.n}]`, x, y); x += colWidths[1];
        ctx.fillText(s.exact !== null ? s.exact.toString() : '-', x, y); x += colWidths[2];
        ctx.fillText(s.predicted.toFixed(1), x, y); x += colWidths[3];
        
        const errColor = Math.abs(s.relError) < 1 ? '#22c55e' : Math.abs(s.relError) < 5 ? '#f59e0b' : '#ef4444';
        ctx.fillStyle = errColor;
        ctx.fillText((s.relError !== null ? s.relError.toFixed(2) + '%' : '-'), x, y); x += colWidths[4];
        
        if (includeCategories) {
            ctx.fillStyle = '#f59e0b';
            ctx.fillText((s.primeCount || '-').toString(), x, y); x += colWidths[5];
            ctx.fillStyle = '#6366f1';
            ctx.fillText((s.compositeCount || '-').toString(), x, y); x += colWidths[6];
            ctx.fillStyle = '#22c55e';
            ctx.fillText((s.ppCount || '-').toString(), x, y); x += colWidths[7];
            ctx.fillStyle = '#f59e0b';
            ctx.fillText((s.pcCount || '-').toString(), x, y); x += colWidths[8];
            ctx.fillStyle = '#6366f1';
            ctx.fillText((s.cpCount || '-').toString(), x, y); x += colWidths[9];
            ctx.fillStyle = '#94a3b8';
            ctx.fillText((s.ccCount || '-').toString(), x, y);
        }
    });
    
    // Footer
    ctx.fillStyle = '#475569';
    ctx.font = '20px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io | ' + new Date().toISOString().slice(0,10), width/2, height - 30);
    
    // Download
    const link = document.createElement('a');
    link.download = `farey_sectors_${startSector}-${endSector}_N${state.nMax}_4K_${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
    
    closeSectorExportDialog();
}

</script>
</body>
</html>
